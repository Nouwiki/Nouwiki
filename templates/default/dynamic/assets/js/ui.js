/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	// CSS
	__webpack_require__(1);
	__webpack_require__(5);

	// JS
	__webpack_require__(7);

/***/ },
/* 1 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 2 */,
/* 3 */,
/* 4 */,
/* 5 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 6 */,
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	var origin = __webpack_require__(8);

	var parse = __webpack_require__(9);
	var $ = __webpack_require__(126);
	__webpack_require__(127);
	var CodeMirror = __webpack_require__(129);
	__webpack_require__(130);
	__webpack_require__(131);
	__webpack_require__(132);

	console.log("NEW");
	var config;
	var template;
	var ready = 2;
	$.get("/config.toml", function (c) {
	  config = c;
	  ready -= 1;
	  if (ready == 0) {
	    $("#controles").removeClass("disabled");
	  }
	});
	$.get("/template_assets/dynamic/dynamic.dot.jst", function (t) {
	  template = t;
	  ready -= 1;
	  if (ready == 0) {
	    $("#controles").removeClass("disabled");
	  }
	});

	// parse.parse(markup).html

	var myCodeMirror = CodeMirror.fromTextArea($("#editor textarea")[0], {
	  lineWrapping: true,
	  theme: 'prose-bright',
	  mode: "markdown"
	});

	function getMarkupText() {
	  $.ajax(origin.markup_loc, {
	    dataType: 'text',
	    type: 'GET',
	    cache: false,
	    success: function (text) {
	      myCodeMirror.setValue(text);
	    } });
	}
	$("#edit").click(function () {
	  if (ready == 0) {
	    edit();
	  }
	});
	//var editing = false;
	function edit() {
	  $("#edit").hide();
	  $("#discard").show();
	  $("#save").show();

	  $("#editor").show();
	  $("#content").hide();
	  getMarkupText();

	  //editing = !editor_showing;
	}

	$("#discard").click(function () {
	  discard();
	});
	function discard() {
	  $("#edit").show();
	  $("#discard").hide();
	  $("#save").hide();

	  $("#editor").hide();
	  $("#content").show();
	}

	$("#save").click(function () {
	  save();
	});
	function save() {
	  $("#edit").show();
	  $("#discard").hide();
	  $("#save").hide();

	  $("#editor").hide();
	  $("#content").show();
	  $.ajax({
	    url: '/api/modify',
	    type: 'PUT',
	    data: myCodeMirror.getValue(),
	    contentType: "text/plain",
	    success: function (result) {
	      console.log(result);
	    }
	  });
	  document.write(parse.parse(myCodeMirror.getValue(), config, template, wiki));
	  document.close();
	}

/***/ },
/* 8 */
/***/ function(module, exports) {

	var origin = window.location.origin;
	var loc = decodeURI(window.location.href);

	var page = loc.split("/");
	page = page[page.length - 1].split("?")[0];
	page = page || "index";

	var root = loc;
	if (loc[loc.length - 1] != "/") {
	  root = loc.replace("/" + page, "/");
	}

	var git = root.split("/");
	git_user = git[2].split(".")[0];
	git_repo = git[3];
	git_repo_url = "https://github.com/" + git_user + "/" + git_repo + "/";
	git_clone_url = "https://github.com/" + git_user + "/" + git_repo + ".git";

	//var wiki = loc.split("/");
	//wiki = wiki[wiki.length-3];

	var markup_page = page;
	var markup_loc = root + "markup/" + markup_page + ".md";

	exports.markup_loc = markup_loc;

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	var matter = __webpack_require__(10);
	var doT = __webpack_require__(54);
	//var hljs = require('highlight.js') // https://highlightjs.org/
	//hljs.configure({classPrefix: ''});
	//hljs.initHighlightingOnLoad();

	var md = __webpack_require__(56)({
		html: true,
		linkify: true,
		typographer: true /*,
	                   highlight: function (str, lang) {
	                   if (lang && hljs.getLanguage(lang)) {
	                   try {
	                   return hljs.highlight(lang, str).value;
	                   } catch (__) {}
	                   }
	                   try {
	                   return hljs.highlightAuto(str).value;
	                   } catch (__) {}
	                   return ''; // use external default escaping
	                   }*/
	}).use(__webpack_require__(125)); //.use(require('markdown-it-attrs'));

	/* --- */

	function fragment(data) {
		var content = matter(data, { lang: 'toml', delims: ['+++', '+++'] });
		console.log(content.data.title);
		markData = content.content;
		if (content.data.title != undefined) {
			markData = "# " + content.data.title + "\n\n" + markData;
		}
		html = md.render(markData);
		return { html: html, content: content.data };
	}

	function parse(markup, config, template, wiki) {
		var data = fragment(markup); // .html .content.*

		template_data = {
			wiki: wiki,
			html: data.html,
			title: data.content.title,
			local_js: data.content.js,
			local_css: data.content.css,
			global_js: config.js,
			global_css: config.css
		};

		var output = data;
		if (template != undefined) {
			var temp = doT.template(template);
			output = temp(template_data);
		} else {
			output = template_data.html;
		}
		return output;
	}

	exports.parse = parse;

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var fs = __webpack_require__(11);
	var extend = __webpack_require__(12);
	var parsers = __webpack_require__(14);

	/**
	 * Expose `matter()`
	 */

	module.exports = matter;

	/**
	 * Parses a `string` of front-matter with the given `options`,
	 * and returns an object.
	 *
	 * ```js
	 * matter('---\ntitle: foo\n---\nbar');
	 * //=> {data: {title: 'foo'}, content: 'bar', orig: '---\ntitle: foo\n---\nbar'}
	 * ```
	 *
	 * @param {String} `string` The string to parse.
	 * @param {Object} `options`
	 *   @option {Array} [options] `delims` Custom delimiters formatted as an array. The default is `['---', '---']`.
	 *   @option {Function} [options] `parser` Parser function to use. [js-yaml] is the default.
	 * @return {Object} Valid JSON
	 * @api public
	 */

	function matter(str, options) {
	  if (typeof str !== 'string') {
	    throw new Error('gray-matter expects a string');
	  }

	  // default results to build up
	  var res = { orig: str, data: {}, content: str };
	  if (str === '') {
	    return res;
	  }

	  // delimiters
	  var delims = arrayify(options && options.delims || '---');
	  var a = delims[0];

	  // strip byte order marks
	  str = stripBom(str);

	  // if the first delim isn't the first thing, return
	  if (!isFirst(str, a)) {
	    return res;
	  }

	  var b = '\n' + (delims[1] || delims[0]);
	  var alen = a.length;

	  // if the next character after the first delim
	  // is a character in the first delim, then just
	  // return the default object. it's either a bad
	  // delim or not a delimiter at all.
	  if (a.indexOf(str.charAt(alen + 1)) !== -1) {
	    return res;
	  }

	  var len = str.length;

	  // find the index of the next delimiter before
	  // going any further. If not found, return.
	  var end = str.indexOf(b, alen + 1);
	  if (end === -1) {
	    end = len;
	  }

	  // detect a language, if defined
	  var lang = str.slice(alen, str.indexOf('\n'));
	  // measure the lang before trimming whitespace
	  var start = alen + lang.length;

	  var opts = options || {};
	  opts.lang = opts.lang || 'yaml';
	  lang = lang && lang.trim() || opts.lang;

	  // get the front matter (data) string
	  var data = str.slice(start, end).trim();
	  if (data) {
	    // if data exists, see if we have a matching parser
	    var fn = opts.parser || parsers[lang];
	    if (typeof fn === 'function') {
	      // run the parser on the data string
	      res.data = fn(data, opts);
	    } else {
	      throw new Error('gray-matter cannot find a parser for: ' + str);
	    }
	  }

	  // grab the content from the string, stripping
	  // an optional new line after the second delim
	  var con = str.substr(end + b.length);
	  if (con.charAt(0) === '\n') {
	    con = con.substr(1);
	  }

	  res.content = con;
	  return res;
	}

	/**
	 * Expose `parsers`
	 *
	 * @type {Object}
	 */

	matter.parsers = parsers;

	/**
	 * Requires cache
	 */

	var YAML = matter.parsers.requires.yaml || (matter.parsers.requires.yaml = __webpack_require__(17));

	/**
	 * Read a file and parse front matter. Returns the same object
	 * as `matter()`.
	 *
	 * ```js
	 * matter.read('home.md');
	 * ```
	 *
	 * @param {String} `fp` file path of the file to read.
	 * @param {Object} `options` Options to pass to gray-matter.
	 * @return {Object}
	 * @api public
	 */

	matter.read = function (fp, options) {
	  var str = fs.readFileSync(fp, 'utf8');
	  var obj = matter(str, options);
	  return extend(obj, {
	    path: fp
	  });
	};

	/**
	 * Stringify an object to front-matter-formatted YAML, and
	 * concatenate it to the given string.
	 *
	 * ```js
	 * matter.stringify('foo bar baz', {title: 'Home'});
	 * ```
	 * Results in:
	 *
	 * ```yaml
	 * ---
	 * title: Home
	 * ---
	 * foo bar baz
	 * ```
	 *
	 * @param {String} `str` The content string to append to stringified front-matter.
	 * @param {Object} `data` Front matter to stringify.
	 * @param {Object} `options` Options to pass to js-yaml
	 * @return {String}
	 * @api public
	 */

	matter.stringify = function (str, data, options) {
	  var delims = arrayify(options && options.delims || '---');
	  var res = '';
	  res += delims[0] + '\n';
	  res += YAML.safeDump(data, options);
	  res += (delims[1] || delims[0]) + '\n';
	  res += str + '\n';
	  return res;
	};

	/**
	 * Return true if the given `string` has front matter.
	 *
	 * @param  {String} `string`
	 * @param  {Object} `options`
	 * @return {Boolean} True if front matter exists.
	 */

	matter.test = function (str, options) {
	  var delims = arrayify(options && options.delims || '---');
	  return isFirst(str, delims[0]);
	};

	/**
	 * Return true if the given `ch` the first
	 * thing in the string.
	 */

	function isFirst(str, ch) {
	  return str.substr(0, ch.length) === ch;
	}

	/**
	 * Utility to strip byte order marks
	 */

	function stripBom(str) {
	  return str.charAt(0) === '\uFEFF' ? str.slice(1) : str;
	}

	/**
	 * Typecast `val` to an array.
	 */

	function arrayify(val) {
	  return !Array.isArray(val) ? [val] : val;
	}

/***/ },
/* 11 */
/***/ function(module, exports) {

	

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var isObject = __webpack_require__(13);

	module.exports = function extend(o /*, objects*/) {
	  if (!isObject(o)) {
	    o = {};
	  }

	  var len = arguments.length;
	  for (var i = 1; i < len; i++) {
	    var obj = arguments[i];

	    if (isObject(obj)) {
	      assign(o, obj);
	    }
	  }
	  return o;
	};

	function assign(a, b) {
	  for (var key in b) {
	    if (hasOwn(b, key)) {
	      a[key] = b[key];
	    }
	  }
	}

	/**
	 * Returns true if the given `key` is an own property of `obj`.
	 */

	function hasOwn(obj, key) {
	  return Object.prototype.hasOwnProperty.call(obj, key);
	}

/***/ },
/* 13 */
/***/ function(module, exports) {

	/*!
	 * is-extendable <https://github.com/jonschlinkert/is-extendable>
	 *
	 * Copyright (c) 2015, Jon Schlinkert.
	 * Licensed under the MIT License.
	 */

	'use strict';

	module.exports = function isExtendable(val) {
	  return typeof val !== 'undefined' && val !== null && (typeof val === 'object' || typeof val === 'function');
	};

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * gray-matter <https://github.com/jonschlinkert/gray-matter.git>
	 *
	 * Copyright (c) 2014-2015, Jon Schlinkert.
	 * Licensed under the MIT License.
	 */

	'use strict'

	/**
	 * Module dependencies
	 */

	;
	var extend = __webpack_require__(12);
	var red = __webpack_require__(15);

	/**
	 * Expose `parser` module
	 */

	var parser = module.exports;

	/**
	 * Requires cache.
	 */

	parser.requires = {};

	/**
	 * Parse YAML front matter
	 *
	 * @param  {String} `str` The string to parse.
	 * @param  {Object} `options` Options to pass to [js-yaml].
	 * @return {Object} Parsed object of data.
	 * @api public
	 */

	parser.yaml = function (str, options) {
	  var opts = extend({ strict: false, safeLoad: false }, options);
	  try {
	    var YAML = parser.requires.yaml || (parser.requires.yaml = __webpack_require__(17));
	    return opts.safeLoad ? YAML.safeLoad(str, options) : YAML.load(str, options);
	  } catch (err) {
	    if (opts.strict) {
	      throw new SyntaxError(msg('js-yaml', err));
	    } else {
	      return {};
	    }
	  }
	};

	/**
	 * Parse JSON front matter
	 *
	 * @param  {String} `str` The string to parse.
	 * @return {Object} Parsed object of data.
	 * @api public
	 */

	parser.json = function (str, options) {
	  var opts = extend({ strict: false }, options);
	  try {
	    return JSON.parse(str);
	  } catch (err) {
	    if (opts.strict) {
	      throw new SyntaxError(msg('JSON', err));
	    } else {
	      return {};
	    }
	  }
	};

	/**
	 * Parse JavaScript front matter. To use javascript front-matter, you must
	 * set `options.eval` to `true`.
	 *
	 * By default, javascript code is wrapped in a function that is immediately
	 * executed when the parser is called. Thus, to be returned as a useful object,
	 * code should be written as object properties.
	 *
	 * **Example:**
	 *
	 * ```markdown
	 * ---js
	 * title: 'autodetect-javascript',
	 * // this function won't be invoked when the parser is called
	 * fn: {
	 *   reverse: function(str) {
	 *     return str.split('').reverse().join('');
	 *   }
	 * }
	 * ---
	 * ```
	 *
	 * @param  {String} `str` The string to parse.
	 * @param  {Object} `options` Set `options.wrapped` to `false` to enable writing raw, un-wrapped javascript.
	 * @return {Object} Parsed object of data.
	 * @api public
	 */

	parser.javascript = function (str, options) {
	  var opts = extend({ wrapped: true, eval: false, strict: false }, options);
	  if (opts.eval) {
	    if (opts.wrapped) {
	      str = 'function data() {return {' + str + '}; } data();';
	    }
	    try {
	      return eval(str);
	    } catch (err) {
	      throw new SyntaxError(msg('javascript', err));
	    }
	    return {};
	  } else {

	    // if `eval` isn't set
	    if (opts.strict) {
	      throw new Error(evalError('javascript'));
	    } else {
	      console.error(evalError('javascript', true));
	    }
	  }
	};

	/**
	 * Alias for `parse.javascript()`.
	 *
	 * @api public
	 */

	parser.js = parser.javascript;

	/**
	 * Parse Coffee-Script front matter. To use coffee front-matter, you must
	 * set `options.eval` to `true`.
	 *
	 * @param  {String} `str` The string to parse.
	 * @param  {Object} `options` Options to pass to [coffee-script].
	 * @return {Object} Parsed object of data.
	 * @api public
	 */

	parser.coffee = function (str, options) {
	  var opts = extend({ eval: false, strict: false }, options);
	  if (opts.eval) {
	    try {
	      var coffee = parser.requires.coffee || (parser.requires.coffee = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"coffee-script\""); e.code = 'MODULE_NOT_FOUND'; throw e; }())));
	      return coffee['eval'](str, options);
	    } catch (err) {
	      throw new SyntaxError(msg('coffee-script', err));
	    }
	  } else {

	    // if `eval` isn't set
	    if (opts.strict) {
	      throw new Error(evalError('coffee'));
	    } else {
	      console.error(evalError('coffee', true));
	    }
	  }
	};

	/**
	 * Alias for `parse.coffee()`.
	 *
	 * @api public
	 */

	parser.cson = parser.coffee;

	/**
	 * Parse TOML front matter.
	 *
	 * @param  {String} `str` The string to parse.
	 * @param  {Object} `options` Options to pass to [toml-node].
	 * @return {Object} Parsed object of data.
	 * @api public
	 */

	parser.toml = function (str, opts) {
	  try {
	    var toml = parser.requires.toml || (parser.requires.toml = __webpack_require__(51));
	    return toml.parse(str);
	  } catch (err) {
	    if (opts.strict) {
	      throw new SyntaxError(msg('TOML', err));
	    } else {
	      return {};
	    }
	  }
	};

	/**
	 * Normalize error messages
	 */

	function msg(lang, err) {
	  return 'gray-matter parser [' + lang + ']: ' + err;
	}

	function evalError(lang, color) {
	  var msg = '[gray-matter]: to parse ' + lang + ' set `options.eval` to `true`';
	  return color ? red(msg) : msg;
	}

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * ansi-red <https://github.com/jonschlinkert/ansi-red>
	 *
	 * Copyright (c) 2015, Jon Schlinkert.
	 * Licensed under the MIT License.
	 */

	'use strict';

	var wrap = __webpack_require__(16);

	module.exports = function red(message) {
	  return wrap(31, 39, message);
	};

/***/ },
/* 16 */
/***/ function(module, exports) {

	'use strict';

	module.exports = function (a, b, msg) {
	  return '\u001b[' + a + 'm' + msg + '\u001b[' + b + 'm';
	};

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var yaml = __webpack_require__(18);

	module.exports = yaml;

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var loader = __webpack_require__(19);
	var dumper = __webpack_require__(50);

	function deprecated(name) {
	  return function () {
	    throw new Error('Function ' + name + ' is deprecated and cannot be used.');
	  };
	}

	module.exports.Type = __webpack_require__(27);
	module.exports.Schema = __webpack_require__(26);
	module.exports.FAILSAFE_SCHEMA = __webpack_require__(30);
	module.exports.JSON_SCHEMA = __webpack_require__(29);
	module.exports.CORE_SCHEMA = __webpack_require__(28);
	module.exports.DEFAULT_SAFE_SCHEMA = __webpack_require__(25);
	module.exports.DEFAULT_FULL_SCHEMA = __webpack_require__(45);
	module.exports.load = loader.load;
	module.exports.loadAll = loader.loadAll;
	module.exports.safeLoad = loader.safeLoad;
	module.exports.safeLoadAll = loader.safeLoadAll;
	module.exports.dump = dumper.dump;
	module.exports.safeDump = dumper.safeDump;
	module.exports.YAMLException = __webpack_require__(21);

	// Deprecated schema names from JS-YAML 2.0.x
	module.exports.MINIMAL_SCHEMA = __webpack_require__(30);
	module.exports.SAFE_SCHEMA = __webpack_require__(25);
	module.exports.DEFAULT_SCHEMA = __webpack_require__(45);

	// Deprecated functions from JS-YAML 1.x.x
	module.exports.scan = deprecated('scan');
	module.exports.parse = deprecated('parse');
	module.exports.compose = deprecated('compose');
	module.exports.addConstructor = deprecated('addConstructor');

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'

	/*eslint-disable max-len,no-use-before-define*/

	;
	var common = __webpack_require__(20);
	var YAMLException = __webpack_require__(21);
	var Mark = __webpack_require__(24);
	var DEFAULT_SAFE_SCHEMA = __webpack_require__(25);
	var DEFAULT_FULL_SCHEMA = __webpack_require__(45);

	var _hasOwnProperty = Object.prototype.hasOwnProperty;

	var CONTEXT_FLOW_IN = 1;
	var CONTEXT_FLOW_OUT = 2;
	var CONTEXT_BLOCK_IN = 3;
	var CONTEXT_BLOCK_OUT = 4;

	var CHOMPING_CLIP = 1;
	var CHOMPING_STRIP = 2;
	var CHOMPING_KEEP = 3;

	var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
	var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
	var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
	var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
	var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;

	function is_EOL(c) {
	  return c === 0x0A /* LF */ || c === 0x0D /* CR */;
	}

	function is_WHITE_SPACE(c) {
	  return c === 0x09 /* Tab */ || c === 0x20 /* Space */;
	}

	function is_WS_OR_EOL(c) {
	  return c === 0x09 /* Tab */ || c === 0x20 /* Space */ || c === 0x0A /* LF */ || c === 0x0D /* CR */;
	}

	function is_FLOW_INDICATOR(c) {
	  return 0x2C /* , */ === c || 0x5B /* [ */ === c || 0x5D /* ] */ === c || 0x7B /* { */ === c || 0x7D /* } */ === c;
	}

	function fromHexCode(c) {
	  var lc;

	  if (0x30 /* 0 */ <= c && c <= 0x39 /* 9 */) {
	      return c - 0x30;
	    }

	  /*eslint-disable no-bitwise*/
	  lc = c | 0x20;

	  if (0x61 /* a */ <= lc && lc <= 0x66 /* f */) {
	      return lc - 0x61 + 10;
	    }

	  return -1;
	}

	function escapedHexLen(c) {
	  if (c === 0x78 /* x */) {
	      return 2;
	    }
	  if (c === 0x75 /* u */) {
	      return 4;
	    }
	  if (c === 0x55 /* U */) {
	      return 8;
	    }
	  return 0;
	}

	function fromDecimalCode(c) {
	  if (0x30 /* 0 */ <= c && c <= 0x39 /* 9 */) {
	      return c - 0x30;
	    }

	  return -1;
	}

	function simpleEscapeSequence(c) {
	  return c === 0x30 /* 0 */ ? '\x00' : c === 0x61 /* a */ ? '\x07' : c === 0x62 /* b */ ? '\x08' : c === 0x74 /* t */ ? '\x09' : c === 0x09 /* Tab */ ? '\x09' : c === 0x6E /* n */ ? '\x0A' : c === 0x76 /* v */ ? '\x0B' : c === 0x66 /* f */ ? '\x0C' : c === 0x72 /* r */ ? '\x0D' : c === 0x65 /* e */ ? '\x1B' : c === 0x20 /* Space */ ? ' ' : c === 0x22 /* " */ ? '\x22' : c === 0x2F /* / */ ? '/' : c === 0x5C /* \ */ ? '\x5C' : c === 0x4E /* N */ ? '\x85' : c === 0x5F /* _ */ ? '\xA0' : c === 0x4C /* L */ ? '\u2028' : c === 0x50 /* P */ ? '\u2029' : '';
	}

	function charFromCodepoint(c) {
	  if (c <= 0xFFFF) {
	    return String.fromCharCode(c);
	  }
	  // Encode UTF-16 surrogate pair
	  // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF
	  return String.fromCharCode((c - 0x010000 >> 10) + 0xD800, (c - 0x010000 & 0x03FF) + 0xDC00);
	}

	var simpleEscapeCheck = new Array(256); // integer, for fast access
	var simpleEscapeMap = new Array(256);
	for (var i = 0; i < 256; i++) {
	  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
	  simpleEscapeMap[i] = simpleEscapeSequence(i);
	}

	function State(input, options) {
	  this.input = input;

	  this.filename = options['filename'] || null;
	  this.schema = options['schema'] || DEFAULT_FULL_SCHEMA;
	  this.onWarning = options['onWarning'] || null;
	  this.legacy = options['legacy'] || false;

	  this.implicitTypes = this.schema.compiledImplicit;
	  this.typeMap = this.schema.compiledTypeMap;

	  this.length = input.length;
	  this.position = 0;
	  this.line = 0;
	  this.lineStart = 0;
	  this.lineIndent = 0;

	  this.documents = [];

	  /*
	  this.version;
	  this.checkLineBreaks;
	  this.tagMap;
	  this.anchorMap;
	  this.tag;
	  this.anchor;
	  this.kind;
	  this.result;*/
	}

	function generateError(state, message) {
	  return new YAMLException(message, new Mark(state.filename, state.input, state.position, state.line, state.position - state.lineStart));
	}

	function throwError(state, message) {
	  throw generateError(state, message);
	}

	function throwWarning(state, message) {
	  if (state.onWarning) {
	    state.onWarning.call(null, generateError(state, message));
	  }
	}

	var directiveHandlers = {

	  YAML: function handleYamlDirective(state, name, args) {

	    var match, major, minor;

	    if (null !== state.version) {
	      throwError(state, 'duplication of %YAML directive');
	    }

	    if (1 !== args.length) {
	      throwError(state, 'YAML directive accepts exactly one argument');
	    }

	    match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);

	    if (null === match) {
	      throwError(state, 'ill-formed argument of the YAML directive');
	    }

	    major = parseInt(match[1], 10);
	    minor = parseInt(match[2], 10);

	    if (1 !== major) {
	      throwError(state, 'unacceptable YAML version of the document');
	    }

	    state.version = args[0];
	    state.checkLineBreaks = minor < 2;

	    if (1 !== minor && 2 !== minor) {
	      throwWarning(state, 'unsupported YAML version of the document');
	    }
	  },

	  TAG: function handleTagDirective(state, name, args) {

	    var handle, prefix;

	    if (2 !== args.length) {
	      throwError(state, 'TAG directive accepts exactly two arguments');
	    }

	    handle = args[0];
	    prefix = args[1];

	    if (!PATTERN_TAG_HANDLE.test(handle)) {
	      throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');
	    }

	    if (_hasOwnProperty.call(state.tagMap, handle)) {
	      throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
	    }

	    if (!PATTERN_TAG_URI.test(prefix)) {
	      throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');
	    }

	    state.tagMap[handle] = prefix;
	  }
	};

	function captureSegment(state, start, end, checkJson) {
	  var _position, _length, _character, _result;

	  if (start < end) {
	    _result = state.input.slice(start, end);

	    if (checkJson) {
	      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
	        _character = _result.charCodeAt(_position);
	        if (!(0x09 === _character || 0x20 <= _character && _character <= 0x10FFFF)) {
	          throwError(state, 'expected valid JSON character');
	        }
	      }
	    } else if (PATTERN_NON_PRINTABLE.test(_result)) {
	      throwError(state, 'the stream contains non-printable characters');
	    }

	    state.result += _result;
	  }
	}

	function mergeMappings(state, destination, source) {
	  var sourceKeys, key, index, quantity;

	  if (!common.isObject(source)) {
	    throwError(state, 'cannot merge mappings; the provided source object is unacceptable');
	  }

	  sourceKeys = Object.keys(source);

	  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
	    key = sourceKeys[index];

	    if (!_hasOwnProperty.call(destination, key)) {
	      destination[key] = source[key];
	    }
	  }
	}

	function storeMappingPair(state, _result, keyTag, keyNode, valueNode) {
	  var index, quantity;

	  keyNode = String(keyNode);

	  if (null === _result) {
	    _result = {};
	  }

	  if ('tag:yaml.org,2002:merge' === keyTag) {
	    if (Array.isArray(valueNode)) {
	      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
	        mergeMappings(state, _result, valueNode[index]);
	      }
	    } else {
	      mergeMappings(state, _result, valueNode);
	    }
	  } else {
	    _result[keyNode] = valueNode;
	  }

	  return _result;
	}

	function readLineBreak(state) {
	  var ch;

	  ch = state.input.charCodeAt(state.position);

	  if (0x0A /* LF */ === ch) {
	    state.position++;
	  } else if (0x0D /* CR */ === ch) {
	    state.position++;
	    if (0x0A /* LF */ === state.input.charCodeAt(state.position)) {
	      state.position++;
	    }
	  } else {
	    throwError(state, 'a line break is expected');
	  }

	  state.line += 1;
	  state.lineStart = state.position;
	}

	function skipSeparationSpace(state, allowComments, checkIndent) {
	  var lineBreaks = 0,
	      ch = state.input.charCodeAt(state.position);

	  while (0 !== ch) {
	    while (is_WHITE_SPACE(ch)) {
	      ch = state.input.charCodeAt(++state.position);
	    }

	    if (allowComments && 0x23 /* # */ === ch) {
	      do {
	        ch = state.input.charCodeAt(++state.position);
	      } while (ch !== 0x0A /* LF */ && ch !== 0x0D /* CR */ && 0 !== ch);
	    }

	    if (is_EOL(ch)) {
	      readLineBreak(state);

	      ch = state.input.charCodeAt(state.position);
	      lineBreaks++;
	      state.lineIndent = 0;

	      while (0x20 /* Space */ === ch) {
	        state.lineIndent++;
	        ch = state.input.charCodeAt(++state.position);
	      }
	    } else {
	      break;
	    }
	  }

	  if (-1 !== checkIndent && 0 !== lineBreaks && state.lineIndent < checkIndent) {
	    throwWarning(state, 'deficient indentation');
	  }

	  return lineBreaks;
	}

	function testDocumentSeparator(state) {
	  var _position = state.position,
	      ch;

	  ch = state.input.charCodeAt(_position);

	  // Condition state.position === state.lineStart is tested
	  // in parent on each call, for efficiency. No needs to test here again.
	  if ((0x2D /* - */ === ch || 0x2E /* . */ === ch) && state.input.charCodeAt(_position + 1) === ch && state.input.charCodeAt(_position + 2) === ch) {

	    _position += 3;

	    ch = state.input.charCodeAt(_position);

	    if (ch === 0 || is_WS_OR_EOL(ch)) {
	      return true;
	    }
	  }

	  return false;
	}

	function writeFoldedLines(state, count) {
	  if (1 === count) {
	    state.result += ' ';
	  } else if (count > 1) {
	    state.result += common.repeat('\n', count - 1);
	  }
	}

	function readPlainScalar(state, nodeIndent, withinFlowCollection) {
	  var preceding,
	      following,
	      captureStart,
	      captureEnd,
	      hasPendingContent,
	      _line,
	      _lineStart,
	      _lineIndent,
	      _kind = state.kind,
	      _result = state.result,
	      ch;

	  ch = state.input.charCodeAt(state.position);

	  if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || 0x23 /* # */ === ch || 0x26 /* & */ === ch || 0x2A /* * */ === ch || 0x21 /* ! */ === ch || 0x7C /* | */ === ch || 0x3E /* > */ === ch || 0x27 /* ' */ === ch || 0x22 /* " */ === ch || 0x25 /* % */ === ch || 0x40 /* @ */ === ch || 0x60 /* ` */ === ch) {
	    return false;
	  }

	  if (0x3F /* ? */ === ch || 0x2D /* - */ === ch) {
	    following = state.input.charCodeAt(state.position + 1);

	    if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
	      return false;
	    }
	  }

	  state.kind = 'scalar';
	  state.result = '';
	  captureStart = captureEnd = state.position;
	  hasPendingContent = false;

	  while (0 !== ch) {
	    if (0x3A /* : */ === ch) {
	      following = state.input.charCodeAt(state.position + 1);

	      if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
	        break;
	      }
	    } else if (0x23 /* # */ === ch) {
	      preceding = state.input.charCodeAt(state.position - 1);

	      if (is_WS_OR_EOL(preceding)) {
	        break;
	      }
	    } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
	      break;
	    } else if (is_EOL(ch)) {
	      _line = state.line;
	      _lineStart = state.lineStart;
	      _lineIndent = state.lineIndent;
	      skipSeparationSpace(state, false, -1);

	      if (state.lineIndent >= nodeIndent) {
	        hasPendingContent = true;
	        ch = state.input.charCodeAt(state.position);
	        continue;
	      } else {
	        state.position = captureEnd;
	        state.line = _line;
	        state.lineStart = _lineStart;
	        state.lineIndent = _lineIndent;
	        break;
	      }
	    }

	    if (hasPendingContent) {
	      captureSegment(state, captureStart, captureEnd, false);
	      writeFoldedLines(state, state.line - _line);
	      captureStart = captureEnd = state.position;
	      hasPendingContent = false;
	    }

	    if (!is_WHITE_SPACE(ch)) {
	      captureEnd = state.position + 1;
	    }

	    ch = state.input.charCodeAt(++state.position);
	  }

	  captureSegment(state, captureStart, captureEnd, false);

	  if (state.result) {
	    return true;
	  }

	  state.kind = _kind;
	  state.result = _result;
	  return false;
	}

	function readSingleQuotedScalar(state, nodeIndent) {
	  var ch, captureStart, captureEnd;

	  ch = state.input.charCodeAt(state.position);

	  if (0x27 /* ' */ !== ch) {
	    return false;
	  }

	  state.kind = 'scalar';
	  state.result = '';
	  state.position++;
	  captureStart = captureEnd = state.position;

	  while (0 !== (ch = state.input.charCodeAt(state.position))) {
	    if (0x27 /* ' */ === ch) {
	      captureSegment(state, captureStart, state.position, true);
	      ch = state.input.charCodeAt(++state.position);

	      if (0x27 /* ' */ === ch) {
	        captureStart = captureEnd = state.position;
	        state.position++;
	      } else {
	        return true;
	      }
	    } else if (is_EOL(ch)) {
	      captureSegment(state, captureStart, captureEnd, true);
	      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
	      captureStart = captureEnd = state.position;
	    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
	      throwError(state, 'unexpected end of the document within a single quoted scalar');
	    } else {
	      state.position++;
	      captureEnd = state.position;
	    }
	  }

	  throwError(state, 'unexpected end of the stream within a single quoted scalar');
	}

	function readDoubleQuotedScalar(state, nodeIndent) {
	  var captureStart, captureEnd, hexLength, hexResult, tmp, ch;

	  ch = state.input.charCodeAt(state.position);

	  if (0x22 /* " */ !== ch) {
	    return false;
	  }

	  state.kind = 'scalar';
	  state.result = '';
	  state.position++;
	  captureStart = captureEnd = state.position;

	  while (0 !== (ch = state.input.charCodeAt(state.position))) {
	    if (0x22 /* " */ === ch) {
	      captureSegment(state, captureStart, state.position, true);
	      state.position++;
	      return true;
	    } else if (0x5C /* \ */ === ch) {
	      captureSegment(state, captureStart, state.position, true);
	      ch = state.input.charCodeAt(++state.position);

	      if (is_EOL(ch)) {
	        skipSeparationSpace(state, false, nodeIndent);

	        // TODO: rework to inline fn with no type cast?
	      } else if (ch < 256 && simpleEscapeCheck[ch]) {
	          state.result += simpleEscapeMap[ch];
	          state.position++;
	        } else if ((tmp = escapedHexLen(ch)) > 0) {
	          hexLength = tmp;
	          hexResult = 0;

	          for (; hexLength > 0; hexLength--) {
	            ch = state.input.charCodeAt(++state.position);

	            if ((tmp = fromHexCode(ch)) >= 0) {
	              hexResult = (hexResult << 4) + tmp;
	            } else {
	              throwError(state, 'expected hexadecimal character');
	            }
	          }

	          state.result += charFromCodepoint(hexResult);

	          state.position++;
	        } else {
	          throwError(state, 'unknown escape sequence');
	        }

	      captureStart = captureEnd = state.position;
	    } else if (is_EOL(ch)) {
	      captureSegment(state, captureStart, captureEnd, true);
	      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
	      captureStart = captureEnd = state.position;
	    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
	      throwError(state, 'unexpected end of the document within a double quoted scalar');
	    } else {
	      state.position++;
	      captureEnd = state.position;
	    }
	  }

	  throwError(state, 'unexpected end of the stream within a double quoted scalar');
	}

	function readFlowCollection(state, nodeIndent) {
	  var readNext = true,
	      _line,
	      _tag = state.tag,
	      _result,
	      _anchor = state.anchor,
	      following,
	      terminator,
	      isPair,
	      isExplicitPair,
	      isMapping,
	      keyNode,
	      keyTag,
	      valueNode,
	      ch;

	  ch = state.input.charCodeAt(state.position);

	  if (ch === 0x5B /* [ */) {
	      terminator = 0x5D; /* ] */
	      isMapping = false;
	      _result = [];
	    } else if (ch === 0x7B /* { */) {
	      terminator = 0x7D; /* } */
	      isMapping = true;
	      _result = {};
	    } else {
	    return false;
	  }

	  if (null !== state.anchor) {
	    state.anchorMap[state.anchor] = _result;
	  }

	  ch = state.input.charCodeAt(++state.position);

	  while (0 !== ch) {
	    skipSeparationSpace(state, true, nodeIndent);

	    ch = state.input.charCodeAt(state.position);

	    if (ch === terminator) {
	      state.position++;
	      state.tag = _tag;
	      state.anchor = _anchor;
	      state.kind = isMapping ? 'mapping' : 'sequence';
	      state.result = _result;
	      return true;
	    } else if (!readNext) {
	      throwError(state, 'missed comma between flow collection entries');
	    }

	    keyTag = keyNode = valueNode = null;
	    isPair = isExplicitPair = false;

	    if (0x3F /* ? */ === ch) {
	      following = state.input.charCodeAt(state.position + 1);

	      if (is_WS_OR_EOL(following)) {
	        isPair = isExplicitPair = true;
	        state.position++;
	        skipSeparationSpace(state, true, nodeIndent);
	      }
	    }

	    _line = state.line;
	    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
	    keyTag = state.tag;
	    keyNode = state.result;
	    skipSeparationSpace(state, true, nodeIndent);

	    ch = state.input.charCodeAt(state.position);

	    if ((isExplicitPair || state.line === _line) && 0x3A /* : */ === ch) {
	      isPair = true;
	      ch = state.input.charCodeAt(++state.position);
	      skipSeparationSpace(state, true, nodeIndent);
	      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
	      valueNode = state.result;
	    }

	    if (isMapping) {
	      storeMappingPair(state, _result, keyTag, keyNode, valueNode);
	    } else if (isPair) {
	      _result.push(storeMappingPair(state, null, keyTag, keyNode, valueNode));
	    } else {
	      _result.push(keyNode);
	    }

	    skipSeparationSpace(state, true, nodeIndent);

	    ch = state.input.charCodeAt(state.position);

	    if (0x2C /* , */ === ch) {
	      readNext = true;
	      ch = state.input.charCodeAt(++state.position);
	    } else {
	      readNext = false;
	    }
	  }

	  throwError(state, 'unexpected end of the stream within a flow collection');
	}

	function readBlockScalar(state, nodeIndent) {
	  var captureStart,
	      folding,
	      chomping = CHOMPING_CLIP,
	      detectedIndent = false,
	      textIndent = nodeIndent,
	      emptyLines = 0,
	      atMoreIndented = false,
	      tmp,
	      ch;

	  ch = state.input.charCodeAt(state.position);

	  if (ch === 0x7C /* | */) {
	      folding = false;
	    } else if (ch === 0x3E /* > */) {
	      folding = true;
	    } else {
	    return false;
	  }

	  state.kind = 'scalar';
	  state.result = '';

	  while (0 !== ch) {
	    ch = state.input.charCodeAt(++state.position);

	    if (0x2B /* + */ === ch || 0x2D /* - */ === ch) {
	      if (CHOMPING_CLIP === chomping) {
	        chomping = 0x2B /* + */ === ch ? CHOMPING_KEEP : CHOMPING_STRIP;
	      } else {
	        throwError(state, 'repeat of a chomping mode identifier');
	      }
	    } else if ((tmp = fromDecimalCode(ch)) >= 0) {
	      if (tmp === 0) {
	        throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');
	      } else if (!detectedIndent) {
	        textIndent = nodeIndent + tmp - 1;
	        detectedIndent = true;
	      } else {
	        throwError(state, 'repeat of an indentation width identifier');
	      }
	    } else {
	      break;
	    }
	  }

	  if (is_WHITE_SPACE(ch)) {
	    do {
	      ch = state.input.charCodeAt(++state.position);
	    } while (is_WHITE_SPACE(ch));

	    if (0x23 /* # */ === ch) {
	      do {
	        ch = state.input.charCodeAt(++state.position);
	      } while (!is_EOL(ch) && 0 !== ch);
	    }
	  }

	  while (0 !== ch) {
	    readLineBreak(state);
	    state.lineIndent = 0;

	    ch = state.input.charCodeAt(state.position);

	    while ((!detectedIndent || state.lineIndent < textIndent) && 0x20 /* Space */ === ch) {
	      state.lineIndent++;
	      ch = state.input.charCodeAt(++state.position);
	    }

	    if (!detectedIndent && state.lineIndent > textIndent) {
	      textIndent = state.lineIndent;
	    }

	    if (is_EOL(ch)) {
	      emptyLines++;
	      continue;
	    }

	    // End of the scalar.
	    if (state.lineIndent < textIndent) {

	      // Perform the chomping.
	      if (chomping === CHOMPING_KEEP) {
	        state.result += common.repeat('\n', emptyLines);
	      } else if (chomping === CHOMPING_CLIP) {
	        if (detectedIndent) {
	          // i.e. only if the scalar is not empty.
	          state.result += '\n';
	        }
	      }

	      // Break this `while` cycle and go to the funciton's epilogue.
	      break;
	    }

	    // Folded style: use fancy rules to handle line breaks.
	    if (folding) {

	      // Lines starting with white space characters (more-indented lines) are not folded.
	      if (is_WHITE_SPACE(ch)) {
	        atMoreIndented = true;
	        state.result += common.repeat('\n', emptyLines + 1);

	        // End of more-indented block.
	      } else if (atMoreIndented) {
	          atMoreIndented = false;
	          state.result += common.repeat('\n', emptyLines + 1);

	          // Just one line break - perceive as the same line.
	        } else if (0 === emptyLines) {
	            if (detectedIndent) {
	              // i.e. only if we have already read some scalar content.
	              state.result += ' ';
	            }

	            // Several line breaks - perceive as different lines.
	          } else {
	              state.result += common.repeat('\n', emptyLines);
	            }

	      // Literal style: just add exact number of line breaks between content lines.
	    } else if (detectedIndent) {
	        // If current line isn't the first one - count line break from the last content line.
	        state.result += common.repeat('\n', emptyLines + 1);
	      } else {
	        // In case of the first content line - count only empty lines.
	        state.result += common.repeat('\n', emptyLines);
	      }

	    detectedIndent = true;
	    emptyLines = 0;
	    captureStart = state.position;

	    while (!is_EOL(ch) && 0 !== ch) {
	      ch = state.input.charCodeAt(++state.position);
	    }

	    captureSegment(state, captureStart, state.position, false);
	  }

	  return true;
	}

	function readBlockSequence(state, nodeIndent) {
	  var _line,
	      _tag = state.tag,
	      _anchor = state.anchor,
	      _result = [],
	      following,
	      detected = false,
	      ch;

	  if (null !== state.anchor) {
	    state.anchorMap[state.anchor] = _result;
	  }

	  ch = state.input.charCodeAt(state.position);

	  while (0 !== ch) {

	    if (0x2D /* - */ !== ch) {
	      break;
	    }

	    following = state.input.charCodeAt(state.position + 1);

	    if (!is_WS_OR_EOL(following)) {
	      break;
	    }

	    detected = true;
	    state.position++;

	    if (skipSeparationSpace(state, true, -1)) {
	      if (state.lineIndent <= nodeIndent) {
	        _result.push(null);
	        ch = state.input.charCodeAt(state.position);
	        continue;
	      }
	    }

	    _line = state.line;
	    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
	    _result.push(state.result);
	    skipSeparationSpace(state, true, -1);

	    ch = state.input.charCodeAt(state.position);

	    if ((state.line === _line || state.lineIndent > nodeIndent) && 0 !== ch) {
	      throwError(state, 'bad indentation of a sequence entry');
	    } else if (state.lineIndent < nodeIndent) {
	      break;
	    }
	  }

	  if (detected) {
	    state.tag = _tag;
	    state.anchor = _anchor;
	    state.kind = 'sequence';
	    state.result = _result;
	    return true;
	  }
	  return false;
	}

	function readBlockMapping(state, nodeIndent, flowIndent) {
	  var following,
	      allowCompact,
	      _line,
	      _tag = state.tag,
	      _anchor = state.anchor,
	      _result = {},
	      keyTag = null,
	      keyNode = null,
	      valueNode = null,
	      atExplicitKey = false,
	      detected = false,
	      ch;

	  if (null !== state.anchor) {
	    state.anchorMap[state.anchor] = _result;
	  }

	  ch = state.input.charCodeAt(state.position);

	  while (0 !== ch) {
	    following = state.input.charCodeAt(state.position + 1);
	    _line = state.line; // Save the current line.

	    //
	    // Explicit notation case. There are two separate blocks:
	    // first for the key (denoted by "?") and second for the value (denoted by ":")
	    //
	    if ((0x3F /* ? */ === ch || 0x3A /* : */ === ch) && is_WS_OR_EOL(following)) {

	      if (0x3F /* ? */ === ch) {
	        if (atExplicitKey) {
	          storeMappingPair(state, _result, keyTag, keyNode, null);
	          keyTag = keyNode = valueNode = null;
	        }

	        detected = true;
	        atExplicitKey = true;
	        allowCompact = true;
	      } else if (atExplicitKey) {
	        // i.e. 0x3A/* : */ === character after the explicit key.
	        atExplicitKey = false;
	        allowCompact = true;
	      } else {
	        throwError(state, 'incomplete explicit mapping pair; a key node is missed');
	      }

	      state.position += 1;
	      ch = following;

	      //
	      // Implicit notation case. Flow-style node as the key first, then ":", and the value.
	      //
	    } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {

	        if (state.line === _line) {
	          ch = state.input.charCodeAt(state.position);

	          while (is_WHITE_SPACE(ch)) {
	            ch = state.input.charCodeAt(++state.position);
	          }

	          if (0x3A /* : */ === ch) {
	            ch = state.input.charCodeAt(++state.position);

	            if (!is_WS_OR_EOL(ch)) {
	              throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');
	            }

	            if (atExplicitKey) {
	              storeMappingPair(state, _result, keyTag, keyNode, null);
	              keyTag = keyNode = valueNode = null;
	            }

	            detected = true;
	            atExplicitKey = false;
	            allowCompact = false;
	            keyTag = state.tag;
	            keyNode = state.result;
	          } else if (detected) {
	            throwError(state, 'can not read an implicit mapping pair; a colon is missed');
	          } else {
	            state.tag = _tag;
	            state.anchor = _anchor;
	            return true; // Keep the result of `composeNode`.
	          }
	        } else if (detected) {
	            throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');
	          } else {
	            state.tag = _tag;
	            state.anchor = _anchor;
	            return true; // Keep the result of `composeNode`.
	          }
	      } else {
	          break; // Reading is done. Go to the epilogue.
	        }

	    //
	    // Common reading code for both explicit and implicit notations.
	    //
	    if (state.line === _line || state.lineIndent > nodeIndent) {
	      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
	        if (atExplicitKey) {
	          keyNode = state.result;
	        } else {
	          valueNode = state.result;
	        }
	      }

	      if (!atExplicitKey) {
	        storeMappingPair(state, _result, keyTag, keyNode, valueNode);
	        keyTag = keyNode = valueNode = null;
	      }

	      skipSeparationSpace(state, true, -1);
	      ch = state.input.charCodeAt(state.position);
	    }

	    if (state.lineIndent > nodeIndent && 0 !== ch) {
	      throwError(state, 'bad indentation of a mapping entry');
	    } else if (state.lineIndent < nodeIndent) {
	      break;
	    }
	  }

	  //
	  // Epilogue.
	  //

	  // Special case: last mapping's node contains only the key in explicit notation.
	  if (atExplicitKey) {
	    storeMappingPair(state, _result, keyTag, keyNode, null);
	  }

	  // Expose the resulting mapping.
	  if (detected) {
	    state.tag = _tag;
	    state.anchor = _anchor;
	    state.kind = 'mapping';
	    state.result = _result;
	  }

	  return detected;
	}

	function readTagProperty(state) {
	  var _position,
	      isVerbatim = false,
	      isNamed = false,
	      tagHandle,
	      tagName,
	      ch;

	  ch = state.input.charCodeAt(state.position);

	  if (0x21 /* ! */ !== ch) {
	    return false;
	  }

	  if (null !== state.tag) {
	    throwError(state, 'duplication of a tag property');
	  }

	  ch = state.input.charCodeAt(++state.position);

	  if (0x3C /* < */ === ch) {
	    isVerbatim = true;
	    ch = state.input.charCodeAt(++state.position);
	  } else if (0x21 /* ! */ === ch) {
	    isNamed = true;
	    tagHandle = '!!';
	    ch = state.input.charCodeAt(++state.position);
	  } else {
	    tagHandle = '!';
	  }

	  _position = state.position;

	  if (isVerbatim) {
	    do {
	      ch = state.input.charCodeAt(++state.position);
	    } while (0 !== ch && 0x3E /* > */ !== ch);

	    if (state.position < state.length) {
	      tagName = state.input.slice(_position, state.position);
	      ch = state.input.charCodeAt(++state.position);
	    } else {
	      throwError(state, 'unexpected end of the stream within a verbatim tag');
	    }
	  } else {
	    while (0 !== ch && !is_WS_OR_EOL(ch)) {

	      if (0x21 /* ! */ === ch) {
	        if (!isNamed) {
	          tagHandle = state.input.slice(_position - 1, state.position + 1);

	          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
	            throwError(state, 'named tag handle cannot contain such characters');
	          }

	          isNamed = true;
	          _position = state.position + 1;
	        } else {
	          throwError(state, 'tag suffix cannot contain exclamation marks');
	        }
	      }

	      ch = state.input.charCodeAt(++state.position);
	    }

	    tagName = state.input.slice(_position, state.position);

	    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
	      throwError(state, 'tag suffix cannot contain flow indicator characters');
	    }
	  }

	  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
	    throwError(state, 'tag name cannot contain such characters: ' + tagName);
	  }

	  if (isVerbatim) {
	    state.tag = tagName;
	  } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
	    state.tag = state.tagMap[tagHandle] + tagName;
	  } else if ('!' === tagHandle) {
	    state.tag = '!' + tagName;
	  } else if ('!!' === tagHandle) {
	    state.tag = 'tag:yaml.org,2002:' + tagName;
	  } else {
	    throwError(state, 'undeclared tag handle "' + tagHandle + '"');
	  }

	  return true;
	}

	function readAnchorProperty(state) {
	  var _position, ch;

	  ch = state.input.charCodeAt(state.position);

	  if (0x26 /* & */ !== ch) {
	    return false;
	  }

	  if (null !== state.anchor) {
	    throwError(state, 'duplication of an anchor property');
	  }

	  ch = state.input.charCodeAt(++state.position);
	  _position = state.position;

	  while (0 !== ch && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
	    ch = state.input.charCodeAt(++state.position);
	  }

	  if (state.position === _position) {
	    throwError(state, 'name of an anchor node must contain at least one character');
	  }

	  state.anchor = state.input.slice(_position, state.position);
	  return true;
	}

	function readAlias(state) {
	  var _position, alias, ch;

	  ch = state.input.charCodeAt(state.position);

	  if (0x2A /* * */ !== ch) {
	    return false;
	  }

	  ch = state.input.charCodeAt(++state.position);
	  _position = state.position;

	  while (0 !== ch && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
	    ch = state.input.charCodeAt(++state.position);
	  }

	  if (state.position === _position) {
	    throwError(state, 'name of an alias node must contain at least one character');
	  }

	  alias = state.input.slice(_position, state.position);

	  if (!state.anchorMap.hasOwnProperty(alias)) {
	    throwError(state, 'unidentified alias "' + alias + '"');
	  }

	  state.result = state.anchorMap[alias];
	  skipSeparationSpace(state, true, -1);
	  return true;
	}

	function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
	  var allowBlockStyles,
	      allowBlockScalars,
	      allowBlockCollections,
	      indentStatus = 1,
	      // 1: this>parent, 0: this=parent, -1: this<parent
	  atNewLine = false,
	      hasContent = false,
	      typeIndex,
	      typeQuantity,
	      type,
	      flowIndent,
	      blockIndent;

	  state.tag = null;
	  state.anchor = null;
	  state.kind = null;
	  state.result = null;

	  allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;

	  if (allowToSeek) {
	    if (skipSeparationSpace(state, true, -1)) {
	      atNewLine = true;

	      if (state.lineIndent > parentIndent) {
	        indentStatus = 1;
	      } else if (state.lineIndent === parentIndent) {
	        indentStatus = 0;
	      } else if (state.lineIndent < parentIndent) {
	        indentStatus = -1;
	      }
	    }
	  }

	  if (1 === indentStatus) {
	    while (readTagProperty(state) || readAnchorProperty(state)) {
	      if (skipSeparationSpace(state, true, -1)) {
	        atNewLine = true;
	        allowBlockCollections = allowBlockStyles;

	        if (state.lineIndent > parentIndent) {
	          indentStatus = 1;
	        } else if (state.lineIndent === parentIndent) {
	          indentStatus = 0;
	        } else if (state.lineIndent < parentIndent) {
	          indentStatus = -1;
	        }
	      } else {
	        allowBlockCollections = false;
	      }
	    }
	  }

	  if (allowBlockCollections) {
	    allowBlockCollections = atNewLine || allowCompact;
	  }

	  if (1 === indentStatus || CONTEXT_BLOCK_OUT === nodeContext) {
	    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
	      flowIndent = parentIndent;
	    } else {
	      flowIndent = parentIndent + 1;
	    }

	    blockIndent = state.position - state.lineStart;

	    if (1 === indentStatus) {
	      if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
	        hasContent = true;
	      } else {
	        if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
	          hasContent = true;
	        } else if (readAlias(state)) {
	          hasContent = true;

	          if (null !== state.tag || null !== state.anchor) {
	            throwError(state, 'alias node should not have any properties');
	          }
	        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
	          hasContent = true;

	          if (null === state.tag) {
	            state.tag = '?';
	          }
	        }

	        if (null !== state.anchor) {
	          state.anchorMap[state.anchor] = state.result;
	        }
	      }
	    } else if (0 === indentStatus) {
	      // Special case: block sequences are allowed to have same indentation level as the parent.
	      // http://www.yaml.org/spec/1.2/spec.html#id2799784
	      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
	    }
	  }

	  if (null !== state.tag && '!' !== state.tag) {
	    if ('?' === state.tag) {
	      for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
	        type = state.implicitTypes[typeIndex];

	        // Implicit resolving is not allowed for non-scalar types, and '?'
	        // non-specific tag is only assigned to plain scalars. So, it isn't
	        // needed to check for 'kind' conformity.

	        if (type.resolve(state.result)) {
	          // `state.result` updated in resolver if matched
	          state.result = type.construct(state.result);
	          state.tag = type.tag;
	          if (null !== state.anchor) {
	            state.anchorMap[state.anchor] = state.result;
	          }
	          break;
	        }
	      }
	    } else if (_hasOwnProperty.call(state.typeMap, state.tag)) {
	      type = state.typeMap[state.tag];

	      if (null !== state.result && type.kind !== state.kind) {
	        throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
	      }

	      if (!type.resolve(state.result)) {
	        // `state.result` updated in resolver if matched
	        throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');
	      } else {
	        state.result = type.construct(state.result);
	        if (null !== state.anchor) {
	          state.anchorMap[state.anchor] = state.result;
	        }
	      }
	    } else {
	      throwError(state, 'unknown tag !<' + state.tag + '>');
	    }
	  }

	  return null !== state.tag || null !== state.anchor || hasContent;
	}

	function readDocument(state) {
	  var documentStart = state.position,
	      _position,
	      directiveName,
	      directiveArgs,
	      hasDirectives = false,
	      ch;

	  state.version = null;
	  state.checkLineBreaks = state.legacy;
	  state.tagMap = {};
	  state.anchorMap = {};

	  while (0 !== (ch = state.input.charCodeAt(state.position))) {
	    skipSeparationSpace(state, true, -1);

	    ch = state.input.charCodeAt(state.position);

	    if (state.lineIndent > 0 || 0x25 /* % */ !== ch) {
	      break;
	    }

	    hasDirectives = true;
	    ch = state.input.charCodeAt(++state.position);
	    _position = state.position;

	    while (0 !== ch && !is_WS_OR_EOL(ch)) {
	      ch = state.input.charCodeAt(++state.position);
	    }

	    directiveName = state.input.slice(_position, state.position);
	    directiveArgs = [];

	    if (directiveName.length < 1) {
	      throwError(state, 'directive name must not be less than one character in length');
	    }

	    while (0 !== ch) {
	      while (is_WHITE_SPACE(ch)) {
	        ch = state.input.charCodeAt(++state.position);
	      }

	      if (0x23 /* # */ === ch) {
	        do {
	          ch = state.input.charCodeAt(++state.position);
	        } while (0 !== ch && !is_EOL(ch));
	        break;
	      }

	      if (is_EOL(ch)) {
	        break;
	      }

	      _position = state.position;

	      while (0 !== ch && !is_WS_OR_EOL(ch)) {
	        ch = state.input.charCodeAt(++state.position);
	      }

	      directiveArgs.push(state.input.slice(_position, state.position));
	    }

	    if (0 !== ch) {
	      readLineBreak(state);
	    }

	    if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
	      directiveHandlers[directiveName](state, directiveName, directiveArgs);
	    } else {
	      throwWarning(state, 'unknown document directive "' + directiveName + '"');
	    }
	  }

	  skipSeparationSpace(state, true, -1);

	  if (0 === state.lineIndent && 0x2D /* - */ === state.input.charCodeAt(state.position) && 0x2D /* - */ === state.input.charCodeAt(state.position + 1) && 0x2D /* - */ === state.input.charCodeAt(state.position + 2)) {
	    state.position += 3;
	    skipSeparationSpace(state, true, -1);
	  } else if (hasDirectives) {
	    throwError(state, 'directives end mark is expected');
	  }

	  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
	  skipSeparationSpace(state, true, -1);

	  if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
	    throwWarning(state, 'non-ASCII line breaks are interpreted as content');
	  }

	  state.documents.push(state.result);

	  if (state.position === state.lineStart && testDocumentSeparator(state)) {

	    if (0x2E /* . */ === state.input.charCodeAt(state.position)) {
	      state.position += 3;
	      skipSeparationSpace(state, true, -1);
	    }
	    return;
	  }

	  if (state.position < state.length - 1) {
	    throwError(state, 'end of the stream or a document separator is expected');
	  } else {
	    return;
	  }
	}

	function loadDocuments(input, options) {
	  input = String(input);
	  options = options || {};

	  if (input.length !== 0) {

	    // Add tailing `\n` if not exists
	    if (0x0A /* LF */ !== input.charCodeAt(input.length - 1) && 0x0D /* CR */ !== input.charCodeAt(input.length - 1)) {
	      input += '\n';
	    }

	    // Strip BOM
	    if (input.charCodeAt(0) === 0xFEFF) {
	      input = input.slice(1);
	    }
	  }

	  var state = new State(input, options);

	  // Use 0 as string terminator. That significantly simplifies bounds check.
	  state.input += '\0';

	  while (0x20 /* Space */ === state.input.charCodeAt(state.position)) {
	    state.lineIndent += 1;
	    state.position += 1;
	  }

	  while (state.position < state.length - 1) {
	    readDocument(state);
	  }

	  return state.documents;
	}

	function loadAll(input, iterator, options) {
	  var documents = loadDocuments(input, options),
	      index,
	      length;

	  for (index = 0, length = documents.length; index < length; index += 1) {
	    iterator(documents[index]);
	  }
	}

	function load(input, options) {
	  var documents = loadDocuments(input, options);

	  if (0 === documents.length) {
	    /*eslint-disable no-undefined*/
	    return undefined;
	  } else if (1 === documents.length) {
	    return documents[0];
	  }
	  throw new YAMLException('expected a single document in the stream, but found more');
	}

	function safeLoadAll(input, output, options) {
	  loadAll(input, output, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
	}

	function safeLoad(input, options) {
	  return load(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
	}

	module.exports.loadAll = loadAll;
	module.exports.load = load;
	module.exports.safeLoadAll = safeLoadAll;
	module.exports.safeLoad = safeLoad;

/***/ },
/* 20 */
/***/ function(module, exports) {

	'use strict';

	function isNothing(subject) {
	  return typeof subject === 'undefined' || null === subject;
	}

	function isObject(subject) {
	  return typeof subject === 'object' && null !== subject;
	}

	function toArray(sequence) {
	  if (Array.isArray(sequence)) {
	    return sequence;
	  } else if (isNothing(sequence)) {
	    return [];
	  }
	  return [sequence];
	}

	function extend(target, source) {
	  var index, length, key, sourceKeys;

	  if (source) {
	    sourceKeys = Object.keys(source);

	    for (index = 0, length = sourceKeys.length; index < length; index += 1) {
	      key = sourceKeys[index];
	      target[key] = source[key];
	    }
	  }

	  return target;
	}

	function repeat(string, count) {
	  var result = '',
	      cycle;

	  for (cycle = 0; cycle < count; cycle += 1) {
	    result += string;
	  }

	  return result;
	}

	function isNegativeZero(number) {
	  return 0 === number && Number.NEGATIVE_INFINITY === 1 / number;
	}

	module.exports.isNothing = isNothing;
	module.exports.isObject = isObject;
	module.exports.toArray = toArray;
	module.exports.repeat = repeat;
	module.exports.isNegativeZero = isNegativeZero;
	module.exports.extend = extend;

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	// YAML error class. http://stackoverflow.com/questions/8458984
	//
	'use strict';

	var inherits = __webpack_require__(22);

	function YAMLException(reason, mark) {
	  // Super constructor
	  Error.call(this);

	  // Include stack trace in error object
	  if (Error.captureStackTrace) {
	    // Chrome and NodeJS
	    Error.captureStackTrace(this, this.constructor);
	  } else {
	    // FF, IE 10+ and Safari 6+. Fallback for others
	    this.stack = new Error().stack || '';
	  }

	  this.name = 'YAMLException';
	  this.reason = reason;
	  this.mark = mark;
	  this.message = (this.reason || '(unknown reason)') + (this.mark ? ' ' + this.mark.toString() : '');
	}

	// Inherit from Error
	inherits(YAMLException, Error);

	YAMLException.prototype.toString = function toString(compact) {
	  var result = this.name + ': ';

	  result += this.reason || '(unknown reason)';

	  if (!compact && this.mark) {
	    result += ' ' + this.mark.toString();
	  }

	  return result;
	};

	module.exports = YAMLException;

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * node-inherit
	 * Copyright(c) 2011 Dmitry Filatov <dfilatov@yandex-team.ru>
	 * MIT Licensed
	 */

	module.exports = __webpack_require__(23);

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * @module inherit
	 * @version 2.2.2
	 * @author Filatov Dmitry <dfilatov@yandex-team.ru>
	 * @description This module provides some syntax sugar for "class" declarations, constructors, mixins, "super" calls and static members.
	 */

	(function (global) {

	    var hasIntrospection = (function () {}).toString().indexOf('_') > -1,
	        emptyBase = function () {},
	        hasOwnProperty = Object.prototype.hasOwnProperty,
	        objCreate = Object.create || function (ptp) {
	        var inheritance = function () {};
	        inheritance.prototype = ptp;
	        return new inheritance();
	    },
	        objKeys = Object.keys || function (obj) {
	        var res = [];
	        for (var i in obj) {
	            hasOwnProperty.call(obj, i) && res.push(i);
	        }
	        return res;
	    },
	        extend = function (o1, o2) {
	        for (var i in o2) {
	            hasOwnProperty.call(o2, i) && (o1[i] = o2[i]);
	        }

	        return o1;
	    },
	        toStr = Object.prototype.toString,
	        isArray = Array.isArray || function (obj) {
	        return toStr.call(obj) === '[object Array]';
	    },
	        isFunction = function (obj) {
	        return toStr.call(obj) === '[object Function]';
	    },
	        noOp = function () {},
	        needCheckProps = true,
	        testPropObj = { toString: '' };

	    for (var i in testPropObj) {
	        // fucking ie hasn't toString, valueOf in for
	        testPropObj.hasOwnProperty(i) && (needCheckProps = false);
	    }

	    var specProps = needCheckProps ? ['toString', 'valueOf'] : null;

	    function getPropList(obj) {
	        var res = objKeys(obj);
	        if (needCheckProps) {
	            var specProp,
	                i = 0;
	            while (specProp = specProps[i++]) {
	                obj.hasOwnProperty(specProp) && res.push(specProp);
	            }
	        }

	        return res;
	    }

	    function override(base, res, add) {
	        var addList = getPropList(add),
	            j = 0,
	            len = addList.length,
	            name,
	            prop;
	        while (j < len) {
	            if ((name = addList[j++]) === '__self') {
	                continue;
	            }
	            prop = add[name];
	            if (isFunction(prop) && (!hasIntrospection || prop.toString().indexOf('.__base') > -1)) {
	                res[name] = (function (name, prop) {
	                    var baseMethod = base[name] ? base[name] : name === '__constructor' ? // case of inheritance from plane function
	                    res.__self.__parent : noOp;
	                    return function () {
	                        var baseSaved = this.__base;
	                        this.__base = baseMethod;
	                        var res = prop.apply(this, arguments);
	                        this.__base = baseSaved;
	                        return res;
	                    };
	                })(name, prop);
	            } else {
	                res[name] = prop;
	            }
	        }
	    }

	    function applyMixins(mixins, res) {
	        var i = 1,
	            mixin;
	        while (mixin = mixins[i++]) {
	            res ? isFunction(mixin) ? inherit.self(res, mixin.prototype, mixin) : inherit.self(res, mixin) : res = isFunction(mixin) ? inherit(mixins[0], mixin.prototype, mixin) : inherit(mixins[0], mixin);
	        }
	        return res || mixins[0];
	    }

	    /**
	    * Creates class
	    * @exports
	    * @param {Function|Array} [baseClass|baseClassAndMixins] class (or class and mixins) to inherit from
	    * @param {Object} prototypeFields
	    * @param {Object} [staticFields]
	    * @returns {Function} class
	    */
	    function inherit() {
	        var args = arguments,
	            withMixins = isArray(args[0]),
	            hasBase = withMixins || isFunction(args[0]),
	            base = hasBase ? withMixins ? applyMixins(args[0]) : args[0] : emptyBase,
	            props = args[hasBase ? 1 : 0] || {},
	            staticProps = args[hasBase ? 2 : 1],
	            res = props.__constructor || hasBase && base.prototype.__constructor ? function () {
	            return this.__constructor.apply(this, arguments);
	        } : hasBase ? function () {
	            return base.apply(this, arguments);
	        } : function () {};

	        if (!hasBase) {
	            res.prototype = props;
	            res.prototype.__self = res.prototype.constructor = res;
	            return extend(res, staticProps);
	        }

	        extend(res, base);

	        res.__parent = base;

	        var basePtp = base.prototype,
	            resPtp = res.prototype = objCreate(basePtp);

	        resPtp.__self = resPtp.constructor = res;

	        props && override(basePtp, resPtp, props);
	        staticProps && override(base, res, staticProps);

	        return res;
	    }

	    inherit.self = function () {
	        var args = arguments,
	            withMixins = isArray(args[0]),
	            base = withMixins ? applyMixins(args[0], args[0][0]) : args[0],
	            props = args[1],
	            staticProps = args[2],
	            basePtp = base.prototype;

	        props && override(basePtp, basePtp, props);
	        staticProps && override(base, base, staticProps);

	        return base;
	    };

	    var defineAsGlobal = true;
	    if (true) {
	        module.exports = inherit;
	        defineAsGlobal = false;
	    }

	    if (typeof modules === 'object') {
	        modules.define('inherit', function (provide) {
	            provide(inherit);
	        });
	        defineAsGlobal = false;
	    }

	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports, module) {
	            module.exports = inherit;
	        }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	        defineAsGlobal = false;
	    }

	    defineAsGlobal && (global.inherit = inherit);
	})(this);

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var common = __webpack_require__(20);

	function Mark(name, buffer, position, line, column) {
	  this.name = name;
	  this.buffer = buffer;
	  this.position = position;
	  this.line = line;
	  this.column = column;
	}

	Mark.prototype.getSnippet = function getSnippet(indent, maxLength) {
	  var head, start, tail, end, snippet;

	  if (!this.buffer) {
	    return null;
	  }

	  indent = indent || 4;
	  maxLength = maxLength || 75;

	  head = '';
	  start = this.position;

	  while (start > 0 && -1 === '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(start - 1))) {
	    start -= 1;
	    if (this.position - start > maxLength / 2 - 1) {
	      head = ' ... ';
	      start += 5;
	      break;
	    }
	  }

	  tail = '';
	  end = this.position;

	  while (end < this.buffer.length && -1 === '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(end))) {
	    end += 1;
	    if (end - this.position > maxLength / 2 - 1) {
	      tail = ' ... ';
	      end -= 5;
	      break;
	    }
	  }

	  snippet = this.buffer.slice(start, end);

	  return common.repeat(' ', indent) + head + snippet + tail + '\n' + common.repeat(' ', indent + this.position - start + head.length) + '^';
	};

	Mark.prototype.toString = function toString(compact) {
	  var snippet,
	      where = '';

	  if (this.name) {
	    where += 'in "' + this.name + '" ';
	  }

	  where += 'at line ' + (this.line + 1) + ', column ' + (this.column + 1);

	  if (!compact) {
	    snippet = this.getSnippet();

	    if (snippet) {
	      where += ':\n' + snippet;
	    }
	  }

	  return where;
	};

	module.exports = Mark;

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	// JS-YAML's default schema for `safeLoad` function.
	// It is not described in the YAML specification.
	//
	// This schema is based on standard YAML's Core schema and includes most of
	// extra types described at YAML tag repository. (http://yaml.org/type/)

	'use strict';

	var Schema = __webpack_require__(26);

	module.exports = new Schema({
	  include: [__webpack_require__(28)],
	  implicit: [__webpack_require__(38), __webpack_require__(39)],
	  explicit: [__webpack_require__(40), __webpack_require__(42), __webpack_require__(43), __webpack_require__(44)]
	});

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'

	/*eslint-disable max-len*/

	;
	var common = __webpack_require__(20);
	var YAMLException = __webpack_require__(21);
	var Type = __webpack_require__(27);

	function compileList(schema, name, result) {
	  var exclude = [];

	  schema.include.forEach(function (includedSchema) {
	    result = compileList(includedSchema, name, result);
	  });

	  schema[name].forEach(function (currentType) {
	    result.forEach(function (previousType, previousIndex) {
	      if (previousType.tag === currentType.tag) {
	        exclude.push(previousIndex);
	      }
	    });

	    result.push(currentType);
	  });

	  return result.filter(function (type, index) {
	    return -1 === exclude.indexOf(index);
	  });
	}

	function compileMap() /* lists... */{
	  var result = {},
	      index,
	      length;

	  function collectType(type) {
	    result[type.tag] = type;
	  }

	  for (index = 0, length = arguments.length; index < length; index += 1) {
	    arguments[index].forEach(collectType);
	  }

	  return result;
	}

	function Schema(definition) {
	  this.include = definition.include || [];
	  this.implicit = definition.implicit || [];
	  this.explicit = definition.explicit || [];

	  this.implicit.forEach(function (type) {
	    if (type.loadKind && 'scalar' !== type.loadKind) {
	      throw new YAMLException('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');
	    }
	  });

	  this.compiledImplicit = compileList(this, 'implicit', []);
	  this.compiledExplicit = compileList(this, 'explicit', []);
	  this.compiledTypeMap = compileMap(this.compiledImplicit, this.compiledExplicit);
	}

	Schema.DEFAULT = null;

	Schema.create = function createSchema() {
	  var schemas, types;

	  switch (arguments.length) {
	    case 1:
	      schemas = Schema.DEFAULT;
	      types = arguments[0];
	      break;

	    case 2:
	      schemas = arguments[0];
	      types = arguments[1];
	      break;

	    default:
	      throw new YAMLException('Wrong number of arguments for Schema.create function');
	  }

	  schemas = common.toArray(schemas);
	  types = common.toArray(types);

	  if (!schemas.every(function (schema) {
	    return schema instanceof Schema;
	  })) {
	    throw new YAMLException('Specified list of super schemas (or a single Schema object) contains a non-Schema object.');
	  }

	  if (!types.every(function (type) {
	    return type instanceof Type;
	  })) {
	    throw new YAMLException('Specified list of YAML types (or a single Type object) contains a non-Type object.');
	  }

	  return new Schema({
	    include: schemas,
	    explicit: types
	  });
	};

	module.exports = Schema;

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var YAMLException = __webpack_require__(21);

	var TYPE_CONSTRUCTOR_OPTIONS = ['kind', 'resolve', 'construct', 'instanceOf', 'predicate', 'represent', 'defaultStyle', 'styleAliases'];

	var YAML_NODE_KINDS = ['scalar', 'sequence', 'mapping'];

	function compileStyleAliases(map) {
	  var result = {};

	  if (null !== map) {
	    Object.keys(map).forEach(function (style) {
	      map[style].forEach(function (alias) {
	        result[String(alias)] = style;
	      });
	    });
	  }

	  return result;
	}

	function Type(tag, options) {
	  options = options || {};

	  Object.keys(options).forEach(function (name) {
	    if (-1 === TYPE_CONSTRUCTOR_OPTIONS.indexOf(name)) {
	      throw new YAMLException('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
	    }
	  });

	  // TODO: Add tag format check.
	  this.tag = tag;
	  this.kind = options['kind'] || null;
	  this.resolve = options['resolve'] || function () {
	    return true;
	  };
	  this.construct = options['construct'] || function (data) {
	    return data;
	  };
	  this.instanceOf = options['instanceOf'] || null;
	  this.predicate = options['predicate'] || null;
	  this.represent = options['represent'] || null;
	  this.defaultStyle = options['defaultStyle'] || null;
	  this.styleAliases = compileStyleAliases(options['styleAliases'] || null);

	  if (-1 === YAML_NODE_KINDS.indexOf(this.kind)) {
	    throw new YAMLException('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
	  }
	}

	module.exports = Type;

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	// Standard YAML's Core schema.
	// http://www.yaml.org/spec/1.2/spec.html#id2804923
	//
	// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
	// So, Core schema has no distinctions from JSON schema is JS-YAML.

	'use strict';

	var Schema = __webpack_require__(26);

	module.exports = new Schema({
	  include: [__webpack_require__(29)]
	});

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	// Standard YAML's JSON schema.
	// http://www.yaml.org/spec/1.2/spec.html#id2803231
	//
	// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
	// So, this schema is not such strict as defined in the YAML specification.
	// It allows numbers in binary notaion, use `Null` and `NULL` as `null`, etc.

	'use strict';

	var Schema = __webpack_require__(26);

	module.exports = new Schema({
	  include: [__webpack_require__(30)],
	  implicit: [__webpack_require__(34), __webpack_require__(35), __webpack_require__(36), __webpack_require__(37)]
	});

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	// Standard YAML's Failsafe schema.
	// http://www.yaml.org/spec/1.2/spec.html#id2802346

	'use strict';

	var Schema = __webpack_require__(26);

	module.exports = new Schema({
	  explicit: [__webpack_require__(31), __webpack_require__(32), __webpack_require__(33)]
	});

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Type = __webpack_require__(27);

	module.exports = new Type('tag:yaml.org,2002:str', {
	  kind: 'scalar',
	  construct: function (data) {
	    return null !== data ? data : '';
	  }
	});

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Type = __webpack_require__(27);

	module.exports = new Type('tag:yaml.org,2002:seq', {
	  kind: 'sequence',
	  construct: function (data) {
	    return null !== data ? data : [];
	  }
	});

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Type = __webpack_require__(27);

	module.exports = new Type('tag:yaml.org,2002:map', {
	  kind: 'mapping',
	  construct: function (data) {
	    return null !== data ? data : {};
	  }
	});

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Type = __webpack_require__(27);

	function resolveYamlNull(data) {
	  if (null === data) {
	    return true;
	  }

	  var max = data.length;

	  return max === 1 && data === '~' || max === 4 && (data === 'null' || data === 'Null' || data === 'NULL');
	}

	function constructYamlNull() {
	  return null;
	}

	function isNull(object) {
	  return null === object;
	}

	module.exports = new Type('tag:yaml.org,2002:null', {
	  kind: 'scalar',
	  resolve: resolveYamlNull,
	  construct: constructYamlNull,
	  predicate: isNull,
	  represent: {
	    canonical: function () {
	      return '~';
	    },
	    lowercase: function () {
	      return 'null';
	    },
	    uppercase: function () {
	      return 'NULL';
	    },
	    camelcase: function () {
	      return 'Null';
	    }
	  },
	  defaultStyle: 'lowercase'
	});

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Type = __webpack_require__(27);

	function resolveYamlBoolean(data) {
	  if (null === data) {
	    return false;
	  }

	  var max = data.length;

	  return max === 4 && (data === 'true' || data === 'True' || data === 'TRUE') || max === 5 && (data === 'false' || data === 'False' || data === 'FALSE');
	}

	function constructYamlBoolean(data) {
	  return data === 'true' || data === 'True' || data === 'TRUE';
	}

	function isBoolean(object) {
	  return '[object Boolean]' === Object.prototype.toString.call(object);
	}

	module.exports = new Type('tag:yaml.org,2002:bool', {
	  kind: 'scalar',
	  resolve: resolveYamlBoolean,
	  construct: constructYamlBoolean,
	  predicate: isBoolean,
	  represent: {
	    lowercase: function (object) {
	      return object ? 'true' : 'false';
	    },
	    uppercase: function (object) {
	      return object ? 'TRUE' : 'FALSE';
	    },
	    camelcase: function (object) {
	      return object ? 'True' : 'False';
	    }
	  },
	  defaultStyle: 'lowercase'
	});

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var common = __webpack_require__(20);
	var Type = __webpack_require__(27);

	function isHexCode(c) {
	  return 0x30 /* 0 */ <= c && c <= 0x39 /* 9 */ || 0x41 /* A */ <= c && c <= 0x46 /* F */ || 0x61 /* a */ <= c && c <= 0x66 /* f */;
	}

	function isOctCode(c) {
	  return 0x30 /* 0 */ <= c && c <= 0x37 /* 7 */;
	}

	function isDecCode(c) {
	  return 0x30 /* 0 */ <= c && c <= 0x39 /* 9 */;
	}

	function resolveYamlInteger(data) {
	  if (null === data) {
	    return false;
	  }

	  var max = data.length,
	      index = 0,
	      hasDigits = false,
	      ch;

	  if (!max) {
	    return false;
	  }

	  ch = data[index];

	  // sign
	  if (ch === '-' || ch === '+') {
	    ch = data[++index];
	  }

	  if (ch === '0') {
	    // 0
	    if (index + 1 === max) {
	      return true;
	    }
	    ch = data[++index];

	    // base 2, base 8, base 16

	    if (ch === 'b') {
	      // base 2
	      index++;

	      for (; index < max; index++) {
	        ch = data[index];
	        if (ch === '_') {
	          continue;
	        }
	        if (ch !== '0' && ch !== '1') {
	          return false;
	        }
	        hasDigits = true;
	      }
	      return hasDigits;
	    }

	    if (ch === 'x') {
	      // base 16
	      index++;

	      for (; index < max; index++) {
	        ch = data[index];
	        if (ch === '_') {
	          continue;
	        }
	        if (!isHexCode(data.charCodeAt(index))) {
	          return false;
	        }
	        hasDigits = true;
	      }
	      return hasDigits;
	    }

	    // base 8
	    for (; index < max; index++) {
	      ch = data[index];
	      if (ch === '_') {
	        continue;
	      }
	      if (!isOctCode(data.charCodeAt(index))) {
	        return false;
	      }
	      hasDigits = true;
	    }
	    return hasDigits;
	  }

	  // base 10 (except 0) or base 60

	  for (; index < max; index++) {
	    ch = data[index];
	    if (ch === '_') {
	      continue;
	    }
	    if (ch === ':') {
	      break;
	    }
	    if (!isDecCode(data.charCodeAt(index))) {
	      return false;
	    }
	    hasDigits = true;
	  }

	  if (!hasDigits) {
	    return false;
	  }

	  // if !base60 - done;
	  if (ch !== ':') {
	    return true;
	  }

	  // base60 almost not used, no needs to optimize
	  return (/^(:[0-5]?[0-9])+$/.test(data.slice(index))
	  );
	}

	function constructYamlInteger(data) {
	  var value = data,
	      sign = 1,
	      ch,
	      base,
	      digits = [];

	  if (value.indexOf('_') !== -1) {
	    value = value.replace(/_/g, '');
	  }

	  ch = value[0];

	  if (ch === '-' || ch === '+') {
	    if (ch === '-') {
	      sign = -1;
	    }
	    value = value.slice(1);
	    ch = value[0];
	  }

	  if ('0' === value) {
	    return 0;
	  }

	  if (ch === '0') {
	    if (value[1] === 'b') {
	      return sign * parseInt(value.slice(2), 2);
	    }
	    if (value[1] === 'x') {
	      return sign * parseInt(value, 16);
	    }
	    return sign * parseInt(value, 8);
	  }

	  if (value.indexOf(':') !== -1) {
	    value.split(':').forEach(function (v) {
	      digits.unshift(parseInt(v, 10));
	    });

	    value = 0;
	    base = 1;

	    digits.forEach(function (d) {
	      value += d * base;
	      base *= 60;
	    });

	    return sign * value;
	  }

	  return sign * parseInt(value, 10);
	}

	function isInteger(object) {
	  return '[object Number]' === Object.prototype.toString.call(object) && 0 === object % 1 && !common.isNegativeZero(object);
	}

	module.exports = new Type('tag:yaml.org,2002:int', {
	  kind: 'scalar',
	  resolve: resolveYamlInteger,
	  construct: constructYamlInteger,
	  predicate: isInteger,
	  represent: {
	    binary: function (object) {
	      return '0b' + object.toString(2);
	    },
	    octal: function (object) {
	      return '0' + object.toString(8);
	    },
	    decimal: function (object) {
	      return object.toString(10);
	    },
	    hexadecimal: function (object) {
	      return '0x' + object.toString(16).toUpperCase();
	    }
	  },
	  defaultStyle: 'decimal',
	  styleAliases: {
	    binary: [2, 'bin'],
	    octal: [8, 'oct'],
	    decimal: [10, 'dec'],
	    hexadecimal: [16, 'hex']
	  }
	});

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var common = __webpack_require__(20);
	var Type = __webpack_require__(27);

	var YAML_FLOAT_PATTERN = new RegExp('^(?:[-+]?(?:[0-9][0-9_]*)\\.[0-9_]*(?:[eE][-+][0-9]+)?' + '|\\.[0-9_]+(?:[eE][-+][0-9]+)?' + '|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*' + '|[-+]?\\.(?:inf|Inf|INF)' + '|\\.(?:nan|NaN|NAN))$');

	function resolveYamlFloat(data) {
	  if (null === data) {
	    return false;
	  }

	  if (!YAML_FLOAT_PATTERN.test(data)) {
	    return false;
	  }
	  return true;
	}

	function constructYamlFloat(data) {
	  var value, sign, base, digits;

	  value = data.replace(/_/g, '').toLowerCase();
	  sign = '-' === value[0] ? -1 : 1;
	  digits = [];

	  if (0 <= '+-'.indexOf(value[0])) {
	    value = value.slice(1);
	  }

	  if ('.inf' === value) {
	    return 1 === sign ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
	  } else if ('.nan' === value) {
	    return NaN;
	  } else if (0 <= value.indexOf(':')) {
	    value.split(':').forEach(function (v) {
	      digits.unshift(parseFloat(v, 10));
	    });

	    value = 0.0;
	    base = 1;

	    digits.forEach(function (d) {
	      value += d * base;
	      base *= 60;
	    });

	    return sign * value;
	  }
	  return sign * parseFloat(value, 10);
	}

	var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;

	function representYamlFloat(object, style) {
	  var res;

	  if (isNaN(object)) {
	    switch (style) {
	      case 'lowercase':
	        return '.nan';
	      case 'uppercase':
	        return '.NAN';
	      case 'camelcase':
	        return '.NaN';
	    }
	  } else if (Number.POSITIVE_INFINITY === object) {
	    switch (style) {
	      case 'lowercase':
	        return '.inf';
	      case 'uppercase':
	        return '.INF';
	      case 'camelcase':
	        return '.Inf';
	    }
	  } else if (Number.NEGATIVE_INFINITY === object) {
	    switch (style) {
	      case 'lowercase':
	        return '-.inf';
	      case 'uppercase':
	        return '-.INF';
	      case 'camelcase':
	        return '-.Inf';
	    }
	  } else if (common.isNegativeZero(object)) {
	    return '-0.0';
	  }

	  res = object.toString(10);

	  // JS stringifier can build scientific format without dots: 5e-100,
	  // while YAML requres dot: 5.e-100. Fix it with simple hack

	  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res;
	}

	function isFloat(object) {
	  return '[object Number]' === Object.prototype.toString.call(object) && (0 !== object % 1 || common.isNegativeZero(object));
	}

	module.exports = new Type('tag:yaml.org,2002:float', {
	  kind: 'scalar',
	  resolve: resolveYamlFloat,
	  construct: constructYamlFloat,
	  predicate: isFloat,
	  represent: representYamlFloat,
	  defaultStyle: 'lowercase'
	});

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Type = __webpack_require__(27);

	var YAML_TIMESTAMP_REGEXP = new RegExp('^([0-9][0-9][0-9][0-9])' + // [1] year
	'-([0-9][0-9]?)' + // [2] month
	'-([0-9][0-9]?)' + // [3] day
	'(?:(?:[Tt]|[ \\t]+)' + // ...
	'([0-9][0-9]?)' + // [4] hour
	':([0-9][0-9])' + // [5] minute
	':([0-9][0-9])' + // [6] second
	'(?:\\.([0-9]*))?' + // [7] fraction
	'(?:[ \\t]*(Z|([-+])([0-9][0-9]?)' + // [8] tz [9] tz_sign [10] tz_hour
	'(?::([0-9][0-9]))?))?)?$'); // [11] tz_minute

	function resolveYamlTimestamp(data) {
	  if (null === data) {
	    return false;
	  }

	  if (YAML_TIMESTAMP_REGEXP.exec(data) === null) {
	    return false;
	  }

	  return true;
	}

	function constructYamlTimestamp(data) {
	  var match,
	      year,
	      month,
	      day,
	      hour,
	      minute,
	      second,
	      fraction = 0,
	      delta = null,
	      tz_hour,
	      tz_minute,
	      date;

	  match = YAML_TIMESTAMP_REGEXP.exec(data);

	  if (null === match) {
	    throw new Error('Date resolve error');
	  }

	  // match: [1] year [2] month [3] day

	  year = +match[1];
	  month = +match[2] - 1; // JS month starts with 0
	  day = +match[3];

	  if (!match[4]) {
	    // no hour
	    return new Date(Date.UTC(year, month, day));
	  }

	  // match: [4] hour [5] minute [6] second [7] fraction

	  hour = +match[4];
	  minute = +match[5];
	  second = +match[6];

	  if (match[7]) {
	    fraction = match[7].slice(0, 3);
	    while (fraction.length < 3) {
	      // milli-seconds
	      fraction += '0';
	    }
	    fraction = +fraction;
	  }

	  // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute

	  if (match[9]) {
	    tz_hour = +match[10];
	    tz_minute = +(match[11] || 0);
	    delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds
	    if ('-' === match[9]) {
	      delta = -delta;
	    }
	  }

	  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));

	  if (delta) {
	    date.setTime(date.getTime() - delta);
	  }

	  return date;
	}

	function representYamlTimestamp(object /*, style*/) {
	  return object.toISOString();
	}

	module.exports = new Type('tag:yaml.org,2002:timestamp', {
	  kind: 'scalar',
	  resolve: resolveYamlTimestamp,
	  construct: constructYamlTimestamp,
	  instanceOf: Date,
	  represent: representYamlTimestamp
	});

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Type = __webpack_require__(27);

	function resolveYamlMerge(data) {
	  return '<<' === data || null === data;
	}

	module.exports = new Type('tag:yaml.org,2002:merge', {
	  kind: 'scalar',
	  resolve: resolveYamlMerge
	});

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'

	/*eslint-disable no-bitwise*/

	// A trick for browserified version.
	// Since we make browserifier to ignore `buffer` module, NodeBuffer will be undefined
	;
	var NodeBuffer = __webpack_require__(41).Buffer;
	var Type = __webpack_require__(27);

	// [ 64, 65, 66 ] -> [ padding, CR, LF ]
	var BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r';

	function resolveYamlBinary(data) {
	  if (null === data) {
	    return false;
	  }

	  var code,
	      idx,
	      bitlen = 0,
	      max = data.length,
	      map = BASE64_MAP;

	  // Convert one by one.
	  for (idx = 0; idx < max; idx++) {
	    code = map.indexOf(data.charAt(idx));

	    // Skip CR/LF
	    if (code > 64) {
	      continue;
	    }

	    // Fail on illegal characters
	    if (code < 0) {
	      return false;
	    }

	    bitlen += 6;
	  }

	  // If there are any bits left, source was corrupted
	  return bitlen % 8 === 0;
	}

	function constructYamlBinary(data) {
	  var idx,
	      tailbits,
	      input = data.replace(/[\r\n=]/g, ''),
	      // remove CR/LF & padding to simplify scan
	  max = input.length,
	      map = BASE64_MAP,
	      bits = 0,
	      result = [];

	  // Collect by 6*4 bits (3 bytes)

	  for (idx = 0; idx < max; idx++) {
	    if (idx % 4 === 0 && idx) {
	      result.push(bits >> 16 & 0xFF);
	      result.push(bits >> 8 & 0xFF);
	      result.push(bits & 0xFF);
	    }

	    bits = bits << 6 | map.indexOf(input.charAt(idx));
	  }

	  // Dump tail

	  tailbits = max % 4 * 6;

	  if (tailbits === 0) {
	    result.push(bits >> 16 & 0xFF);
	    result.push(bits >> 8 & 0xFF);
	    result.push(bits & 0xFF);
	  } else if (tailbits === 18) {
	    result.push(bits >> 10 & 0xFF);
	    result.push(bits >> 2 & 0xFF);
	  } else if (tailbits === 12) {
	    result.push(bits >> 4 & 0xFF);
	  }

	  // Wrap into Buffer for NodeJS and leave Array for browser
	  if (NodeBuffer) {
	    return new NodeBuffer(result);
	  }

	  return result;
	}

	function representYamlBinary(object /*, style*/) {
	  var result = '',
	      bits = 0,
	      idx,
	      tail,
	      max = object.length,
	      map = BASE64_MAP;

	  // Convert every three bytes to 4 ASCII characters.

	  for (idx = 0; idx < max; idx++) {
	    if (idx % 3 === 0 && idx) {
	      result += map[bits >> 18 & 0x3F];
	      result += map[bits >> 12 & 0x3F];
	      result += map[bits >> 6 & 0x3F];
	      result += map[bits & 0x3F];
	    }

	    bits = (bits << 8) + object[idx];
	  }

	  // Dump tail

	  tail = max % 3;

	  if (tail === 0) {
	    result += map[bits >> 18 & 0x3F];
	    result += map[bits >> 12 & 0x3F];
	    result += map[bits >> 6 & 0x3F];
	    result += map[bits & 0x3F];
	  } else if (tail === 2) {
	    result += map[bits >> 10 & 0x3F];
	    result += map[bits >> 4 & 0x3F];
	    result += map[bits << 2 & 0x3F];
	    result += map[64];
	  } else if (tail === 1) {
	    result += map[bits >> 2 & 0x3F];
	    result += map[bits << 4 & 0x3F];
	    result += map[64];
	    result += map[64];
	  }

	  return result;
	}

	function isBinary(object) {
	  return NodeBuffer && NodeBuffer.isBuffer(object);
	}

	module.exports = new Type('tag:yaml.org,2002:binary', {
	  kind: 'scalar',
	  resolve: resolveYamlBinary,
	  construct: constructYamlBinary,
	  predicate: isBinary,
	  represent: representYamlBinary
	});

/***/ },
/* 41 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Type = __webpack_require__(27);

	var _hasOwnProperty = Object.prototype.hasOwnProperty;
	var _toString = Object.prototype.toString;

	function resolveYamlOmap(data) {
	  if (null === data) {
	    return true;
	  }

	  var objectKeys = [],
	      index,
	      length,
	      pair,
	      pairKey,
	      pairHasKey,
	      object = data;

	  for (index = 0, length = object.length; index < length; index += 1) {
	    pair = object[index];
	    pairHasKey = false;

	    if ('[object Object]' !== _toString.call(pair)) {
	      return false;
	    }

	    for (pairKey in pair) {
	      if (_hasOwnProperty.call(pair, pairKey)) {
	        if (!pairHasKey) {
	          pairHasKey = true;
	        } else {
	          return false;
	        }
	      }
	    }

	    if (!pairHasKey) {
	      return false;
	    }

	    if (-1 === objectKeys.indexOf(pairKey)) {
	      objectKeys.push(pairKey);
	    } else {
	      return false;
	    }
	  }

	  return true;
	}

	function constructYamlOmap(data) {
	  return null !== data ? data : [];
	}

	module.exports = new Type('tag:yaml.org,2002:omap', {
	  kind: 'sequence',
	  resolve: resolveYamlOmap,
	  construct: constructYamlOmap
	});

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Type = __webpack_require__(27);

	var _toString = Object.prototype.toString;

	function resolveYamlPairs(data) {
	  if (null === data) {
	    return true;
	  }

	  var index,
	      length,
	      pair,
	      keys,
	      result,
	      object = data;

	  result = new Array(object.length);

	  for (index = 0, length = object.length; index < length; index += 1) {
	    pair = object[index];

	    if ('[object Object]' !== _toString.call(pair)) {
	      return false;
	    }

	    keys = Object.keys(pair);

	    if (1 !== keys.length) {
	      return false;
	    }

	    result[index] = [keys[0], pair[keys[0]]];
	  }

	  return true;
	}

	function constructYamlPairs(data) {
	  if (null === data) {
	    return [];
	  }

	  var index,
	      length,
	      pair,
	      keys,
	      result,
	      object = data;

	  result = new Array(object.length);

	  for (index = 0, length = object.length; index < length; index += 1) {
	    pair = object[index];

	    keys = Object.keys(pair);

	    result[index] = [keys[0], pair[keys[0]]];
	  }

	  return result;
	}

	module.exports = new Type('tag:yaml.org,2002:pairs', {
	  kind: 'sequence',
	  resolve: resolveYamlPairs,
	  construct: constructYamlPairs
	});

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Type = __webpack_require__(27);

	var _hasOwnProperty = Object.prototype.hasOwnProperty;

	function resolveYamlSet(data) {
	  if (null === data) {
	    return true;
	  }

	  var key,
	      object = data;

	  for (key in object) {
	    if (_hasOwnProperty.call(object, key)) {
	      if (null !== object[key]) {
	        return false;
	      }
	    }
	  }

	  return true;
	}

	function constructYamlSet(data) {
	  return null !== data ? data : {};
	}

	module.exports = new Type('tag:yaml.org,2002:set', {
	  kind: 'mapping',
	  resolve: resolveYamlSet,
	  construct: constructYamlSet
	});

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	// JS-YAML's default schema for `load` function.
	// It is not described in the YAML specification.
	//
	// This schema is based on JS-YAML's default safe schema and includes
	// JavaScript-specific types: !!js/undefined, !!js/regexp and !!js/function.
	//
	// Also this schema is used as default base schema at `Schema.create` function.

	'use strict';

	var Schema = __webpack_require__(26);

	module.exports = Schema.DEFAULT = new Schema({
	  include: [__webpack_require__(25)],
	  explicit: [__webpack_require__(46), __webpack_require__(47), __webpack_require__(48)]
	});

/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Type = __webpack_require__(27);

	function resolveJavascriptUndefined() {
	  return true;
	}

	function constructJavascriptUndefined() {
	  /*eslint-disable no-undefined*/
	  return undefined;
	}

	function representJavascriptUndefined() {
	  return '';
	}

	function isUndefined(object) {
	  return 'undefined' === typeof object;
	}

	module.exports = new Type('tag:yaml.org,2002:js/undefined', {
	  kind: 'scalar',
	  resolve: resolveJavascriptUndefined,
	  construct: constructJavascriptUndefined,
	  predicate: isUndefined,
	  represent: representJavascriptUndefined
	});

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Type = __webpack_require__(27);

	function resolveJavascriptRegExp(data) {
	  if (null === data) {
	    return false;
	  }

	  if (0 === data.length) {
	    return false;
	  }

	  var regexp = data,
	      tail = /\/([gim]*)$/.exec(data),
	      modifiers = '';

	  // if regexp starts with '/' it can have modifiers and must be properly closed
	  // `/foo/gim` - modifiers tail can be maximum 3 chars
	  if ('/' === regexp[0]) {
	    if (tail) {
	      modifiers = tail[1];
	    }

	    if (modifiers.length > 3) {
	      return false;
	    }
	    // if expression starts with /, is should be properly terminated
	    if (regexp[regexp.length - modifiers.length - 1] !== '/') {
	      return false;
	    }

	    regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
	  }

	  try {
	    return true;
	  } catch (error) {
	    return false;
	  }
	}

	function constructJavascriptRegExp(data) {
	  var regexp = data,
	      tail = /\/([gim]*)$/.exec(data),
	      modifiers = '';

	  // `/foo/gim` - tail can be maximum 4 chars
	  if ('/' === regexp[0]) {
	    if (tail) {
	      modifiers = tail[1];
	    }
	    regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
	  }

	  return new RegExp(regexp, modifiers);
	}

	function representJavascriptRegExp(object /*, style*/) {
	  var result = '/' + object.source + '/';

	  if (object.global) {
	    result += 'g';
	  }

	  if (object.multiline) {
	    result += 'm';
	  }

	  if (object.ignoreCase) {
	    result += 'i';
	  }

	  return result;
	}

	function isRegExp(object) {
	  return '[object RegExp]' === Object.prototype.toString.call(object);
	}

	module.exports = new Type('tag:yaml.org,2002:js/regexp', {
	  kind: 'scalar',
	  resolve: resolveJavascriptRegExp,
	  construct: constructJavascriptRegExp,
	  predicate: isRegExp,
	  represent: representJavascriptRegExp
	});

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var esprima;

	// Browserified version does not have esprima
	//
	// 1. For node.js just require module as deps
	// 2. For browser try to require mudule via external AMD system.
	//    If not found - try to fallback to window.esprima. If not
	//    found too - then fail to parse.
	//
	try {
	  esprima = __webpack_require__(49);
	} catch (_) {
	  /*global window */
	  if (typeof window !== 'undefined') {
	    esprima = window.esprima;
	  }
	}

	var Type = __webpack_require__(27);

	function resolveJavascriptFunction(data) {
	  if (null === data) {
	    return false;
	  }

	  try {
	    var source = '(' + data + ')',
	        ast = esprima.parse(source, { range: true });

	    if ('Program' !== ast.type || 1 !== ast.body.length || 'ExpressionStatement' !== ast.body[0].type || 'FunctionExpression' !== ast.body[0].expression.type) {
	      return false;
	    }

	    return true;
	  } catch (err) {
	    return false;
	  }
	}

	function constructJavascriptFunction(data) {
	  /*jslint evil:true*/

	  var source = '(' + data + ')',
	      ast = esprima.parse(source, { range: true }),
	      params = [],
	      body;

	  if ('Program' !== ast.type || 1 !== ast.body.length || 'ExpressionStatement' !== ast.body[0].type || 'FunctionExpression' !== ast.body[0].expression.type) {
	    throw new Error('Failed to resolve function');
	  }

	  ast.body[0].expression.params.forEach(function (param) {
	    params.push(param.name);
	  });

	  body = ast.body[0].expression.body.range;

	  // Esprima's ranges include the first '{' and the last '}' characters on
	  // function expressions. So cut them out.
	  /*eslint-disable no-new-func*/
	  return new Function(params, source.slice(body[0] + 1, body[1] - 1));
	}

	function representJavascriptFunction(object /*, style*/) {
	  return object.toString();
	}

	function isFunction(object) {
	  return '[object Function]' === Object.prototype.toString.call(object);
	}

	module.exports = new Type('tag:yaml.org,2002:js/function', {
	  kind: 'scalar',
	  resolve: resolveJavascriptFunction,
	  construct: constructJavascriptFunction,
	  predicate: isFunction,
	  represent: representJavascriptFunction
	});

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	  Copyright (c) jQuery Foundation, Inc. and Contributors, All Rights Reserved.

	  Redistribution and use in source and binary forms, with or without
	  modification, are permitted provided that the following conditions are met:

	    * Redistributions of source code must retain the above copyright
	      notice, this list of conditions and the following disclaimer.
	    * Redistributions in binary form must reproduce the above copyright
	      notice, this list of conditions and the following disclaimer in the
	      documentation and/or other materials provided with the distribution.

	  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
	  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
	  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/(function(root,factory){'use strict' // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,
	// Rhino, and plain browser loading.
	/* istanbul ignore next */;if(true){!(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))}else if(typeof exports!=='undefined'){factory(exports)}else {factory(root.esprima={})}})(this,function(exports){'use strict';var Token,TokenName,FnExprTokens,Syntax,PlaceHolders,Messages,Regex,source,strict,index,lineNumber,lineStart,hasLineTerminator,lastIndex,lastLineNumber,lastLineStart,startIndex,startLineNumber,startLineStart,scanning,length,lookahead,state,extra,isBindingElement,isAssignmentTarget,firstCoverInitializedNameError;Token={BooleanLiteral:1,EOF:2,Identifier:3,Keyword:4,NullLiteral:5,NumericLiteral:6,Punctuator:7,StringLiteral:8,RegularExpression:9,Template:10};TokenName={};TokenName[Token.BooleanLiteral]='Boolean';TokenName[Token.EOF]='<end>';TokenName[Token.Identifier]='Identifier';TokenName[Token.Keyword]='Keyword';TokenName[Token.NullLiteral]='Null';TokenName[Token.NumericLiteral]='Numeric';TokenName[Token.Punctuator]='Punctuator';TokenName[Token.StringLiteral]='String';TokenName[Token.RegularExpression]='RegularExpression';TokenName[Token.Template]='Template'; // A function following one of those tokens is an expression.
	FnExprTokens=['(','{','[','in','typeof','instanceof','new','return','case','delete','throw','void', // assignment operators
	'=','+=','-=','*=','/=','%=','<<=','>>=','>>>=','&=','|=','^=',',', // binary/unary operators
	'+','-','*','/','%','++','--','<<','>>','>>>','&','|','^','!','~','&&','||','?',':','===','==','>=','<=','<','>','!=','!=='];Syntax={AssignmentExpression:'AssignmentExpression',AssignmentPattern:'AssignmentPattern',ArrayExpression:'ArrayExpression',ArrayPattern:'ArrayPattern',ArrowFunctionExpression:'ArrowFunctionExpression',BlockStatement:'BlockStatement',BinaryExpression:'BinaryExpression',BreakStatement:'BreakStatement',CallExpression:'CallExpression',CatchClause:'CatchClause',ClassBody:'ClassBody',ClassDeclaration:'ClassDeclaration',ClassExpression:'ClassExpression',ConditionalExpression:'ConditionalExpression',ContinueStatement:'ContinueStatement',DoWhileStatement:'DoWhileStatement',DebuggerStatement:'DebuggerStatement',EmptyStatement:'EmptyStatement',ExportAllDeclaration:'ExportAllDeclaration',ExportDefaultDeclaration:'ExportDefaultDeclaration',ExportNamedDeclaration:'ExportNamedDeclaration',ExportSpecifier:'ExportSpecifier',ExpressionStatement:'ExpressionStatement',ForStatement:'ForStatement',ForOfStatement:'ForOfStatement',ForInStatement:'ForInStatement',FunctionDeclaration:'FunctionDeclaration',FunctionExpression:'FunctionExpression',Identifier:'Identifier',IfStatement:'IfStatement',ImportDeclaration:'ImportDeclaration',ImportDefaultSpecifier:'ImportDefaultSpecifier',ImportNamespaceSpecifier:'ImportNamespaceSpecifier',ImportSpecifier:'ImportSpecifier',Literal:'Literal',LabeledStatement:'LabeledStatement',LogicalExpression:'LogicalExpression',MemberExpression:'MemberExpression',MetaProperty:'MetaProperty',MethodDefinition:'MethodDefinition',NewExpression:'NewExpression',ObjectExpression:'ObjectExpression',ObjectPattern:'ObjectPattern',Program:'Program',Property:'Property',RestElement:'RestElement',ReturnStatement:'ReturnStatement',SequenceExpression:'SequenceExpression',SpreadElement:'SpreadElement',Super:'Super',SwitchCase:'SwitchCase',SwitchStatement:'SwitchStatement',TaggedTemplateExpression:'TaggedTemplateExpression',TemplateElement:'TemplateElement',TemplateLiteral:'TemplateLiteral',ThisExpression:'ThisExpression',ThrowStatement:'ThrowStatement',TryStatement:'TryStatement',UnaryExpression:'UnaryExpression',UpdateExpression:'UpdateExpression',VariableDeclaration:'VariableDeclaration',VariableDeclarator:'VariableDeclarator',WhileStatement:'WhileStatement',WithStatement:'WithStatement',YieldExpression:'YieldExpression'};PlaceHolders={ArrowParameterPlaceHolder:'ArrowParameterPlaceHolder'}; // Error messages should be identical to V8.
	Messages={UnexpectedToken:'Unexpected token %0',UnexpectedNumber:'Unexpected number',UnexpectedString:'Unexpected string',UnexpectedIdentifier:'Unexpected identifier',UnexpectedReserved:'Unexpected reserved word',UnexpectedTemplate:'Unexpected quasi %0',UnexpectedEOS:'Unexpected end of input',NewlineAfterThrow:'Illegal newline after throw',InvalidRegExp:'Invalid regular expression',UnterminatedRegExp:'Invalid regular expression: missing /',InvalidLHSInAssignment:'Invalid left-hand side in assignment',InvalidLHSInForIn:'Invalid left-hand side in for-in',InvalidLHSInForLoop:'Invalid left-hand side in for-loop',MultipleDefaultsInSwitch:'More than one default clause in switch statement',NoCatchOrFinally:'Missing catch or finally after try',UnknownLabel:'Undefined label \'%0\'',Redeclaration:'%0 \'%1\' has already been declared',IllegalContinue:'Illegal continue statement',IllegalBreak:'Illegal break statement',IllegalReturn:'Illegal return statement',StrictModeWith:'Strict mode code may not include a with statement',StrictCatchVariable:'Catch variable may not be eval or arguments in strict mode',StrictVarName:'Variable name may not be eval or arguments in strict mode',StrictParamName:'Parameter name eval or arguments is not allowed in strict mode',StrictParamDupe:'Strict mode function may not have duplicate parameter names',StrictFunctionName:'Function name may not be eval or arguments in strict mode',StrictOctalLiteral:'Octal literals are not allowed in strict mode.',StrictDelete:'Delete of an unqualified identifier in strict mode.',StrictLHSAssignment:'Assignment to eval or arguments is not allowed in strict mode',StrictLHSPostfix:'Postfix increment/decrement may not have eval or arguments operand in strict mode',StrictLHSPrefix:'Prefix increment/decrement may not have eval or arguments operand in strict mode',StrictReservedWord:'Use of future reserved word in strict mode',TemplateOctalLiteral:'Octal literals are not allowed in template strings.',ParameterAfterRestParameter:'Rest parameter must be last formal parameter',DefaultRestParameter:'Unexpected token =',ObjectPatternAsRestParameter:'Unexpected token {',DuplicateProtoProperty:'Duplicate __proto__ fields are not allowed in object literals',ConstructorSpecialMethod:'Class constructor may not be an accessor',DuplicateConstructor:'A class may only have one constructor',StaticPrototype:'Classes may not have static property named prototype',MissingFromClause:'Unexpected token',NoAsAfterImportNamespace:'Unexpected token',InvalidModuleSpecifier:'Unexpected token',IllegalImportDeclaration:'Unexpected token',IllegalExportDeclaration:'Unexpected token',DuplicateBinding:'Duplicate binding %0'}; // See also tools/generate-unicode-regex.js.
	Regex={ // ECMAScript 6/Unicode v7.0.0 NonAsciiIdentifierStart:
	NonAsciiIdentifierStart:/[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDE00-\uDE11\uDE13-\uDE2B\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDE00-\uDE2F\uDE44\uDE80-\uDEAA]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|\uD809[\uDC00-\uDC6E]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]/, // ECMAScript 6/Unicode v7.0.0 NonAsciiIdentifierPart:
	NonAsciiIdentifierPart:/[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDD0-\uDDDA\uDE00-\uDE11\uDE13-\uDE37\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF01-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|\uD809[\uDC00-\uDC6E]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/}; // Ensure the condition is true, otherwise throw an error.
	// This is only to have a better contract semantic, i.e. another safety net
	// to catch a logic error. The condition shall be fulfilled in normal case.
	// Do NOT use this to enforce a certain condition on any user input.
	function assert(condition,message){ /* istanbul ignore if */if(!condition){throw new Error('ASSERT: '+message)}}function isDecimalDigit(ch){return ch>=0x30&&ch<=0x39; // 0..9
	}function isHexDigit(ch){return '0123456789abcdefABCDEF'.indexOf(ch)>=0}function isOctalDigit(ch){return '01234567'.indexOf(ch)>=0}function octalToDecimal(ch){ // \0 is not octal escape sequence
	var octal=ch!=='0',code='01234567'.indexOf(ch);if(index<length&&isOctalDigit(source[index])){octal=true;code=code*8+'01234567'.indexOf(source[index++]); // 3 digits are only allowed when string starts
	// with 0, 1, 2, 3
	if('0123'.indexOf(ch)>=0&&index<length&&isOctalDigit(source[index])){code=code*8+'01234567'.indexOf(source[index++])}}return {code:code,octal:octal}} // ECMA-262 11.2 White Space
	function isWhiteSpace(ch){return ch===0x20||ch===0x09||ch===0x0B||ch===0x0C||ch===0xA0||ch>=0x1680&&[0x1680,0x180E,0x2000,0x2001,0x2002,0x2003,0x2004,0x2005,0x2006,0x2007,0x2008,0x2009,0x200A,0x202F,0x205F,0x3000,0xFEFF].indexOf(ch)>=0} // ECMA-262 11.3 Line Terminators
	function isLineTerminator(ch){return ch===0x0A||ch===0x0D||ch===0x2028||ch===0x2029} // ECMA-262 11.6 Identifier Names and Identifiers
	function fromCodePoint(cp){return cp<0x10000?String.fromCharCode(cp):String.fromCharCode(0xD800+(cp-0x10000>>10))+String.fromCharCode(0xDC00+(cp-0x10000&1023))}function isIdentifierStart(ch){return ch===0x24||ch===0x5F|| // $ (dollar) and _ (underscore)
	ch>=0x41&&ch<=0x5A|| // A..Z
	ch>=0x61&&ch<=0x7A|| // a..z
	ch===0x5C|| // \ (backslash)
	ch>=0x80&&Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch))}function isIdentifierPart(ch){return ch===0x24||ch===0x5F|| // $ (dollar) and _ (underscore)
	ch>=0x41&&ch<=0x5A|| // A..Z
	ch>=0x61&&ch<=0x7A|| // a..z
	ch>=0x30&&ch<=0x39|| // 0..9
	ch===0x5C|| // \ (backslash)
	ch>=0x80&&Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch))} // ECMA-262 11.6.2.2 Future Reserved Words
	function isFutureReservedWord(id){switch(id){case 'enum':case 'export':case 'import':case 'super':return true;default:return false;}}function isStrictModeReservedWord(id){switch(id){case 'implements':case 'interface':case 'package':case 'private':case 'protected':case 'public':case 'static':case 'yield':case 'let':return true;default:return false;}}function isRestrictedWord(id){return id==='eval'||id==='arguments'} // ECMA-262 11.6.2.1 Keywords
	function isKeyword(id){switch(id.length){case 2:return id==='if'||id==='in'||id==='do';case 3:return id==='var'||id==='for'||id==='new'||id==='try'||id==='let';case 4:return id==='this'||id==='else'||id==='case'||id==='void'||id==='with'||id==='enum';case 5:return id==='while'||id==='break'||id==='catch'||id==='throw'||id==='const'||id==='yield'||id==='class'||id==='super';case 6:return id==='return'||id==='typeof'||id==='delete'||id==='switch'||id==='export'||id==='import';case 7:return id==='default'||id==='finally'||id==='extends';case 8:return id==='function'||id==='continue'||id==='debugger';case 10:return id==='instanceof';default:return false;}} // ECMA-262 11.4 Comments
	function addComment(type,value,start,end,loc){var comment;assert(typeof start==='number','Comment must have valid position');state.lastCommentStart=start;comment={type:type,value:value};if(extra.range){comment.range=[start,end]}if(extra.loc){comment.loc=loc}extra.comments.push(comment);if(extra.attachComment){extra.leadingComments.push(comment);extra.trailingComments.push(comment)}if(extra.tokenize){comment.type=comment.type+'Comment';if(extra.delegate){comment=extra.delegate(comment)}extra.tokens.push(comment)}}function skipSingleLineComment(offset){var start,loc,ch,comment;start=index-offset;loc={start:{line:lineNumber,column:index-lineStart-offset}};while(index<length){ch=source.charCodeAt(index);++index;if(isLineTerminator(ch)){hasLineTerminator=true;if(extra.comments){comment=source.slice(start+offset,index-1);loc.end={line:lineNumber,column:index-lineStart-1};addComment('Line',comment,start,index-1,loc)}if(ch===13&&source.charCodeAt(index)===10){++index}++lineNumber;lineStart=index;return}}if(extra.comments){comment=source.slice(start+offset,index);loc.end={line:lineNumber,column:index-lineStart};addComment('Line',comment,start,index,loc)}}function skipMultiLineComment(){var start,loc,ch,comment;if(extra.comments){start=index-2;loc={start:{line:lineNumber,column:index-lineStart-2}}}while(index<length){ch=source.charCodeAt(index);if(isLineTerminator(ch)){if(ch===0x0D&&source.charCodeAt(index+1)===0x0A){++index}hasLineTerminator=true;++lineNumber;++index;lineStart=index}else if(ch===0x2A){ // Block comment ends with '*/'.
	if(source.charCodeAt(index+1)===0x2F){++index;++index;if(extra.comments){comment=source.slice(start+2,index-2);loc.end={line:lineNumber,column:index-lineStart};addComment('Block',comment,start,index,loc)}return}++index}else {++index}} // Ran off the end of the file - the whole thing is a comment
	if(extra.comments){loc.end={line:lineNumber,column:index-lineStart};comment=source.slice(start+2,index);addComment('Block',comment,start,index,loc)}tolerateUnexpectedToken()}function skipComment(){var ch,start;hasLineTerminator=false;start=index===0;while(index<length){ch=source.charCodeAt(index);if(isWhiteSpace(ch)){++index}else if(isLineTerminator(ch)){hasLineTerminator=true;++index;if(ch===0x0D&&source.charCodeAt(index)===0x0A){++index}++lineNumber;lineStart=index;start=true}else if(ch===0x2F){ // U+002F is '/'
	ch=source.charCodeAt(index+1);if(ch===0x2F){++index;++index;skipSingleLineComment(2);start=true}else if(ch===0x2A){ // U+002A is '*'
	++index;++index;skipMultiLineComment()}else {break}}else if(start&&ch===0x2D){ // U+002D is '-'
	// U+003E is '>'
	if(source.charCodeAt(index+1)===0x2D&&source.charCodeAt(index+2)===0x3E){ // '-->' is a single-line comment
	index+=3;skipSingleLineComment(3)}else {break}}else if(ch===0x3C){ // U+003C is '<'
	if(source.slice(index+1,index+4)==='!--'){++index; // `<`
	++index; // `!`
	++index; // `-`
	++index; // `-`
	skipSingleLineComment(4)}else {break}}else {break}}}function scanHexEscape(prefix){var i,len,ch,code=0;len=prefix==='u'?4:2;for(i=0;i<len;++i){if(index<length&&isHexDigit(source[index])){ch=source[index++];code=code*16+'0123456789abcdef'.indexOf(ch.toLowerCase())}else {return ''}}return String.fromCharCode(code)}function scanUnicodeCodePointEscape(){var ch,code;ch=source[index];code=0; // At least, one hex digit is required.
	if(ch==='}'){throwUnexpectedToken()}while(index<length){ch=source[index++];if(!isHexDigit(ch)){break}code=code*16+'0123456789abcdef'.indexOf(ch.toLowerCase())}if(code>0x10FFFF||ch!=='}'){throwUnexpectedToken()}return fromCodePoint(code)}function codePointAt(i){var cp,first,second;cp=source.charCodeAt(i);if(cp>=0xD800&&cp<=0xDBFF){second=source.charCodeAt(i+1);if(second>=0xDC00&&second<=0xDFFF){first=cp;cp=(first-0xD800)*0x400+second-0xDC00+0x10000}}return cp}function getComplexIdentifier(){var cp,ch,id;cp=codePointAt(index);id=fromCodePoint(cp);index+=id.length; // '\u' (U+005C, U+0075) denotes an escaped character.
	if(cp===0x5C){if(source.charCodeAt(index)!==0x75){throwUnexpectedToken()}++index;if(source[index]==='{'){++index;ch=scanUnicodeCodePointEscape()}else {ch=scanHexEscape('u');cp=ch.charCodeAt(0);if(!ch||ch==='\\'||!isIdentifierStart(cp)){throwUnexpectedToken()}}id=ch}while(index<length){cp=codePointAt(index);if(!isIdentifierPart(cp)){break}ch=fromCodePoint(cp);id+=ch;index+=ch.length; // '\u' (U+005C, U+0075) denotes an escaped character.
	if(cp===0x5C){id=id.substr(0,id.length-1);if(source.charCodeAt(index)!==0x75){throwUnexpectedToken()}++index;if(source[index]==='{'){++index;ch=scanUnicodeCodePointEscape()}else {ch=scanHexEscape('u');cp=ch.charCodeAt(0);if(!ch||ch==='\\'||!isIdentifierPart(cp)){throwUnexpectedToken()}}id+=ch}}return id}function getIdentifier(){var start,ch;start=index++;while(index<length){ch=source.charCodeAt(index);if(ch===0x5C){ // Blackslash (U+005C) marks Unicode escape sequence.
	index=start;return getComplexIdentifier()}else if(ch>=0xD800&&ch<0xDFFF){ // Need to handle surrogate pairs.
	index=start;return getComplexIdentifier()}if(isIdentifierPart(ch)){++index}else {break}}return source.slice(start,index)}function scanIdentifier(){var start,id,type;start=index; // Backslash (U+005C) starts an escaped character.
	id=source.charCodeAt(index)===0x5C?getComplexIdentifier():getIdentifier(); // There is no keyword or literal with only one character.
	// Thus, it must be an identifier.
	if(id.length===1){type=Token.Identifier}else if(isKeyword(id)){type=Token.Keyword}else if(id==='null'){type=Token.NullLiteral}else if(id==='true'||id==='false'){type=Token.BooleanLiteral}else {type=Token.Identifier}return {type:type,value:id,lineNumber:lineNumber,lineStart:lineStart,start:start,end:index}} // ECMA-262 11.7 Punctuators
	function scanPunctuator(){var token,str;token={type:Token.Punctuator,value:'',lineNumber:lineNumber,lineStart:lineStart,start:index,end:index}; // Check for most common single-character punctuators.
	str=source[index];switch(str){case '(':if(extra.tokenize){extra.openParenToken=extra.tokenValues.length}++index;break;case '{':if(extra.tokenize){extra.openCurlyToken=extra.tokenValues.length}state.curlyStack.push('{');++index;break;case '.':++index;if(source[index]==='.'&&source[index+1]==='.'){ // Spread operator: ...
	index+=2;str='...'}break;case '}':++index;state.curlyStack.pop();break;case ')':case ';':case ',':case '[':case ']':case ':':case '?':case '~':++index;break;default: // 4-character punctuator.
	str=source.substr(index,4);if(str==='>>>='){index+=4}else { // 3-character punctuators.
	str=str.substr(0,3);if(str==='==='||str==='!=='||str==='>>>'||str==='<<='||str==='>>='){index+=3}else { // 2-character punctuators.
	str=str.substr(0,2);if(str==='&&'||str==='||'||str==='=='||str==='!='||str==='+='||str==='-='||str==='*='||str==='/='||str==='++'||str==='--'||str==='<<'||str==='>>'||str==='&='||str==='|='||str==='^='||str==='%='||str==='<='||str==='>='||str==='=>'){index+=2}else { // 1-character punctuators.
	str=source[index];if('<>=!+-*%&|^/'.indexOf(str)>=0){++index}}}}}if(index===token.start){throwUnexpectedToken()}token.end=index;token.value=str;return token} // ECMA-262 11.8.3 Numeric Literals
	function scanHexLiteral(start){var number='';while(index<length){if(!isHexDigit(source[index])){break}number+=source[index++]}if(number.length===0){throwUnexpectedToken()}if(isIdentifierStart(source.charCodeAt(index))){throwUnexpectedToken()}return {type:Token.NumericLiteral,value:parseInt('0x'+number,16),lineNumber:lineNumber,lineStart:lineStart,start:start,end:index}}function scanBinaryLiteral(start){var ch,number;number='';while(index<length){ch=source[index];if(ch!=='0'&&ch!=='1'){break}number+=source[index++]}if(number.length===0){ // only 0b or 0B
	throwUnexpectedToken()}if(index<length){ch=source.charCodeAt(index); /* istanbul ignore else */if(isIdentifierStart(ch)||isDecimalDigit(ch)){throwUnexpectedToken()}}return {type:Token.NumericLiteral,value:parseInt(number,2),lineNumber:lineNumber,lineStart:lineStart,start:start,end:index}}function scanOctalLiteral(prefix,start){var number,octal;if(isOctalDigit(prefix)){octal=true;number='0'+source[index++]}else {octal=false;++index;number=''}while(index<length){if(!isOctalDigit(source[index])){break}number+=source[index++]}if(!octal&&number.length===0){ // only 0o or 0O
	throwUnexpectedToken()}if(isIdentifierStart(source.charCodeAt(index))||isDecimalDigit(source.charCodeAt(index))){throwUnexpectedToken()}return {type:Token.NumericLiteral,value:parseInt(number,8),octal:octal,lineNumber:lineNumber,lineStart:lineStart,start:start,end:index}}function isImplicitOctalLiteral(){var i,ch; // Implicit octal, unless there is a non-octal digit.
	// (Annex B.1.1 on Numeric Literals)
	for(i=index+1;i<length;++i){ch=source[i];if(ch==='8'||ch==='9'){return false}if(!isOctalDigit(ch)){return true}}return true}function scanNumericLiteral(){var number,start,ch;ch=source[index];assert(isDecimalDigit(ch.charCodeAt(0))||ch==='.','Numeric literal must start with a decimal digit or a decimal point');start=index;number='';if(ch!=='.'){number=source[index++];ch=source[index]; // Hex number starts with '0x'.
	// Octal number starts with '0'.
	// Octal number in ES6 starts with '0o'.
	// Binary number in ES6 starts with '0b'.
	if(number==='0'){if(ch==='x'||ch==='X'){++index;return scanHexLiteral(start)}if(ch==='b'||ch==='B'){++index;return scanBinaryLiteral(start)}if(ch==='o'||ch==='O'){return scanOctalLiteral(ch,start)}if(isOctalDigit(ch)){if(isImplicitOctalLiteral()){return scanOctalLiteral(ch,start)}}}while(isDecimalDigit(source.charCodeAt(index))){number+=source[index++]}ch=source[index]}if(ch==='.'){number+=source[index++];while(isDecimalDigit(source.charCodeAt(index))){number+=source[index++]}ch=source[index]}if(ch==='e'||ch==='E'){number+=source[index++];ch=source[index];if(ch==='+'||ch==='-'){number+=source[index++]}if(isDecimalDigit(source.charCodeAt(index))){while(isDecimalDigit(source.charCodeAt(index))){number+=source[index++]}}else {throwUnexpectedToken()}}if(isIdentifierStart(source.charCodeAt(index))){throwUnexpectedToken()}return {type:Token.NumericLiteral,value:parseFloat(number),lineNumber:lineNumber,lineStart:lineStart,start:start,end:index}} // ECMA-262 11.8.4 String Literals
	function scanStringLiteral(){var str='',quote,start,ch,unescaped,octToDec,octal=false;quote=source[index];assert(quote==='\''||quote==='"','String literal must starts with a quote');start=index;++index;while(index<length){ch=source[index++];if(ch===quote){quote='';break}else if(ch==='\\'){ch=source[index++];if(!ch||!isLineTerminator(ch.charCodeAt(0))){switch(ch){case 'u':case 'x':if(source[index]==='{'){++index;str+=scanUnicodeCodePointEscape()}else {unescaped=scanHexEscape(ch);if(!unescaped){throw throwUnexpectedToken()}str+=unescaped}break;case 'n':str+='\n';break;case 'r':str+='\r';break;case 't':str+='\t';break;case 'b':str+='\b';break;case 'f':str+='\f';break;case 'v':str+='\x0B';break;case '8':case '9':str+=ch;tolerateUnexpectedToken();break;default:if(isOctalDigit(ch)){octToDec=octalToDecimal(ch);octal=octToDec.octal||octal;str+=String.fromCharCode(octToDec.code)}else {str+=ch}break;}}else {++lineNumber;if(ch==='\r'&&source[index]==='\n'){++index}lineStart=index}}else if(isLineTerminator(ch.charCodeAt(0))){break}else {str+=ch}}if(quote!==''){throwUnexpectedToken()}return {type:Token.StringLiteral,value:str,octal:octal,lineNumber:startLineNumber,lineStart:startLineStart,start:start,end:index}} // ECMA-262 11.8.6 Template Literal Lexical Components
	function scanTemplate(){var cooked='',ch,start,rawOffset,terminated,head,tail,restore,unescaped;terminated=false;tail=false;start=index;head=source[index]==='`';rawOffset=2;++index;while(index<length){ch=source[index++];if(ch==='`'){rawOffset=1;tail=true;terminated=true;break}else if(ch==='$'){if(source[index]==='{'){state.curlyStack.push('${');++index;terminated=true;break}cooked+=ch}else if(ch==='\\'){ch=source[index++];if(!isLineTerminator(ch.charCodeAt(0))){switch(ch){case 'n':cooked+='\n';break;case 'r':cooked+='\r';break;case 't':cooked+='\t';break;case 'u':case 'x':if(source[index]==='{'){++index;cooked+=scanUnicodeCodePointEscape()}else {restore=index;unescaped=scanHexEscape(ch);if(unescaped){cooked+=unescaped}else {index=restore;cooked+=ch}}break;case 'b':cooked+='\b';break;case 'f':cooked+='\f';break;case 'v':cooked+='\v';break;default:if(ch==='0'){if(isDecimalDigit(source.charCodeAt(index))){ // Illegal: \01 \02 and so on
	throwError(Messages.TemplateOctalLiteral)}cooked+='\0'}else if(isOctalDigit(ch)){ // Illegal: \1 \2
	throwError(Messages.TemplateOctalLiteral)}else {cooked+=ch}break;}}else {++lineNumber;if(ch==='\r'&&source[index]==='\n'){++index}lineStart=index}}else if(isLineTerminator(ch.charCodeAt(0))){++lineNumber;if(ch==='\r'&&source[index]==='\n'){++index}lineStart=index;cooked+='\n'}else {cooked+=ch}}if(!terminated){throwUnexpectedToken()}if(!head){state.curlyStack.pop()}return {type:Token.Template,value:{cooked:cooked,raw:source.slice(start+1,index-rawOffset)},head:head,tail:tail,lineNumber:lineNumber,lineStart:lineStart,start:start,end:index}} // ECMA-262 11.8.5 Regular Expression Literals
	function testRegExp(pattern,flags){ // The BMP character to use as a replacement for astral symbols when
	// translating an ES6 "u"-flagged pattern to an ES5-compatible
	// approximation.
	// Note: replacing with '\uFFFF' enables false positives in unlikely
	// scenarios. For example, `[\u{1044f}-\u{10440}]` is an invalid
	// pattern that would not be detected by this substitution.
	var astralSubstitute='\uFFFF',tmp=pattern;if(flags.indexOf('u')>=0){tmp=tmp // Replace every Unicode escape sequence with the equivalent
	// BMP character or a constant ASCII code point in the case of
	// astral symbols. (See the above note on `astralSubstitute`
	// for more information.)
	.replace(/\\u\{([0-9a-fA-F]+)\}|\\u([a-fA-F0-9]{4})/g,function($0,$1,$2){var codePoint=parseInt($1||$2,16);if(codePoint>0x10FFFF){throwUnexpectedToken(null,Messages.InvalidRegExp)}if(codePoint<=0xFFFF){return String.fromCharCode(codePoint)}return astralSubstitute}) // Replace each paired surrogate with a single ASCII symbol to
	// avoid throwing on regular expressions that are only valid in
	// combination with the "u" flag.
	.replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g,astralSubstitute)} // First, detect invalid regular expressions.
	try{RegExp(tmp)}catch(e) {throwUnexpectedToken(null,Messages.InvalidRegExp)} // Return a regular expression object for this pattern-flag pair, or
	// `null` in case the current environment doesn't support the flags it
	// uses.
	try{return new RegExp(pattern,flags)}catch(exception) {return null}}function scanRegExpBody(){var ch,str,classMarker,terminated,body;ch=source[index];assert(ch==='/','Regular expression literal must start with a slash');str=source[index++];classMarker=false;terminated=false;while(index<length){ch=source[index++];str+=ch;if(ch==='\\'){ch=source[index++]; // ECMA-262 7.8.5
	if(isLineTerminator(ch.charCodeAt(0))){throwUnexpectedToken(null,Messages.UnterminatedRegExp)}str+=ch}else if(isLineTerminator(ch.charCodeAt(0))){throwUnexpectedToken(null,Messages.UnterminatedRegExp)}else if(classMarker){if(ch===']'){classMarker=false}}else {if(ch==='/'){terminated=true;break}else if(ch==='['){classMarker=true}}}if(!terminated){throwUnexpectedToken(null,Messages.UnterminatedRegExp)} // Exclude leading and trailing slash.
	body=str.substr(1,str.length-2);return {value:body,literal:str}}function scanRegExpFlags(){var ch,str,flags,restore;str='';flags='';while(index<length){ch=source[index];if(!isIdentifierPart(ch.charCodeAt(0))){break}++index;if(ch==='\\'&&index<length){ch=source[index];if(ch==='u'){++index;restore=index;ch=scanHexEscape('u');if(ch){flags+=ch;for(str+='\\u';restore<index;++restore){str+=source[restore]}}else {index=restore;flags+='u';str+='\\u'}tolerateUnexpectedToken()}else {str+='\\';tolerateUnexpectedToken()}}else {flags+=ch;str+=ch}}return {value:flags,literal:str}}function scanRegExp(){var start,body,flags,value;scanning=true;lookahead=null;skipComment();start=index;body=scanRegExpBody();flags=scanRegExpFlags();value=testRegExp(body.value,flags.value);scanning=false;if(extra.tokenize){return {type:Token.RegularExpression,value:value,regex:{pattern:body.value,flags:flags.value},lineNumber:lineNumber,lineStart:lineStart,start:start,end:index}}return {literal:body.literal+flags.literal,value:value,regex:{pattern:body.value,flags:flags.value},start:start,end:index}}function collectRegex(){var pos,loc,regex,token;skipComment();pos=index;loc={start:{line:lineNumber,column:index-lineStart}};regex=scanRegExp();loc.end={line:lineNumber,column:index-lineStart}; /* istanbul ignore next */if(!extra.tokenize){ // Pop the previous token, which is likely '/' or '/='
	if(extra.tokens.length>0){token=extra.tokens[extra.tokens.length-1];if(token.range[0]===pos&&token.type==='Punctuator'){if(token.value==='/'||token.value==='/='){extra.tokens.pop()}}}extra.tokens.push({type:'RegularExpression',value:regex.literal,regex:regex.regex,range:[pos,index],loc:loc})}return regex}function isIdentifierName(token){return token.type===Token.Identifier||token.type===Token.Keyword||token.type===Token.BooleanLiteral||token.type===Token.NullLiteral} // Using the following algorithm:
	// https://github.com/mozilla/sweet.js/wiki/design
	function advanceSlash(){var regex,previous,check;function testKeyword(value){return value&&value.length>1&&value[0]>='a'&&value[0]<='z'}previous=extra.tokenValues[extra.tokens.length-1];regex=previous!==null;switch(previous){case 'this':case ']':regex=false;break;case ')':check=extra.tokenValues[extra.openParenToken-1];regex=check==='if'||check==='while'||check==='for'||check==='with';break;case '}': // Dividing a function by anything makes little sense,
	// but we have to check for that.
	regex=false;if(testKeyword(extra.tokenValues[extra.openCurlyToken-3])){ // Anonymous function, e.g. function(){} /42
	check=extra.tokenValues[extra.openCurlyToken-4];regex=check?FnExprTokens.indexOf(check)<0:false}else if(testKeyword(extra.tokenValues[extra.openCurlyToken-4])){ // Named function, e.g. function f(){} /42/
	check=extra.tokenValues[extra.openCurlyToken-5];regex=check?FnExprTokens.indexOf(check)<0:true}}return regex?collectRegex():scanPunctuator()}function advance(){var cp,token;if(index>=length){return {type:Token.EOF,lineNumber:lineNumber,lineStart:lineStart,start:index,end:index}}cp=source.charCodeAt(index);if(isIdentifierStart(cp)){token=scanIdentifier();if(strict&&isStrictModeReservedWord(token.value)){token.type=Token.Keyword}return token} // Very common: ( and ) and ;
	if(cp===0x28||cp===0x29||cp===0x3B){return scanPunctuator()} // String literal starts with single quote (U+0027) or double quote (U+0022).
	if(cp===0x27||cp===0x22){return scanStringLiteral()} // Dot (.) U+002E can also start a floating-point number, hence the need
	// to check the next character.
	if(cp===0x2E){if(isDecimalDigit(source.charCodeAt(index+1))){return scanNumericLiteral()}return scanPunctuator()}if(isDecimalDigit(cp)){return scanNumericLiteral()} // Slash (/) U+002F can also start a regex.
	if(extra.tokenize&&cp===0x2F){return advanceSlash()} // Template literals start with ` (U+0060) for template head
	// or } (U+007D) for template middle or template tail.
	if(cp===0x60||cp===0x7D&&state.curlyStack[state.curlyStack.length-1]==='${'){return scanTemplate()} // Possible identifier start in a surrogate pair.
	if(cp>=0xD800&&cp<0xDFFF){cp=codePointAt(index);if(isIdentifierStart(cp)){return scanIdentifier()}}return scanPunctuator()}function collectToken(){var loc,token,value,entry;loc={start:{line:lineNumber,column:index-lineStart}};token=advance();loc.end={line:lineNumber,column:index-lineStart};if(token.type!==Token.EOF){value=source.slice(token.start,token.end);entry={type:TokenName[token.type],value:value,range:[token.start,token.end],loc:loc};if(token.regex){entry.regex={pattern:token.regex.pattern,flags:token.regex.flags}}if(extra.tokenValues){extra.tokenValues.push(entry.type==='Punctuator'||entry.type==='Keyword'?entry.value:null)}if(extra.tokenize){if(!extra.range){delete entry.range}if(!extra.loc){delete entry.loc}if(extra.delegate){entry=extra.delegate(entry)}}extra.tokens.push(entry)}return token}function lex(){var token;scanning=true;lastIndex=index;lastLineNumber=lineNumber;lastLineStart=lineStart;skipComment();token=lookahead;startIndex=index;startLineNumber=lineNumber;startLineStart=lineStart;lookahead=typeof extra.tokens!=='undefined'?collectToken():advance();scanning=false;return token}function peek(){scanning=true;skipComment();lastIndex=index;lastLineNumber=lineNumber;lastLineStart=lineStart;startIndex=index;startLineNumber=lineNumber;startLineStart=lineStart;lookahead=typeof extra.tokens!=='undefined'?collectToken():advance();scanning=false}function Position(){this.line=startLineNumber;this.column=startIndex-startLineStart}function SourceLocation(){this.start=new Position;this.end=null}function WrappingSourceLocation(startToken){this.start={line:startToken.lineNumber,column:startToken.start-startToken.lineStart};this.end=null}function Node(){if(extra.range){this.range=[startIndex,0]}if(extra.loc){this.loc=new SourceLocation}}function WrappingNode(startToken){if(extra.range){this.range=[startToken.start,0]}if(extra.loc){this.loc=new WrappingSourceLocation(startToken)}}WrappingNode.prototype=Node.prototype={processComment:function(){var lastChild,innerComments,leadingComments,trailingComments,bottomRight=extra.bottomRightStack,i,comment,last=bottomRight[bottomRight.length-1];if(this.type===Syntax.Program){if(this.body.length>0){return}} /**
	             * patch innnerComments for properties empty block
	             * `function a() {/** comments **\/}`
	             */if(this.type===Syntax.BlockStatement&&this.body.length===0){innerComments=[];for(i=extra.leadingComments.length-1;i>=0;--i){comment=extra.leadingComments[i];if(this.range[1]>=comment.range[1]){innerComments.unshift(comment);extra.leadingComments.splice(i,1);extra.trailingComments.splice(i,1)}}if(innerComments.length){this.innerComments=innerComments; //bottomRight.push(this);
	return}}if(extra.trailingComments.length>0){trailingComments=[];for(i=extra.trailingComments.length-1;i>=0;--i){comment=extra.trailingComments[i];if(comment.range[0]>=this.range[1]){trailingComments.unshift(comment);extra.trailingComments.splice(i,1)}}extra.trailingComments=[]}else {if(last&&last.trailingComments&&last.trailingComments[0].range[0]>=this.range[1]){trailingComments=last.trailingComments;delete last.trailingComments}} // Eating the stack.
	while(last&&last.range[0]>=this.range[0]){lastChild=bottomRight.pop();last=bottomRight[bottomRight.length-1]}if(lastChild){if(lastChild.leadingComments){leadingComments=[];for(i=lastChild.leadingComments.length-1;i>=0;--i){comment=lastChild.leadingComments[i];if(comment.range[1]<=this.range[0]){leadingComments.unshift(comment);lastChild.leadingComments.splice(i,1)}}if(!lastChild.leadingComments.length){lastChild.leadingComments=undefined}}}else if(extra.leadingComments.length>0){leadingComments=[];for(i=extra.leadingComments.length-1;i>=0;--i){comment=extra.leadingComments[i];if(comment.range[1]<=this.range[0]){leadingComments.unshift(comment);extra.leadingComments.splice(i,1)}}}if(leadingComments&&leadingComments.length>0){this.leadingComments=leadingComments}if(trailingComments&&trailingComments.length>0){this.trailingComments=trailingComments}bottomRight.push(this)},finish:function(){if(extra.range){this.range[1]=lastIndex}if(extra.loc){this.loc.end={line:lastLineNumber,column:lastIndex-lastLineStart};if(extra.source){this.loc.source=extra.source}}if(extra.attachComment){this.processComment()}},finishArrayExpression:function(elements){this.type=Syntax.ArrayExpression;this.elements=elements;this.finish();return this},finishArrayPattern:function(elements){this.type=Syntax.ArrayPattern;this.elements=elements;this.finish();return this},finishArrowFunctionExpression:function(params,defaults,body,expression){this.type=Syntax.ArrowFunctionExpression;this.id=null;this.params=params;this.defaults=defaults;this.body=body;this.generator=false;this.expression=expression;this.finish();return this},finishAssignmentExpression:function(operator,left,right){this.type=Syntax.AssignmentExpression;this.operator=operator;this.left=left;this.right=right;this.finish();return this},finishAssignmentPattern:function(left,right){this.type=Syntax.AssignmentPattern;this.left=left;this.right=right;this.finish();return this},finishBinaryExpression:function(operator,left,right){this.type=operator==='||'||operator==='&&'?Syntax.LogicalExpression:Syntax.BinaryExpression;this.operator=operator;this.left=left;this.right=right;this.finish();return this},finishBlockStatement:function(body){this.type=Syntax.BlockStatement;this.body=body;this.finish();return this},finishBreakStatement:function(label){this.type=Syntax.BreakStatement;this.label=label;this.finish();return this},finishCallExpression:function(callee,args){this.type=Syntax.CallExpression;this.callee=callee;this.arguments=args;this.finish();return this},finishCatchClause:function(param,body){this.type=Syntax.CatchClause;this.param=param;this.body=body;this.finish();return this},finishClassBody:function(body){this.type=Syntax.ClassBody;this.body=body;this.finish();return this},finishClassDeclaration:function(id,superClass,body){this.type=Syntax.ClassDeclaration;this.id=id;this.superClass=superClass;this.body=body;this.finish();return this},finishClassExpression:function(id,superClass,body){this.type=Syntax.ClassExpression;this.id=id;this.superClass=superClass;this.body=body;this.finish();return this},finishConditionalExpression:function(test,consequent,alternate){this.type=Syntax.ConditionalExpression;this.test=test;this.consequent=consequent;this.alternate=alternate;this.finish();return this},finishContinueStatement:function(label){this.type=Syntax.ContinueStatement;this.label=label;this.finish();return this},finishDebuggerStatement:function(){this.type=Syntax.DebuggerStatement;this.finish();return this},finishDoWhileStatement:function(body,test){this.type=Syntax.DoWhileStatement;this.body=body;this.test=test;this.finish();return this},finishEmptyStatement:function(){this.type=Syntax.EmptyStatement;this.finish();return this},finishExpressionStatement:function(expression){this.type=Syntax.ExpressionStatement;this.expression=expression;this.finish();return this},finishForStatement:function(init,test,update,body){this.type=Syntax.ForStatement;this.init=init;this.test=test;this.update=update;this.body=body;this.finish();return this},finishForOfStatement:function(left,right,body){this.type=Syntax.ForOfStatement;this.left=left;this.right=right;this.body=body;this.finish();return this},finishForInStatement:function(left,right,body){this.type=Syntax.ForInStatement;this.left=left;this.right=right;this.body=body;this.each=false;this.finish();return this},finishFunctionDeclaration:function(id,params,defaults,body,generator){this.type=Syntax.FunctionDeclaration;this.id=id;this.params=params;this.defaults=defaults;this.body=body;this.generator=generator;this.expression=false;this.finish();return this},finishFunctionExpression:function(id,params,defaults,body,generator){this.type=Syntax.FunctionExpression;this.id=id;this.params=params;this.defaults=defaults;this.body=body;this.generator=generator;this.expression=false;this.finish();return this},finishIdentifier:function(name){this.type=Syntax.Identifier;this.name=name;this.finish();return this},finishIfStatement:function(test,consequent,alternate){this.type=Syntax.IfStatement;this.test=test;this.consequent=consequent;this.alternate=alternate;this.finish();return this},finishLabeledStatement:function(label,body){this.type=Syntax.LabeledStatement;this.label=label;this.body=body;this.finish();return this},finishLiteral:function(token){this.type=Syntax.Literal;this.value=token.value;this.raw=source.slice(token.start,token.end);if(token.regex){this.regex=token.regex}this.finish();return this},finishMemberExpression:function(accessor,object,property){this.type=Syntax.MemberExpression;this.computed=accessor==='[';this.object=object;this.property=property;this.finish();return this},finishMetaProperty:function(meta,property){this.type=Syntax.MetaProperty;this.meta=meta;this.property=property;this.finish();return this},finishNewExpression:function(callee,args){this.type=Syntax.NewExpression;this.callee=callee;this.arguments=args;this.finish();return this},finishObjectExpression:function(properties){this.type=Syntax.ObjectExpression;this.properties=properties;this.finish();return this},finishObjectPattern:function(properties){this.type=Syntax.ObjectPattern;this.properties=properties;this.finish();return this},finishPostfixExpression:function(operator,argument){this.type=Syntax.UpdateExpression;this.operator=operator;this.argument=argument;this.prefix=false;this.finish();return this},finishProgram:function(body,sourceType){this.type=Syntax.Program;this.body=body;this.sourceType=sourceType;this.finish();return this},finishProperty:function(kind,key,computed,value,method,shorthand){this.type=Syntax.Property;this.key=key;this.computed=computed;this.value=value;this.kind=kind;this.method=method;this.shorthand=shorthand;this.finish();return this},finishRestElement:function(argument){this.type=Syntax.RestElement;this.argument=argument;this.finish();return this},finishReturnStatement:function(argument){this.type=Syntax.ReturnStatement;this.argument=argument;this.finish();return this},finishSequenceExpression:function(expressions){this.type=Syntax.SequenceExpression;this.expressions=expressions;this.finish();return this},finishSpreadElement:function(argument){this.type=Syntax.SpreadElement;this.argument=argument;this.finish();return this},finishSwitchCase:function(test,consequent){this.type=Syntax.SwitchCase;this.test=test;this.consequent=consequent;this.finish();return this},finishSuper:function(){this.type=Syntax.Super;this.finish();return this},finishSwitchStatement:function(discriminant,cases){this.type=Syntax.SwitchStatement;this.discriminant=discriminant;this.cases=cases;this.finish();return this},finishTaggedTemplateExpression:function(tag,quasi){this.type=Syntax.TaggedTemplateExpression;this.tag=tag;this.quasi=quasi;this.finish();return this},finishTemplateElement:function(value,tail){this.type=Syntax.TemplateElement;this.value=value;this.tail=tail;this.finish();return this},finishTemplateLiteral:function(quasis,expressions){this.type=Syntax.TemplateLiteral;this.quasis=quasis;this.expressions=expressions;this.finish();return this},finishThisExpression:function(){this.type=Syntax.ThisExpression;this.finish();return this},finishThrowStatement:function(argument){this.type=Syntax.ThrowStatement;this.argument=argument;this.finish();return this},finishTryStatement:function(block,handler,finalizer){this.type=Syntax.TryStatement;this.block=block;this.guardedHandlers=[];this.handlers=handler?[handler]:[];this.handler=handler;this.finalizer=finalizer;this.finish();return this},finishUnaryExpression:function(operator,argument){this.type=operator==='++'||operator==='--'?Syntax.UpdateExpression:Syntax.UnaryExpression;this.operator=operator;this.argument=argument;this.prefix=true;this.finish();return this},finishVariableDeclaration:function(declarations){this.type=Syntax.VariableDeclaration;this.declarations=declarations;this.kind='var';this.finish();return this},finishLexicalDeclaration:function(declarations,kind){this.type=Syntax.VariableDeclaration;this.declarations=declarations;this.kind=kind;this.finish();return this},finishVariableDeclarator:function(id,init){this.type=Syntax.VariableDeclarator;this.id=id;this.init=init;this.finish();return this},finishWhileStatement:function(test,body){this.type=Syntax.WhileStatement;this.test=test;this.body=body;this.finish();return this},finishWithStatement:function(object,body){this.type=Syntax.WithStatement;this.object=object;this.body=body;this.finish();return this},finishExportSpecifier:function(local,exported){this.type=Syntax.ExportSpecifier;this.exported=exported||local;this.local=local;this.finish();return this},finishImportDefaultSpecifier:function(local){this.type=Syntax.ImportDefaultSpecifier;this.local=local;this.finish();return this},finishImportNamespaceSpecifier:function(local){this.type=Syntax.ImportNamespaceSpecifier;this.local=local;this.finish();return this},finishExportNamedDeclaration:function(declaration,specifiers,src){this.type=Syntax.ExportNamedDeclaration;this.declaration=declaration;this.specifiers=specifiers;this.source=src;this.finish();return this},finishExportDefaultDeclaration:function(declaration){this.type=Syntax.ExportDefaultDeclaration;this.declaration=declaration;this.finish();return this},finishExportAllDeclaration:function(src){this.type=Syntax.ExportAllDeclaration;this.source=src;this.finish();return this},finishImportSpecifier:function(local,imported){this.type=Syntax.ImportSpecifier;this.local=local||imported;this.imported=imported;this.finish();return this},finishImportDeclaration:function(specifiers,src){this.type=Syntax.ImportDeclaration;this.specifiers=specifiers;this.source=src;this.finish();return this},finishYieldExpression:function(argument,delegate){this.type=Syntax.YieldExpression;this.argument=argument;this.delegate=delegate;this.finish();return this}};function recordError(error){var e,existing;for(e=0;e<extra.errors.length;e++){existing=extra.errors[e]; // Prevent duplicated error.
	/* istanbul ignore next */if(existing.index===error.index&&existing.message===error.message){return}}extra.errors.push(error)}function constructError(msg,column){var error=new Error(msg);try{throw error}catch(base) { /* istanbul ignore else */if(Object.create&&Object.defineProperty){error=Object.create(base);Object.defineProperty(error,'column',{value:column})}}finally {return error}}function createError(line,pos,description){var msg,column,error;msg='Line '+line+': '+description;column=pos-(scanning?lineStart:lastLineStart)+1;error=constructError(msg,column);error.lineNumber=line;error.description=description;error.index=pos;return error} // Throw an exception
	function throwError(messageFormat){var args,msg;args=Array.prototype.slice.call(arguments,1);msg=messageFormat.replace(/%(\d)/g,function(whole,idx){assert(idx<args.length,'Message reference must be in range');return args[idx]});throw createError(lastLineNumber,lastIndex,msg)}function tolerateError(messageFormat){var args,msg,error;args=Array.prototype.slice.call(arguments,1); /* istanbul ignore next */msg=messageFormat.replace(/%(\d)/g,function(whole,idx){assert(idx<args.length,'Message reference must be in range');return args[idx]});error=createError(lineNumber,lastIndex,msg);if(extra.errors){recordError(error)}else {throw error}} // Throw an exception because of the token.
	function unexpectedTokenError(token,message){var value,msg=message||Messages.UnexpectedToken;if(token){if(!message){msg=token.type===Token.EOF?Messages.UnexpectedEOS:token.type===Token.Identifier?Messages.UnexpectedIdentifier:token.type===Token.NumericLiteral?Messages.UnexpectedNumber:token.type===Token.StringLiteral?Messages.UnexpectedString:token.type===Token.Template?Messages.UnexpectedTemplate:Messages.UnexpectedToken;if(token.type===Token.Keyword){if(isFutureReservedWord(token.value)){msg=Messages.UnexpectedReserved}else if(strict&&isStrictModeReservedWord(token.value)){msg=Messages.StrictReservedWord}}}value=token.type===Token.Template?token.value.raw:token.value}else {value='ILLEGAL'}msg=msg.replace('%0',value);return token&&typeof token.lineNumber==='number'?createError(token.lineNumber,token.start,msg):createError(scanning?lineNumber:lastLineNumber,scanning?index:lastIndex,msg)}function throwUnexpectedToken(token,message){throw unexpectedTokenError(token,message)}function tolerateUnexpectedToken(token,message){var error=unexpectedTokenError(token,message);if(extra.errors){recordError(error)}else {throw error}} // Expect the next token to match the specified punctuator.
	// If not, an exception will be thrown.
	function expect(value){var token=lex();if(token.type!==Token.Punctuator||token.value!==value){throwUnexpectedToken(token)}} /**
	     * @name expectCommaSeparator
	     * @description Quietly expect a comma when in tolerant mode, otherwise delegates
	     * to <code>expect(value)</code>
	     * @since 2.0
	     */function expectCommaSeparator(){var token;if(extra.errors){token=lookahead;if(token.type===Token.Punctuator&&token.value===','){lex()}else if(token.type===Token.Punctuator&&token.value===';'){lex();tolerateUnexpectedToken(token)}else {tolerateUnexpectedToken(token,Messages.UnexpectedToken)}}else {expect(',')}} // Expect the next token to match the specified keyword.
	// If not, an exception will be thrown.
	function expectKeyword(keyword){var token=lex();if(token.type!==Token.Keyword||token.value!==keyword){throwUnexpectedToken(token)}} // Return true if the next token matches the specified punctuator.
	function match(value){return lookahead.type===Token.Punctuator&&lookahead.value===value} // Return true if the next token matches the specified keyword
	function matchKeyword(keyword){return lookahead.type===Token.Keyword&&lookahead.value===keyword} // Return true if the next token matches the specified contextual keyword
	// (where an identifier is sometimes a keyword depending on the context)
	function matchContextualKeyword(keyword){return lookahead.type===Token.Identifier&&lookahead.value===keyword} // Return true if the next token is an assignment operator
	function matchAssign(){var op;if(lookahead.type!==Token.Punctuator){return false}op=lookahead.value;return op==='='||op==='*='||op==='/='||op==='%='||op==='+='||op==='-='||op==='<<='||op==='>>='||op==='>>>='||op==='&='||op==='^='||op==='|='}function consumeSemicolon(){ // Catch the very common case first: immediately a semicolon (U+003B).
	if(source.charCodeAt(startIndex)===0x3B||match(';')){lex();return}if(hasLineTerminator){return} // FIXME(ikarienator): this is seemingly an issue in the previous location info convention.
	lastIndex=startIndex;lastLineNumber=startLineNumber;lastLineStart=startLineStart;if(lookahead.type!==Token.EOF&&!match('}')){throwUnexpectedToken(lookahead)}} // Cover grammar support.
	//
	// When an assignment expression position starts with an left parenthesis, the determination of the type
	// of the syntax is to be deferred arbitrarily long until the end of the parentheses pair (plus a lookahead)
	// or the first comma. This situation also defers the determination of all the expressions nested in the pair.
	//
	// There are three productions that can be parsed in a parentheses pair that needs to be determined
	// after the outermost pair is closed. They are:
	//
	//   1. AssignmentExpression
	//   2. BindingElements
	//   3. AssignmentTargets
	//
	// In order to avoid exponential backtracking, we use two flags to denote if the production can be
	// binding element or assignment target.
	//
	// The three productions have the relationship:
	//
	//   BindingElements  AssignmentTargets  AssignmentExpression
	//
	// with a single exception that CoverInitializedName when used directly in an Expression, generates
	// an early error. Therefore, we need the third state, firstCoverInitializedNameError, to track the
	// first usage of CoverInitializedName and report it when we reached the end of the parentheses pair.
	//
	// isolateCoverGrammar function runs the given parser function with a new cover grammar context, and it does not
	// effect the current flags. This means the production the parser parses is only used as an expression. Therefore
	// the CoverInitializedName check is conducted.
	//
	// inheritCoverGrammar function runs the given parse function with a new cover grammar context, and it propagates
	// the flags outside of the parser. This means the production the parser parses is used as a part of a potential
	// pattern. The CoverInitializedName check is deferred.
	function isolateCoverGrammar(parser){var oldIsBindingElement=isBindingElement,oldIsAssignmentTarget=isAssignmentTarget,oldFirstCoverInitializedNameError=firstCoverInitializedNameError,result;isBindingElement=true;isAssignmentTarget=true;firstCoverInitializedNameError=null;result=parser();if(firstCoverInitializedNameError!==null){throwUnexpectedToken(firstCoverInitializedNameError)}isBindingElement=oldIsBindingElement;isAssignmentTarget=oldIsAssignmentTarget;firstCoverInitializedNameError=oldFirstCoverInitializedNameError;return result}function inheritCoverGrammar(parser){var oldIsBindingElement=isBindingElement,oldIsAssignmentTarget=isAssignmentTarget,oldFirstCoverInitializedNameError=firstCoverInitializedNameError,result;isBindingElement=true;isAssignmentTarget=true;firstCoverInitializedNameError=null;result=parser();isBindingElement=isBindingElement&&oldIsBindingElement;isAssignmentTarget=isAssignmentTarget&&oldIsAssignmentTarget;firstCoverInitializedNameError=oldFirstCoverInitializedNameError||firstCoverInitializedNameError;return result} // ECMA-262 13.3.3 Destructuring Binding Patterns
	function parseArrayPattern(params,kind){var node=new Node,elements=[],rest,restNode;expect('[');while(!match(']')){if(match(',')){lex();elements.push(null)}else {if(match('...')){restNode=new Node;lex();params.push(lookahead);rest=parseVariableIdentifier(kind);elements.push(restNode.finishRestElement(rest));break}else {elements.push(parsePatternWithDefault(params,kind))}if(!match(']')){expect(',')}}}expect(']');return node.finishArrayPattern(elements)}function parsePropertyPattern(params,kind){var node=new Node,key,keyToken,computed=match('['),init;if(lookahead.type===Token.Identifier){keyToken=lookahead;key=parseVariableIdentifier();if(match('=')){params.push(keyToken);lex();init=parseAssignmentExpression();return node.finishProperty('init',key,false,new WrappingNode(keyToken).finishAssignmentPattern(key,init),false,false)}else if(!match(':')){params.push(keyToken);return node.finishProperty('init',key,false,key,false,true)}}else {key=parseObjectPropertyKey()}expect(':');init=parsePatternWithDefault(params,kind);return node.finishProperty('init',key,computed,init,false,false)}function parseObjectPattern(params,kind){var node=new Node,properties=[];expect('{');while(!match('}')){properties.push(parsePropertyPattern(params,kind));if(!match('}')){expect(',')}}lex();return node.finishObjectPattern(properties)}function parsePattern(params,kind){if(match('[')){return parseArrayPattern(params,kind)}else if(match('{')){return parseObjectPattern(params,kind)}else if(matchKeyword('let')){if(kind==='const'||kind==='let'){tolerateUnexpectedToken(lookahead,Messages.UnexpectedToken)}}params.push(lookahead);return parseVariableIdentifier(kind)}function parsePatternWithDefault(params,kind){var startToken=lookahead,pattern,previousAllowYield,right;pattern=parsePattern(params,kind);if(match('=')){lex();previousAllowYield=state.allowYield;state.allowYield=true;right=isolateCoverGrammar(parseAssignmentExpression);state.allowYield=previousAllowYield;pattern=new WrappingNode(startToken).finishAssignmentPattern(pattern,right)}return pattern} // ECMA-262 12.2.5 Array Initializer
	function parseArrayInitializer(){var elements=[],node=new Node,restSpread;expect('[');while(!match(']')){if(match(',')){lex();elements.push(null)}else if(match('...')){restSpread=new Node;lex();restSpread.finishSpreadElement(inheritCoverGrammar(parseAssignmentExpression));if(!match(']')){isAssignmentTarget=isBindingElement=false;expect(',')}elements.push(restSpread)}else {elements.push(inheritCoverGrammar(parseAssignmentExpression));if(!match(']')){expect(',')}}}lex();return node.finishArrayExpression(elements)} // ECMA-262 12.2.6 Object Initializer
	function parsePropertyFunction(node,paramInfo,isGenerator){var previousStrict,body;isAssignmentTarget=isBindingElement=false;previousStrict=strict;body=isolateCoverGrammar(parseFunctionSourceElements);if(strict&&paramInfo.firstRestricted){tolerateUnexpectedToken(paramInfo.firstRestricted,paramInfo.message)}if(strict&&paramInfo.stricted){tolerateUnexpectedToken(paramInfo.stricted,paramInfo.message)}strict=previousStrict;return node.finishFunctionExpression(null,paramInfo.params,paramInfo.defaults,body,isGenerator)}function parsePropertyMethodFunction(){var params,method,node=new Node,previousAllowYield=state.allowYield;state.allowYield=false;params=parseParams();state.allowYield=previousAllowYield;state.allowYield=false;method=parsePropertyFunction(node,params,false);state.allowYield=previousAllowYield;return method}function parseObjectPropertyKey(){var token,node=new Node,expr;token=lex(); // Note: This function is called only from parseObjectProperty(), where
	// EOF and Punctuator tokens are already filtered out.
	switch(token.type){case Token.StringLiteral:case Token.NumericLiteral:if(strict&&token.octal){tolerateUnexpectedToken(token,Messages.StrictOctalLiteral)}return node.finishLiteral(token);case Token.Identifier:case Token.BooleanLiteral:case Token.NullLiteral:case Token.Keyword:return node.finishIdentifier(token.value);case Token.Punctuator:if(token.value==='['){expr=isolateCoverGrammar(parseAssignmentExpression);expect(']');return expr}break;}throwUnexpectedToken(token)}function lookaheadPropertyName(){switch(lookahead.type){case Token.Identifier:case Token.StringLiteral:case Token.BooleanLiteral:case Token.NullLiteral:case Token.NumericLiteral:case Token.Keyword:return true;case Token.Punctuator:return lookahead.value==='[';}return false} // This function is to try to parse a MethodDefinition as defined in 14.3. But in the case of object literals,
	// it might be called at a position where there is in fact a short hand identifier pattern or a data property.
	// This can only be determined after we consumed up to the left parentheses.
	//
	// In order to avoid back tracking, it returns `null` if the position is not a MethodDefinition and the caller
	// is responsible to visit other options.
	function tryParseMethodDefinition(token,key,computed,node){var value,options,methodNode,params,previousAllowYield=state.allowYield;if(token.type===Token.Identifier){ // check for `get` and `set`;
	if(token.value==='get'&&lookaheadPropertyName()){computed=match('[');key=parseObjectPropertyKey();methodNode=new Node;expect('(');expect(')');state.allowYield=false;value=parsePropertyFunction(methodNode,{params:[],defaults:[],stricted:null,firstRestricted:null,message:null},false);state.allowYield=previousAllowYield;return node.finishProperty('get',key,computed,value,false,false)}else if(token.value==='set'&&lookaheadPropertyName()){computed=match('[');key=parseObjectPropertyKey();methodNode=new Node;expect('(');options={params:[],defaultCount:0,defaults:[],firstRestricted:null,paramSet:{}};if(match(')')){tolerateUnexpectedToken(lookahead)}else {state.allowYield=false;parseParam(options);state.allowYield=previousAllowYield;if(options.defaultCount===0){options.defaults=[]}}expect(')');state.allowYield=false;value=parsePropertyFunction(methodNode,options,false);state.allowYield=previousAllowYield;return node.finishProperty('set',key,computed,value,false,false)}}else if(token.type===Token.Punctuator&&token.value==='*'&&lookaheadPropertyName()){computed=match('[');key=parseObjectPropertyKey();methodNode=new Node;state.allowYield=true;params=parseParams();state.allowYield=previousAllowYield;state.allowYield=false;value=parsePropertyFunction(methodNode,params,true);state.allowYield=previousAllowYield;return node.finishProperty('init',key,computed,value,true,false)}if(key&&match('(')){value=parsePropertyMethodFunction();return node.finishProperty('init',key,computed,value,true,false)} // Not a MethodDefinition.
	return null}function parseObjectProperty(hasProto){var token=lookahead,node=new Node,computed,key,maybeMethod,proto,value;computed=match('[');if(match('*')){lex()}else {key=parseObjectPropertyKey()}maybeMethod=tryParseMethodDefinition(token,key,computed,node);if(maybeMethod){return maybeMethod}if(!key){throwUnexpectedToken(lookahead)} // Check for duplicated __proto__
	if(!computed){proto=key.type===Syntax.Identifier&&key.name==='__proto__'||key.type===Syntax.Literal&&key.value==='__proto__';if(hasProto.value&&proto){tolerateError(Messages.DuplicateProtoProperty)}hasProto.value|=proto}if(match(':')){lex();value=inheritCoverGrammar(parseAssignmentExpression);return node.finishProperty('init',key,computed,value,false,false)}if(token.type===Token.Identifier){if(match('=')){firstCoverInitializedNameError=lookahead;lex();value=isolateCoverGrammar(parseAssignmentExpression);return node.finishProperty('init',key,computed,new WrappingNode(token).finishAssignmentPattern(key,value),false,true)}return node.finishProperty('init',key,computed,key,false,true)}throwUnexpectedToken(lookahead)}function parseObjectInitializer(){var properties=[],hasProto={value:false},node=new Node;expect('{');while(!match('}')){properties.push(parseObjectProperty(hasProto));if(!match('}')){expectCommaSeparator()}}expect('}');return node.finishObjectExpression(properties)}function reinterpretExpressionAsPattern(expr){var i;switch(expr.type){case Syntax.Identifier:case Syntax.MemberExpression:case Syntax.RestElement:case Syntax.AssignmentPattern:break;case Syntax.SpreadElement:expr.type=Syntax.RestElement;reinterpretExpressionAsPattern(expr.argument);break;case Syntax.ArrayExpression:expr.type=Syntax.ArrayPattern;for(i=0;i<expr.elements.length;i++){if(expr.elements[i]!==null){reinterpretExpressionAsPattern(expr.elements[i])}}break;case Syntax.ObjectExpression:expr.type=Syntax.ObjectPattern;for(i=0;i<expr.properties.length;i++){reinterpretExpressionAsPattern(expr.properties[i].value)}break;case Syntax.AssignmentExpression:expr.type=Syntax.AssignmentPattern;reinterpretExpressionAsPattern(expr.left);break;default: // Allow other node type for tolerant parsing.
	break;}} // ECMA-262 12.2.9 Template Literals
	function parseTemplateElement(option){var node,token;if(lookahead.type!==Token.Template||option.head&&!lookahead.head){throwUnexpectedToken()}node=new Node;token=lex();return node.finishTemplateElement({raw:token.value.raw,cooked:token.value.cooked},token.tail)}function parseTemplateLiteral(){var quasi,quasis,expressions,node=new Node;quasi=parseTemplateElement({head:true});quasis=[quasi];expressions=[];while(!quasi.tail){expressions.push(parseExpression());quasi=parseTemplateElement({head:false});quasis.push(quasi)}return node.finishTemplateLiteral(quasis,expressions)} // ECMA-262 12.2.10 The Grouping Operator
	function parseGroupExpression(){var expr,expressions,startToken,i,params=[];expect('(');if(match(')')){lex();if(!match('=>')){expect('=>')}return {type:PlaceHolders.ArrowParameterPlaceHolder,params:[],rawParams:[]}}startToken=lookahead;if(match('...')){expr=parseRestElement(params);expect(')');if(!match('=>')){expect('=>')}return {type:PlaceHolders.ArrowParameterPlaceHolder,params:[expr]}}isBindingElement=true;expr=inheritCoverGrammar(parseAssignmentExpression);if(match(',')){isAssignmentTarget=false;expressions=[expr];while(startIndex<length){if(!match(',')){break}lex();if(match('...')){if(!isBindingElement){throwUnexpectedToken(lookahead)}expressions.push(parseRestElement(params));expect(')');if(!match('=>')){expect('=>')}isBindingElement=false;for(i=0;i<expressions.length;i++){reinterpretExpressionAsPattern(expressions[i])}return {type:PlaceHolders.ArrowParameterPlaceHolder,params:expressions}}expressions.push(inheritCoverGrammar(parseAssignmentExpression))}expr=new WrappingNode(startToken).finishSequenceExpression(expressions)}expect(')');if(match('=>')){if(expr.type===Syntax.Identifier&&expr.name==='yield'){return {type:PlaceHolders.ArrowParameterPlaceHolder,params:[expr]}}if(!isBindingElement){throwUnexpectedToken(lookahead)}if(expr.type===Syntax.SequenceExpression){for(i=0;i<expr.expressions.length;i++){reinterpretExpressionAsPattern(expr.expressions[i])}}else {reinterpretExpressionAsPattern(expr)}expr={type:PlaceHolders.ArrowParameterPlaceHolder,params:expr.type===Syntax.SequenceExpression?expr.expressions:[expr]}}isBindingElement=false;return expr} // ECMA-262 12.2 Primary Expressions
	function parsePrimaryExpression(){var type,token,expr,node;if(match('(')){isBindingElement=false;return inheritCoverGrammar(parseGroupExpression)}if(match('[')){return inheritCoverGrammar(parseArrayInitializer)}if(match('{')){return inheritCoverGrammar(parseObjectInitializer)}type=lookahead.type;node=new Node;if(type===Token.Identifier){if(state.sourceType==='module'&&lookahead.value==='await'){tolerateUnexpectedToken(lookahead)}expr=node.finishIdentifier(lex().value)}else if(type===Token.StringLiteral||type===Token.NumericLiteral){isAssignmentTarget=isBindingElement=false;if(strict&&lookahead.octal){tolerateUnexpectedToken(lookahead,Messages.StrictOctalLiteral)}expr=node.finishLiteral(lex())}else if(type===Token.Keyword){if(!strict&&state.allowYield&&matchKeyword('yield')){return parseNonComputedProperty()}isAssignmentTarget=isBindingElement=false;if(matchKeyword('function')){return parseFunctionExpression()}if(matchKeyword('this')){lex();return node.finishThisExpression()}if(matchKeyword('class')){return parseClassExpression()}if(!strict&&matchKeyword('let')){return node.finishIdentifier(lex().value)}throwUnexpectedToken(lex())}else if(type===Token.BooleanLiteral){isAssignmentTarget=isBindingElement=false;token=lex();token.value=token.value==='true';expr=node.finishLiteral(token)}else if(type===Token.NullLiteral){isAssignmentTarget=isBindingElement=false;token=lex();token.value=null;expr=node.finishLiteral(token)}else if(match('/')||match('/=')){isAssignmentTarget=isBindingElement=false;index=startIndex;if(typeof extra.tokens!=='undefined'){token=collectRegex()}else {token=scanRegExp()}lex();expr=node.finishLiteral(token)}else if(type===Token.Template){expr=parseTemplateLiteral()}else {throwUnexpectedToken(lex())}return expr} // ECMA-262 12.3 Left-Hand-Side Expressions
	function parseArguments(){var args=[],expr;expect('(');if(!match(')')){while(startIndex<length){if(match('...')){expr=new Node;lex();expr.finishSpreadElement(isolateCoverGrammar(parseAssignmentExpression))}else {expr=isolateCoverGrammar(parseAssignmentExpression)}args.push(expr);if(match(')')){break}expectCommaSeparator()}}expect(')');return args}function parseNonComputedProperty(){var token,node=new Node;token=lex();if(!isIdentifierName(token)){throwUnexpectedToken(token)}return node.finishIdentifier(token.value)}function parseNonComputedMember(){expect('.');return parseNonComputedProperty()}function parseComputedMember(){var expr;expect('[');expr=isolateCoverGrammar(parseExpression);expect(']');return expr} // ECMA-262 12.3.3 The new Operator
	function parseNewExpression(){var callee,args,node=new Node;expectKeyword('new');if(match('.')){lex();if(lookahead.type===Token.Identifier&&lookahead.value==='target'){if(state.inFunctionBody){lex();return node.finishMetaProperty('new','target')}}throwUnexpectedToken(lookahead)}callee=isolateCoverGrammar(parseLeftHandSideExpression);args=match('(')?parseArguments():[];isAssignmentTarget=isBindingElement=false;return node.finishNewExpression(callee,args)} // ECMA-262 12.3.4 Function Calls
	function parseLeftHandSideExpressionAllowCall(){var quasi,expr,args,property,startToken,previousAllowIn=state.allowIn;startToken=lookahead;state.allowIn=true;if(matchKeyword('super')&&state.inFunctionBody){expr=new Node;lex();expr=expr.finishSuper();if(!match('(')&&!match('.')&&!match('[')){throwUnexpectedToken(lookahead)}}else {expr=inheritCoverGrammar(matchKeyword('new')?parseNewExpression:parsePrimaryExpression)}for(;;){if(match('.')){isBindingElement=false;isAssignmentTarget=true;property=parseNonComputedMember();expr=new WrappingNode(startToken).finishMemberExpression('.',expr,property)}else if(match('(')){isBindingElement=false;isAssignmentTarget=false;args=parseArguments();expr=new WrappingNode(startToken).finishCallExpression(expr,args)}else if(match('[')){isBindingElement=false;isAssignmentTarget=true;property=parseComputedMember();expr=new WrappingNode(startToken).finishMemberExpression('[',expr,property)}else if(lookahead.type===Token.Template&&lookahead.head){quasi=parseTemplateLiteral();expr=new WrappingNode(startToken).finishTaggedTemplateExpression(expr,quasi)}else {break}}state.allowIn=previousAllowIn;return expr} // ECMA-262 12.3 Left-Hand-Side Expressions
	function parseLeftHandSideExpression(){var quasi,expr,property,startToken;assert(state.allowIn,'callee of new expression always allow in keyword.');startToken=lookahead;if(matchKeyword('super')&&state.inFunctionBody){expr=new Node;lex();expr=expr.finishSuper();if(!match('[')&&!match('.')){throwUnexpectedToken(lookahead)}}else {expr=inheritCoverGrammar(matchKeyword('new')?parseNewExpression:parsePrimaryExpression)}for(;;){if(match('[')){isBindingElement=false;isAssignmentTarget=true;property=parseComputedMember();expr=new WrappingNode(startToken).finishMemberExpression('[',expr,property)}else if(match('.')){isBindingElement=false;isAssignmentTarget=true;property=parseNonComputedMember();expr=new WrappingNode(startToken).finishMemberExpression('.',expr,property)}else if(lookahead.type===Token.Template&&lookahead.head){quasi=parseTemplateLiteral();expr=new WrappingNode(startToken).finishTaggedTemplateExpression(expr,quasi)}else {break}}return expr} // ECMA-262 12.4 Postfix Expressions
	function parsePostfixExpression(){var expr,token,startToken=lookahead;expr=inheritCoverGrammar(parseLeftHandSideExpressionAllowCall);if(!hasLineTerminator&&lookahead.type===Token.Punctuator){if(match('++')||match('--')){ // ECMA-262 11.3.1, 11.3.2
	if(strict&&expr.type===Syntax.Identifier&&isRestrictedWord(expr.name)){tolerateError(Messages.StrictLHSPostfix)}if(!isAssignmentTarget){tolerateError(Messages.InvalidLHSInAssignment)}isAssignmentTarget=isBindingElement=false;token=lex();expr=new WrappingNode(startToken).finishPostfixExpression(token.value,expr)}}return expr} // ECMA-262 12.5 Unary Operators
	function parseUnaryExpression(){var token,expr,startToken;if(lookahead.type!==Token.Punctuator&&lookahead.type!==Token.Keyword){expr=parsePostfixExpression()}else if(match('++')||match('--')){startToken=lookahead;token=lex();expr=inheritCoverGrammar(parseUnaryExpression); // ECMA-262 11.4.4, 11.4.5
	if(strict&&expr.type===Syntax.Identifier&&isRestrictedWord(expr.name)){tolerateError(Messages.StrictLHSPrefix)}if(!isAssignmentTarget){tolerateError(Messages.InvalidLHSInAssignment)}expr=new WrappingNode(startToken).finishUnaryExpression(token.value,expr);isAssignmentTarget=isBindingElement=false}else if(match('+')||match('-')||match('~')||match('!')){startToken=lookahead;token=lex();expr=inheritCoverGrammar(parseUnaryExpression);expr=new WrappingNode(startToken).finishUnaryExpression(token.value,expr);isAssignmentTarget=isBindingElement=false}else if(matchKeyword('delete')||matchKeyword('void')||matchKeyword('typeof')){startToken=lookahead;token=lex();expr=inheritCoverGrammar(parseUnaryExpression);expr=new WrappingNode(startToken).finishUnaryExpression(token.value,expr);if(strict&&expr.operator==='delete'&&expr.argument.type===Syntax.Identifier){tolerateError(Messages.StrictDelete)}isAssignmentTarget=isBindingElement=false}else {expr=parsePostfixExpression()}return expr}function binaryPrecedence(token,allowIn){var prec=0;if(token.type!==Token.Punctuator&&token.type!==Token.Keyword){return 0}switch(token.value){case '||':prec=1;break;case '&&':prec=2;break;case '|':prec=3;break;case '^':prec=4;break;case '&':prec=5;break;case '==':case '!=':case '===':case '!==':prec=6;break;case '<':case '>':case '<=':case '>=':case 'instanceof':prec=7;break;case 'in':prec=allowIn?7:0;break;case '<<':case '>>':case '>>>':prec=8;break;case '+':case '-':prec=9;break;case '*':case '/':case '%':prec=11;break;default:break;}return prec} // ECMA-262 12.6 Multiplicative Operators
	// ECMA-262 12.7 Additive Operators
	// ECMA-262 12.8 Bitwise Shift Operators
	// ECMA-262 12.9 Relational Operators
	// ECMA-262 12.10 Equality Operators
	// ECMA-262 12.11 Binary Bitwise Operators
	// ECMA-262 12.12 Binary Logical Operators
	function parseBinaryExpression(){var marker,markers,expr,token,prec,stack,right,operator,left,i;marker=lookahead;left=inheritCoverGrammar(parseUnaryExpression);token=lookahead;prec=binaryPrecedence(token,state.allowIn);if(prec===0){return left}isAssignmentTarget=isBindingElement=false;token.prec=prec;lex();markers=[marker,lookahead];right=isolateCoverGrammar(parseUnaryExpression);stack=[left,token,right];while((prec=binaryPrecedence(lookahead,state.allowIn))>0){ // Reduce: make a binary expression from the three topmost entries.
	while(stack.length>2&&prec<=stack[stack.length-2].prec){right=stack.pop();operator=stack.pop().value;left=stack.pop();markers.pop();expr=new WrappingNode(markers[markers.length-1]).finishBinaryExpression(operator,left,right);stack.push(expr)} // Shift.
	token=lex();token.prec=prec;stack.push(token);markers.push(lookahead);expr=isolateCoverGrammar(parseUnaryExpression);stack.push(expr)} // Final reduce to clean-up the stack.
	i=stack.length-1;expr=stack[i];markers.pop();while(i>1){expr=new WrappingNode(markers.pop()).finishBinaryExpression(stack[i-1].value,stack[i-2],expr);i-=2}return expr} // ECMA-262 12.13 Conditional Operator
	function parseConditionalExpression(){var expr,previousAllowIn,consequent,alternate,startToken;startToken=lookahead;expr=inheritCoverGrammar(parseBinaryExpression);if(match('?')){lex();previousAllowIn=state.allowIn;state.allowIn=true;consequent=isolateCoverGrammar(parseAssignmentExpression);state.allowIn=previousAllowIn;expect(':');alternate=isolateCoverGrammar(parseAssignmentExpression);expr=new WrappingNode(startToken).finishConditionalExpression(expr,consequent,alternate);isAssignmentTarget=isBindingElement=false}return expr} // ECMA-262 14.2 Arrow Function Definitions
	function parseConciseBody(){if(match('{')){return parseFunctionSourceElements()}return isolateCoverGrammar(parseAssignmentExpression)}function checkPatternParam(options,param){var i;switch(param.type){case Syntax.Identifier:validateParam(options,param,param.name);break;case Syntax.RestElement:checkPatternParam(options,param.argument);break;case Syntax.AssignmentPattern:checkPatternParam(options,param.left);break;case Syntax.ArrayPattern:for(i=0;i<param.elements.length;i++){if(param.elements[i]!==null){checkPatternParam(options,param.elements[i])}}break;case Syntax.YieldExpression:break;default:assert(param.type===Syntax.ObjectPattern,'Invalid type');for(i=0;i<param.properties.length;i++){checkPatternParam(options,param.properties[i].value)}break;}}function reinterpretAsCoverFormalsList(expr){var i,len,param,params,defaults,defaultCount,options,token;defaults=[];defaultCount=0;params=[expr];switch(expr.type){case Syntax.Identifier:break;case PlaceHolders.ArrowParameterPlaceHolder:params=expr.params;break;default:return null;}options={paramSet:{}};for(i=0,len=params.length;i<len;i+=1){param=params[i];switch(param.type){case Syntax.AssignmentPattern:params[i]=param.left;if(param.right.type===Syntax.YieldExpression){if(param.right.argument){throwUnexpectedToken(lookahead)}param.right.type=Syntax.Identifier;param.right.name='yield';delete param.right.argument;delete param.right.delegate}defaults.push(param.right);++defaultCount;checkPatternParam(options,param.left);break;default:checkPatternParam(options,param);params[i]=param;defaults.push(null);break;}}if(strict||!state.allowYield){for(i=0,len=params.length;i<len;i+=1){param=params[i];if(param.type===Syntax.YieldExpression){throwUnexpectedToken(lookahead)}}}if(options.message===Messages.StrictParamDupe){token=strict?options.stricted:options.firstRestricted;throwUnexpectedToken(token,options.message)}if(defaultCount===0){defaults=[]}return {params:params,defaults:defaults,stricted:options.stricted,firstRestricted:options.firstRestricted,message:options.message}}function parseArrowFunctionExpression(options,node){var previousStrict,previousAllowYield,body;if(hasLineTerminator){tolerateUnexpectedToken(lookahead)}expect('=>');previousStrict=strict;previousAllowYield=state.allowYield;state.allowYield=true;body=parseConciseBody();if(strict&&options.firstRestricted){throwUnexpectedToken(options.firstRestricted,options.message)}if(strict&&options.stricted){tolerateUnexpectedToken(options.stricted,options.message)}strict=previousStrict;state.allowYield=previousAllowYield;return node.finishArrowFunctionExpression(options.params,options.defaults,body,body.type!==Syntax.BlockStatement)} // ECMA-262 14.4 Yield expression
	function parseYieldExpression(){var argument,expr,delegate,previousAllowYield;argument=null;expr=new Node;expectKeyword('yield');if(!hasLineTerminator){previousAllowYield=state.allowYield;state.allowYield=false;delegate=match('*');if(delegate){lex();argument=parseAssignmentExpression()}else {if(!match(';')&&!match('}')&&!match(')')&&lookahead.type!==Token.EOF){argument=parseAssignmentExpression()}}state.allowYield=previousAllowYield}return expr.finishYieldExpression(argument,delegate)} // ECMA-262 12.14 Assignment Operators
	function parseAssignmentExpression(){var token,expr,right,list,startToken;startToken=lookahead;token=lookahead;if(!state.allowYield&&matchKeyword('yield')){return parseYieldExpression()}expr=parseConditionalExpression();if(expr.type===PlaceHolders.ArrowParameterPlaceHolder||match('=>')){isAssignmentTarget=isBindingElement=false;list=reinterpretAsCoverFormalsList(expr);if(list){firstCoverInitializedNameError=null;return parseArrowFunctionExpression(list,new WrappingNode(startToken))}return expr}if(matchAssign()){if(!isAssignmentTarget){tolerateError(Messages.InvalidLHSInAssignment)} // ECMA-262 12.1.1
	if(strict&&expr.type===Syntax.Identifier){if(isRestrictedWord(expr.name)){tolerateUnexpectedToken(token,Messages.StrictLHSAssignment)}if(isStrictModeReservedWord(expr.name)){tolerateUnexpectedToken(token,Messages.StrictReservedWord)}}if(!match('=')){isAssignmentTarget=isBindingElement=false}else {reinterpretExpressionAsPattern(expr)}token=lex();right=isolateCoverGrammar(parseAssignmentExpression);expr=new WrappingNode(startToken).finishAssignmentExpression(token.value,expr,right);firstCoverInitializedNameError=null}return expr} // ECMA-262 12.15 Comma Operator
	function parseExpression(){var expr,startToken=lookahead,expressions;expr=isolateCoverGrammar(parseAssignmentExpression);if(match(',')){expressions=[expr];while(startIndex<length){if(!match(',')){break}lex();expressions.push(isolateCoverGrammar(parseAssignmentExpression))}expr=new WrappingNode(startToken).finishSequenceExpression(expressions)}return expr} // ECMA-262 13.2 Block
	function parseStatementListItem(){if(lookahead.type===Token.Keyword){switch(lookahead.value){case 'export':if(state.sourceType!=='module'){tolerateUnexpectedToken(lookahead,Messages.IllegalExportDeclaration)}return parseExportDeclaration();case 'import':if(state.sourceType!=='module'){tolerateUnexpectedToken(lookahead,Messages.IllegalImportDeclaration)}return parseImportDeclaration();case 'const':return parseLexicalDeclaration({inFor:false});case 'function':return parseFunctionDeclaration(new Node);case 'class':return parseClassDeclaration();}}if(matchKeyword('let')&&isLexicalDeclaration()){return parseLexicalDeclaration({inFor:false})}return parseStatement()}function parseStatementList(){var list=[];while(startIndex<length){if(match('}')){break}list.push(parseStatementListItem())}return list}function parseBlock(){var block,node=new Node;expect('{');block=parseStatementList();expect('}');return node.finishBlockStatement(block)} // ECMA-262 13.3.2 Variable Statement
	function parseVariableIdentifier(kind){var token,node=new Node;token=lex();if(token.type===Token.Keyword&&token.value==='yield'){if(strict){tolerateUnexpectedToken(token,Messages.StrictReservedWord)}if(!state.allowYield){throwUnexpectedToken(token)}}else if(token.type!==Token.Identifier){if(strict&&token.type===Token.Keyword&&isStrictModeReservedWord(token.value)){tolerateUnexpectedToken(token,Messages.StrictReservedWord)}else {if(strict||token.value!=='let'||kind!=='var'){throwUnexpectedToken(token)}}}else if(state.sourceType==='module'&&token.type===Token.Identifier&&token.value==='await'){tolerateUnexpectedToken(token)}return node.finishIdentifier(token.value)}function parseVariableDeclaration(options){var init=null,id,node=new Node,params=[];id=parsePattern(params,'var'); // ECMA-262 12.2.1
	if(strict&&isRestrictedWord(id.name)){tolerateError(Messages.StrictVarName)}if(match('=')){lex();init=isolateCoverGrammar(parseAssignmentExpression)}else if(id.type!==Syntax.Identifier&&!options.inFor){expect('=')}return node.finishVariableDeclarator(id,init)}function parseVariableDeclarationList(options){var list=[];do {list.push(parseVariableDeclaration({inFor:options.inFor}));if(!match(',')){break}lex()}while(startIndex<length);return list}function parseVariableStatement(node){var declarations;expectKeyword('var');declarations=parseVariableDeclarationList({inFor:false});consumeSemicolon();return node.finishVariableDeclaration(declarations)} // ECMA-262 13.3.1 Let and Const Declarations
	function parseLexicalBinding(kind,options){var init=null,id,node=new Node,params=[];id=parsePattern(params,kind); // ECMA-262 12.2.1
	if(strict&&id.type===Syntax.Identifier&&isRestrictedWord(id.name)){tolerateError(Messages.StrictVarName)}if(kind==='const'){if(!matchKeyword('in')&&!matchContextualKeyword('of')){expect('=');init=isolateCoverGrammar(parseAssignmentExpression)}}else if(!options.inFor&&id.type!==Syntax.Identifier||match('=')){expect('=');init=isolateCoverGrammar(parseAssignmentExpression)}return node.finishVariableDeclarator(id,init)}function parseBindingList(kind,options){var list=[];do {list.push(parseLexicalBinding(kind,options));if(!match(',')){break}lex()}while(startIndex<length);return list}function tokenizerState(){return {index:index,lineNumber:lineNumber,lineStart:lineStart,hasLineTerminator:hasLineTerminator,lastIndex:lastIndex,lastLineNumber:lastLineNumber,lastLineStart:lastLineStart,startIndex:startIndex,startLineNumber:startLineNumber,startLineStart:startLineStart,lookahead:lookahead,tokenCount:extra.tokens?extra.tokens.length:0}}function resetTokenizerState(ts){index=ts.index;lineNumber=ts.lineNumber;lineStart=ts.lineStart;hasLineTerminator=ts.hasLineTerminator;lastIndex=ts.lastIndex;lastLineNumber=ts.lastLineNumber;lastLineStart=ts.lastLineStart;startIndex=ts.startIndex;startLineNumber=ts.startLineNumber;startLineStart=ts.startLineStart;lookahead=ts.lookahead;if(extra.tokens){extra.tokens.splice(ts.tokenCount,extra.tokens.length)}}function isLexicalDeclaration(){var lexical,ts;ts=tokenizerState();lex();lexical=lookahead.type===Token.Identifier||match('[')||match('{')||matchKeyword('let')||matchKeyword('yield');resetTokenizerState(ts);return lexical}function parseLexicalDeclaration(options){var kind,declarations,node=new Node;kind=lex().value;assert(kind==='let'||kind==='const','Lexical declaration must be either let or const');declarations=parseBindingList(kind,options);consumeSemicolon();return node.finishLexicalDeclaration(declarations,kind)}function parseRestElement(params){var param,node=new Node;lex();if(match('{')){throwError(Messages.ObjectPatternAsRestParameter)}params.push(lookahead);param=parseVariableIdentifier();if(match('=')){throwError(Messages.DefaultRestParameter)}if(!match(')')){throwError(Messages.ParameterAfterRestParameter)}return node.finishRestElement(param)} // ECMA-262 13.4 Empty Statement
	function parseEmptyStatement(node){expect(';');return node.finishEmptyStatement()} // ECMA-262 12.4 Expression Statement
	function parseExpressionStatement(node){var expr=parseExpression();consumeSemicolon();return node.finishExpressionStatement(expr)} // ECMA-262 13.6 If statement
	function parseIfStatement(node){var test,consequent,alternate;expectKeyword('if');expect('(');test=parseExpression();expect(')');consequent=parseStatement();if(matchKeyword('else')){lex();alternate=parseStatement()}else {alternate=null}return node.finishIfStatement(test,consequent,alternate)} // ECMA-262 13.7 Iteration Statements
	function parseDoWhileStatement(node){var body,test,oldInIteration;expectKeyword('do');oldInIteration=state.inIteration;state.inIteration=true;body=parseStatement();state.inIteration=oldInIteration;expectKeyword('while');expect('(');test=parseExpression();expect(')');if(match(';')){lex()}return node.finishDoWhileStatement(body,test)}function parseWhileStatement(node){var test,body,oldInIteration;expectKeyword('while');expect('(');test=parseExpression();expect(')');oldInIteration=state.inIteration;state.inIteration=true;body=parseStatement();state.inIteration=oldInIteration;return node.finishWhileStatement(test,body)}function parseForStatement(node){var init,forIn,initSeq,initStartToken,test,update,left,right,kind,declarations,body,oldInIteration,previousAllowIn=state.allowIn;init=test=update=null;forIn=true;expectKeyword('for');expect('(');if(match(';')){lex()}else {if(matchKeyword('var')){init=new Node;lex();state.allowIn=false;declarations=parseVariableDeclarationList({inFor:true});state.allowIn=previousAllowIn;if(declarations.length===1&&matchKeyword('in')){init=init.finishVariableDeclaration(declarations);lex();left=init;right=parseExpression();init=null}else if(declarations.length===1&&declarations[0].init===null&&matchContextualKeyword('of')){init=init.finishVariableDeclaration(declarations);lex();left=init;right=parseAssignmentExpression();init=null;forIn=false}else {init=init.finishVariableDeclaration(declarations);expect(';')}}else if(matchKeyword('const')||matchKeyword('let')){init=new Node;kind=lex().value;if(!strict&&lookahead.value==='in'){init=init.finishIdentifier(kind);lex();left=init;right=parseExpression();init=null}else {state.allowIn=false;declarations=parseBindingList(kind,{inFor:true});state.allowIn=previousAllowIn;if(declarations.length===1&&declarations[0].init===null&&matchKeyword('in')){init=init.finishLexicalDeclaration(declarations,kind);lex();left=init;right=parseExpression();init=null}else if(declarations.length===1&&declarations[0].init===null&&matchContextualKeyword('of')){init=init.finishLexicalDeclaration(declarations,kind);lex();left=init;right=parseAssignmentExpression();init=null;forIn=false}else {consumeSemicolon();init=init.finishLexicalDeclaration(declarations,kind)}}}else {initStartToken=lookahead;state.allowIn=false;init=inheritCoverGrammar(parseAssignmentExpression);state.allowIn=previousAllowIn;if(matchKeyword('in')){if(!isAssignmentTarget){tolerateError(Messages.InvalidLHSInForIn)}lex();reinterpretExpressionAsPattern(init);left=init;right=parseExpression();init=null}else if(matchContextualKeyword('of')){if(!isAssignmentTarget){tolerateError(Messages.InvalidLHSInForLoop)}lex();reinterpretExpressionAsPattern(init);left=init;right=parseAssignmentExpression();init=null;forIn=false}else {if(match(',')){initSeq=[init];while(match(',')){lex();initSeq.push(isolateCoverGrammar(parseAssignmentExpression))}init=new WrappingNode(initStartToken).finishSequenceExpression(initSeq)}expect(';')}}}if(typeof left==='undefined'){if(!match(';')){test=parseExpression()}expect(';');if(!match(')')){update=parseExpression()}}expect(')');oldInIteration=state.inIteration;state.inIteration=true;body=isolateCoverGrammar(parseStatement);state.inIteration=oldInIteration;return typeof left==='undefined'?node.finishForStatement(init,test,update,body):forIn?node.finishForInStatement(left,right,body):node.finishForOfStatement(left,right,body)} // ECMA-262 13.8 The continue statement
	function parseContinueStatement(node){var label=null,key;expectKeyword('continue'); // Optimize the most common form: 'continue;'.
	if(source.charCodeAt(startIndex)===0x3B){lex();if(!state.inIteration){throwError(Messages.IllegalContinue)}return node.finishContinueStatement(null)}if(hasLineTerminator){if(!state.inIteration){throwError(Messages.IllegalContinue)}return node.finishContinueStatement(null)}if(lookahead.type===Token.Identifier){label=parseVariableIdentifier();key='$'+label.name;if(!Object.prototype.hasOwnProperty.call(state.labelSet,key)){throwError(Messages.UnknownLabel,label.name)}}consumeSemicolon();if(label===null&&!state.inIteration){throwError(Messages.IllegalContinue)}return node.finishContinueStatement(label)} // ECMA-262 13.9 The break statement
	function parseBreakStatement(node){var label=null,key;expectKeyword('break'); // Catch the very common case first: immediately a semicolon (U+003B).
	if(source.charCodeAt(lastIndex)===0x3B){lex();if(!(state.inIteration||state.inSwitch)){throwError(Messages.IllegalBreak)}return node.finishBreakStatement(null)}if(hasLineTerminator){if(!(state.inIteration||state.inSwitch)){throwError(Messages.IllegalBreak)}}else if(lookahead.type===Token.Identifier){label=parseVariableIdentifier();key='$'+label.name;if(!Object.prototype.hasOwnProperty.call(state.labelSet,key)){throwError(Messages.UnknownLabel,label.name)}}consumeSemicolon();if(label===null&&!(state.inIteration||state.inSwitch)){throwError(Messages.IllegalBreak)}return node.finishBreakStatement(label)} // ECMA-262 13.10 The return statement
	function parseReturnStatement(node){var argument=null;expectKeyword('return');if(!state.inFunctionBody){tolerateError(Messages.IllegalReturn)} // 'return' followed by a space and an identifier is very common.
	if(source.charCodeAt(lastIndex)===0x20){if(isIdentifierStart(source.charCodeAt(lastIndex+1))){argument=parseExpression();consumeSemicolon();return node.finishReturnStatement(argument)}}if(hasLineTerminator){ // HACK
	return node.finishReturnStatement(null)}if(!match(';')){if(!match('}')&&lookahead.type!==Token.EOF){argument=parseExpression()}}consumeSemicolon();return node.finishReturnStatement(argument)} // ECMA-262 13.11 The with statement
	function parseWithStatement(node){var object,body;if(strict){tolerateError(Messages.StrictModeWith)}expectKeyword('with');expect('(');object=parseExpression();expect(')');body=parseStatement();return node.finishWithStatement(object,body)} // ECMA-262 13.12 The switch statement
	function parseSwitchCase(){var test,consequent=[],statement,node=new Node;if(matchKeyword('default')){lex();test=null}else {expectKeyword('case');test=parseExpression()}expect(':');while(startIndex<length){if(match('}')||matchKeyword('default')||matchKeyword('case')){break}statement=parseStatementListItem();consequent.push(statement)}return node.finishSwitchCase(test,consequent)}function parseSwitchStatement(node){var discriminant,cases,clause,oldInSwitch,defaultFound;expectKeyword('switch');expect('(');discriminant=parseExpression();expect(')');expect('{');cases=[];if(match('}')){lex();return node.finishSwitchStatement(discriminant,cases)}oldInSwitch=state.inSwitch;state.inSwitch=true;defaultFound=false;while(startIndex<length){if(match('}')){break}clause=parseSwitchCase();if(clause.test===null){if(defaultFound){throwError(Messages.MultipleDefaultsInSwitch)}defaultFound=true}cases.push(clause)}state.inSwitch=oldInSwitch;expect('}');return node.finishSwitchStatement(discriminant,cases)} // ECMA-262 13.14 The throw statement
	function parseThrowStatement(node){var argument;expectKeyword('throw');if(hasLineTerminator){throwError(Messages.NewlineAfterThrow)}argument=parseExpression();consumeSemicolon();return node.finishThrowStatement(argument)} // ECMA-262 13.15 The try statement
	function parseCatchClause(){var param,params=[],paramMap={},key,i,body,node=new Node;expectKeyword('catch');expect('(');if(match(')')){throwUnexpectedToken(lookahead)}param=parsePattern(params);for(i=0;i<params.length;i++){key='$'+params[i].value;if(Object.prototype.hasOwnProperty.call(paramMap,key)){tolerateError(Messages.DuplicateBinding,params[i].value)}paramMap[key]=true} // ECMA-262 12.14.1
	if(strict&&isRestrictedWord(param.name)){tolerateError(Messages.StrictCatchVariable)}expect(')');body=parseBlock();return node.finishCatchClause(param,body)}function parseTryStatement(node){var block,handler=null,finalizer=null;expectKeyword('try');block=parseBlock();if(matchKeyword('catch')){handler=parseCatchClause()}if(matchKeyword('finally')){lex();finalizer=parseBlock()}if(!handler&&!finalizer){throwError(Messages.NoCatchOrFinally)}return node.finishTryStatement(block,handler,finalizer)} // ECMA-262 13.16 The debugger statement
	function parseDebuggerStatement(node){expectKeyword('debugger');consumeSemicolon();return node.finishDebuggerStatement()} // 13 Statements
	function parseStatement(){var type=lookahead.type,expr,labeledBody,key,node;if(type===Token.EOF){throwUnexpectedToken(lookahead)}if(type===Token.Punctuator&&lookahead.value==='{'){return parseBlock()}isAssignmentTarget=isBindingElement=true;node=new Node;if(type===Token.Punctuator){switch(lookahead.value){case ';':return parseEmptyStatement(node);case '(':return parseExpressionStatement(node);default:break;}}else if(type===Token.Keyword){switch(lookahead.value){case 'break':return parseBreakStatement(node);case 'continue':return parseContinueStatement(node);case 'debugger':return parseDebuggerStatement(node);case 'do':return parseDoWhileStatement(node);case 'for':return parseForStatement(node);case 'function':return parseFunctionDeclaration(node);case 'if':return parseIfStatement(node);case 'return':return parseReturnStatement(node);case 'switch':return parseSwitchStatement(node);case 'throw':return parseThrowStatement(node);case 'try':return parseTryStatement(node);case 'var':return parseVariableStatement(node);case 'while':return parseWhileStatement(node);case 'with':return parseWithStatement(node);default:break;}}expr=parseExpression(); // ECMA-262 12.12 Labelled Statements
	if(expr.type===Syntax.Identifier&&match(':')){lex();key='$'+expr.name;if(Object.prototype.hasOwnProperty.call(state.labelSet,key)){throwError(Messages.Redeclaration,'Label',expr.name)}state.labelSet[key]=true;labeledBody=parseStatement();delete state.labelSet[key];return node.finishLabeledStatement(expr,labeledBody)}consumeSemicolon();return node.finishExpressionStatement(expr)} // ECMA-262 14.1 Function Definition
	function parseFunctionSourceElements(){var statement,body=[],token,directive,firstRestricted,oldLabelSet,oldInIteration,oldInSwitch,oldInFunctionBody,oldParenthesisCount,node=new Node;expect('{');while(startIndex<length){if(lookahead.type!==Token.StringLiteral){break}token=lookahead;statement=parseStatementListItem();body.push(statement);if(statement.expression.type!==Syntax.Literal){ // this is not directive
	break}directive=source.slice(token.start+1,token.end-1);if(directive==='use strict'){strict=true;if(firstRestricted){tolerateUnexpectedToken(firstRestricted,Messages.StrictOctalLiteral)}}else {if(!firstRestricted&&token.octal){firstRestricted=token}}}oldLabelSet=state.labelSet;oldInIteration=state.inIteration;oldInSwitch=state.inSwitch;oldInFunctionBody=state.inFunctionBody;oldParenthesisCount=state.parenthesizedCount;state.labelSet={};state.inIteration=false;state.inSwitch=false;state.inFunctionBody=true;state.parenthesizedCount=0;while(startIndex<length){if(match('}')){break}body.push(parseStatementListItem())}expect('}');state.labelSet=oldLabelSet;state.inIteration=oldInIteration;state.inSwitch=oldInSwitch;state.inFunctionBody=oldInFunctionBody;state.parenthesizedCount=oldParenthesisCount;return node.finishBlockStatement(body)}function validateParam(options,param,name){var key='$'+name;if(strict){if(isRestrictedWord(name)){options.stricted=param;options.message=Messages.StrictParamName}if(Object.prototype.hasOwnProperty.call(options.paramSet,key)){options.stricted=param;options.message=Messages.StrictParamDupe}}else if(!options.firstRestricted){if(isRestrictedWord(name)){options.firstRestricted=param;options.message=Messages.StrictParamName}else if(isStrictModeReservedWord(name)){options.firstRestricted=param;options.message=Messages.StrictReservedWord}else if(Object.prototype.hasOwnProperty.call(options.paramSet,key)){options.stricted=param;options.message=Messages.StrictParamDupe}}options.paramSet[key]=true}function parseParam(options){var token,param,params=[],i,def;token=lookahead;if(token.value==='...'){param=parseRestElement(params);validateParam(options,param.argument,param.argument.name);options.params.push(param);options.defaults.push(null);return false}param=parsePatternWithDefault(params);for(i=0;i<params.length;i++){validateParam(options,params[i],params[i].value)}if(param.type===Syntax.AssignmentPattern){def=param.right;param=param.left;++options.defaultCount}options.params.push(param);options.defaults.push(def);return !match(')')}function parseParams(firstRestricted){var options;options={params:[],defaultCount:0,defaults:[],firstRestricted:firstRestricted};expect('(');if(!match(')')){options.paramSet={};while(startIndex<length){if(!parseParam(options)){break}expect(',')}}expect(')');if(options.defaultCount===0){options.defaults=[]}return {params:options.params,defaults:options.defaults,stricted:options.stricted,firstRestricted:options.firstRestricted,message:options.message}}function parseFunctionDeclaration(node,identifierIsOptional){var id=null,params=[],defaults=[],body,token,stricted,tmp,firstRestricted,message,previousStrict,isGenerator,previousAllowYield;previousAllowYield=state.allowYield;expectKeyword('function');isGenerator=match('*');if(isGenerator){lex()}if(!identifierIsOptional||!match('(')){token=lookahead;id=parseVariableIdentifier();if(strict){if(isRestrictedWord(token.value)){tolerateUnexpectedToken(token,Messages.StrictFunctionName)}}else {if(isRestrictedWord(token.value)){firstRestricted=token;message=Messages.StrictFunctionName}else if(isStrictModeReservedWord(token.value)){firstRestricted=token;message=Messages.StrictReservedWord}}}state.allowYield=!isGenerator;tmp=parseParams(firstRestricted);params=tmp.params;defaults=tmp.defaults;stricted=tmp.stricted;firstRestricted=tmp.firstRestricted;if(tmp.message){message=tmp.message}previousStrict=strict;body=parseFunctionSourceElements();if(strict&&firstRestricted){throwUnexpectedToken(firstRestricted,message)}if(strict&&stricted){tolerateUnexpectedToken(stricted,message)}strict=previousStrict;state.allowYield=previousAllowYield;return node.finishFunctionDeclaration(id,params,defaults,body,isGenerator)}function parseFunctionExpression(){var token,id=null,stricted,firstRestricted,message,tmp,params=[],defaults=[],body,previousStrict,node=new Node,isGenerator,previousAllowYield;previousAllowYield=state.allowYield;expectKeyword('function');isGenerator=match('*');if(isGenerator){lex()}state.allowYield=!isGenerator;if(!match('(')){token=lookahead;id=!strict&&!isGenerator&&matchKeyword('yield')?parseNonComputedProperty():parseVariableIdentifier();if(strict){if(isRestrictedWord(token.value)){tolerateUnexpectedToken(token,Messages.StrictFunctionName)}}else {if(isRestrictedWord(token.value)){firstRestricted=token;message=Messages.StrictFunctionName}else if(isStrictModeReservedWord(token.value)){firstRestricted=token;message=Messages.StrictReservedWord}}}tmp=parseParams(firstRestricted);params=tmp.params;defaults=tmp.defaults;stricted=tmp.stricted;firstRestricted=tmp.firstRestricted;if(tmp.message){message=tmp.message}previousStrict=strict;body=parseFunctionSourceElements();if(strict&&firstRestricted){throwUnexpectedToken(firstRestricted,message)}if(strict&&stricted){tolerateUnexpectedToken(stricted,message)}strict=previousStrict;state.allowYield=previousAllowYield;return node.finishFunctionExpression(id,params,defaults,body,isGenerator)} // ECMA-262 14.5 Class Definitions
	function parseClassBody(){var classBody,token,isStatic,hasConstructor=false,body,method,computed,key;classBody=new Node;expect('{');body=[];while(!match('}')){if(match(';')){lex()}else {method=new Node;token=lookahead;isStatic=false;computed=match('[');if(match('*')){lex()}else {key=parseObjectPropertyKey();if(key.name==='static'&&(lookaheadPropertyName()||match('*'))){token=lookahead;isStatic=true;computed=match('[');if(match('*')){lex()}else {key=parseObjectPropertyKey()}}}method=tryParseMethodDefinition(token,key,computed,method);if(method){method['static']=isStatic; // jscs:ignore requireDotNotation
	if(method.kind==='init'){method.kind='method'}if(!isStatic){if(!method.computed&&(method.key.name||method.key.value.toString())==='constructor'){if(method.kind!=='method'||!method.method||method.value.generator){throwUnexpectedToken(token,Messages.ConstructorSpecialMethod)}if(hasConstructor){throwUnexpectedToken(token,Messages.DuplicateConstructor)}else {hasConstructor=true}method.kind='constructor'}}else {if(!method.computed&&(method.key.name||method.key.value.toString())==='prototype'){throwUnexpectedToken(token,Messages.StaticPrototype)}}method.type=Syntax.MethodDefinition;delete method.method;delete method.shorthand;body.push(method)}else {throwUnexpectedToken(lookahead)}}}lex();return classBody.finishClassBody(body)}function parseClassDeclaration(identifierIsOptional){var id=null,superClass=null,classNode=new Node,classBody,previousStrict=strict;strict=true;expectKeyword('class');if(!identifierIsOptional||lookahead.type===Token.Identifier){id=parseVariableIdentifier()}if(matchKeyword('extends')){lex();superClass=isolateCoverGrammar(parseLeftHandSideExpressionAllowCall)}classBody=parseClassBody();strict=previousStrict;return classNode.finishClassDeclaration(id,superClass,classBody)}function parseClassExpression(){var id=null,superClass=null,classNode=new Node,classBody,previousStrict=strict;strict=true;expectKeyword('class');if(lookahead.type===Token.Identifier){id=parseVariableIdentifier()}if(matchKeyword('extends')){lex();superClass=isolateCoverGrammar(parseLeftHandSideExpressionAllowCall)}classBody=parseClassBody();strict=previousStrict;return classNode.finishClassExpression(id,superClass,classBody)} // ECMA-262 15.2 Modules
	function parseModuleSpecifier(){var node=new Node;if(lookahead.type!==Token.StringLiteral){throwError(Messages.InvalidModuleSpecifier)}return node.finishLiteral(lex())} // ECMA-262 15.2.3 Exports
	function parseExportSpecifier(){var exported,local,node=new Node,def;if(matchKeyword('default')){ // export {default} from 'something';
	def=new Node;lex();local=def.finishIdentifier('default')}else {local=parseVariableIdentifier()}if(matchContextualKeyword('as')){lex();exported=parseNonComputedProperty()}return node.finishExportSpecifier(local,exported)}function parseExportNamedDeclaration(node){var declaration=null,isExportFromIdentifier,src=null,specifiers=[]; // non-default export
	if(lookahead.type===Token.Keyword){ // covers:
	// export var f = 1;
	switch(lookahead.value){case 'let':case 'const':declaration=parseLexicalDeclaration({inFor:false});return node.finishExportNamedDeclaration(declaration,specifiers,null);case 'var':case 'class':case 'function':declaration=parseStatementListItem();return node.finishExportNamedDeclaration(declaration,specifiers,null);}}expect('{');while(!match('}')){isExportFromIdentifier=isExportFromIdentifier||matchKeyword('default');specifiers.push(parseExportSpecifier());if(!match('}')){expect(',');if(match('}')){break}}}expect('}');if(matchContextualKeyword('from')){ // covering:
	// export {default} from 'foo';
	// export {foo} from 'foo';
	lex();src=parseModuleSpecifier();consumeSemicolon()}else if(isExportFromIdentifier){ // covering:
	// export {default}; // missing fromClause
	throwError(lookahead.value?Messages.UnexpectedToken:Messages.MissingFromClause,lookahead.value)}else { // cover
	// export {foo};
	consumeSemicolon()}return node.finishExportNamedDeclaration(declaration,specifiers,src)}function parseExportDefaultDeclaration(node){var declaration=null,expression=null; // covers:
	// export default ...
	expectKeyword('default');if(matchKeyword('function')){ // covers:
	// export default function foo () {}
	// export default function () {}
	declaration=parseFunctionDeclaration(new Node,true);return node.finishExportDefaultDeclaration(declaration)}if(matchKeyword('class')){declaration=parseClassDeclaration(true);return node.finishExportDefaultDeclaration(declaration)}if(matchContextualKeyword('from')){throwError(Messages.UnexpectedToken,lookahead.value)} // covers:
	// export default {};
	// export default [];
	// export default (1 + 2);
	if(match('{')){expression=parseObjectInitializer()}else if(match('[')){expression=parseArrayInitializer()}else {expression=parseAssignmentExpression()}consumeSemicolon();return node.finishExportDefaultDeclaration(expression)}function parseExportAllDeclaration(node){var src; // covers:
	// export * from 'foo';
	expect('*');if(!matchContextualKeyword('from')){throwError(lookahead.value?Messages.UnexpectedToken:Messages.MissingFromClause,lookahead.value)}lex();src=parseModuleSpecifier();consumeSemicolon();return node.finishExportAllDeclaration(src)}function parseExportDeclaration(){var node=new Node;if(state.inFunctionBody){throwError(Messages.IllegalExportDeclaration)}expectKeyword('export');if(matchKeyword('default')){return parseExportDefaultDeclaration(node)}if(match('*')){return parseExportAllDeclaration(node)}return parseExportNamedDeclaration(node)} // ECMA-262 15.2.2 Imports
	function parseImportSpecifier(){ // import {<foo as bar>} ...;
	var local,imported,node=new Node;imported=parseNonComputedProperty();if(matchContextualKeyword('as')){lex();local=parseVariableIdentifier()}return node.finishImportSpecifier(local,imported)}function parseNamedImports(){var specifiers=[]; // {foo, bar as bas}
	expect('{');while(!match('}')){specifiers.push(parseImportSpecifier());if(!match('}')){expect(',');if(match('}')){break}}}expect('}');return specifiers}function parseImportDefaultSpecifier(){ // import <foo> ...;
	var local,node=new Node;local=parseNonComputedProperty();return node.finishImportDefaultSpecifier(local)}function parseImportNamespaceSpecifier(){ // import <* as foo> ...;
	var local,node=new Node;expect('*');if(!matchContextualKeyword('as')){throwError(Messages.NoAsAfterImportNamespace)}lex();local=parseNonComputedProperty();return node.finishImportNamespaceSpecifier(local)}function parseImportDeclaration(){var specifiers=[],src,node=new Node;if(state.inFunctionBody){throwError(Messages.IllegalImportDeclaration)}expectKeyword('import');if(lookahead.type===Token.StringLiteral){ // import 'foo';
	src=parseModuleSpecifier()}else {if(match('{')){ // import {bar}
	specifiers=specifiers.concat(parseNamedImports())}else if(match('*')){ // import * as foo
	specifiers.push(parseImportNamespaceSpecifier())}else if(isIdentifierName(lookahead)&&!matchKeyword('default')){ // import foo
	specifiers.push(parseImportDefaultSpecifier());if(match(',')){lex();if(match('*')){ // import foo, * as foo
	specifiers.push(parseImportNamespaceSpecifier())}else if(match('{')){ // import foo, {bar}
	specifiers=specifiers.concat(parseNamedImports())}else {throwUnexpectedToken(lookahead)}}}else {throwUnexpectedToken(lex())}if(!matchContextualKeyword('from')){throwError(lookahead.value?Messages.UnexpectedToken:Messages.MissingFromClause,lookahead.value)}lex();src=parseModuleSpecifier()}consumeSemicolon();return node.finishImportDeclaration(specifiers,src)} // ECMA-262 15.1 Scripts
	function parseScriptBody(){var statement,body=[],token,directive,firstRestricted;while(startIndex<length){token=lookahead;if(token.type!==Token.StringLiteral){break}statement=parseStatementListItem();body.push(statement);if(statement.expression.type!==Syntax.Literal){ // this is not directive
	break}directive=source.slice(token.start+1,token.end-1);if(directive==='use strict'){strict=true;if(firstRestricted){tolerateUnexpectedToken(firstRestricted,Messages.StrictOctalLiteral)}}else {if(!firstRestricted&&token.octal){firstRestricted=token}}}while(startIndex<length){statement=parseStatementListItem(); /* istanbul ignore if */if(typeof statement==='undefined'){break}body.push(statement)}return body}function parseProgram(){var body,node;peek();node=new Node;body=parseScriptBody();return node.finishProgram(body,state.sourceType)}function filterTokenLocation(){var i,entry,token,tokens=[];for(i=0;i<extra.tokens.length;++i){entry=extra.tokens[i];token={type:entry.type,value:entry.value};if(entry.regex){token.regex={pattern:entry.regex.pattern,flags:entry.regex.flags}}if(extra.range){token.range=entry.range}if(extra.loc){token.loc=entry.loc}tokens.push(token)}extra.tokens=tokens}function tokenize(code,options,delegate){var toString,tokens;toString=String;if(typeof code!=='string'&&!(code instanceof String)){code=toString(code)}source=code;index=0;lineNumber=source.length>0?1:0;lineStart=0;startIndex=index;startLineNumber=lineNumber;startLineStart=lineStart;length=source.length;lookahead=null;state={allowIn:true,allowYield:true,labelSet:{},inFunctionBody:false,inIteration:false,inSwitch:false,lastCommentStart:-1,curlyStack:[]};extra={}; // Options matching.
	options=options||{}; // Of course we collect tokens here.
	options.tokens=true;extra.tokens=[];extra.tokenValues=[];extra.tokenize=true;extra.delegate=delegate; // The following two fields are necessary to compute the Regex tokens.
	extra.openParenToken=-1;extra.openCurlyToken=-1;extra.range=typeof options.range==='boolean'&&options.range;extra.loc=typeof options.loc==='boolean'&&options.loc;if(typeof options.comment==='boolean'&&options.comment){extra.comments=[]}if(typeof options.tolerant==='boolean'&&options.tolerant){extra.errors=[]}try{peek();if(lookahead.type===Token.EOF){return extra.tokens}lex();while(lookahead.type!==Token.EOF){try{lex()}catch(lexError) {if(extra.errors){recordError(lexError); // We have to break on the first error
	// to avoid infinite loops.
	break}else {throw lexError}}}tokens=extra.tokens;if(typeof extra.errors!=='undefined'){tokens.errors=extra.errors}}catch(e) {throw e}finally {extra={}}return tokens}function parse(code,options){var program,toString;toString=String;if(typeof code!=='string'&&!(code instanceof String)){code=toString(code)}source=code;index=0;lineNumber=source.length>0?1:0;lineStart=0;startIndex=index;startLineNumber=lineNumber;startLineStart=lineStart;length=source.length;lookahead=null;state={allowIn:true,allowYield:true,labelSet:{},inFunctionBody:false,inIteration:false,inSwitch:false,lastCommentStart:-1,curlyStack:[],sourceType:'script'};strict=false;extra={};if(typeof options!=='undefined'){extra.range=typeof options.range==='boolean'&&options.range;extra.loc=typeof options.loc==='boolean'&&options.loc;extra.attachComment=typeof options.attachComment==='boolean'&&options.attachComment;if(extra.loc&&options.source!==null&&options.source!==undefined){extra.source=toString(options.source)}if(typeof options.tokens==='boolean'&&options.tokens){extra.tokens=[]}if(typeof options.comment==='boolean'&&options.comment){extra.comments=[]}if(typeof options.tolerant==='boolean'&&options.tolerant){extra.errors=[]}if(extra.attachComment){extra.range=true;extra.comments=[];extra.bottomRightStack=[];extra.trailingComments=[];extra.leadingComments=[]}if(options.sourceType==='module'){ // very restrictive condition for now
	state.sourceType=options.sourceType;strict=true}}try{program=parseProgram();if(typeof extra.comments!=='undefined'){program.comments=extra.comments}if(typeof extra.tokens!=='undefined'){filterTokenLocation();program.tokens=extra.tokens}if(typeof extra.errors!=='undefined'){program.errors=extra.errors}}catch(e) {throw e}finally {extra={}}return program} // Sync with *.json manifests.
	exports.version='2.7.0';exports.tokenize=tokenize;exports.parse=parse; // Deep copy.
	/* istanbul ignore next */exports.Syntax=(function(){var name,types={};if(typeof Object.create==='function'){types=Object.create(null)}for(name in Syntax){if(Syntax.hasOwnProperty(name)){types[name]=Syntax[name]}}if(typeof Object.freeze==='function'){Object.freeze(types)}return types})()}); /* vim: set sw=4 ts=4 et tw=80 : */

/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'

	/*eslint-disable no-use-before-define*/

	;
	var common = __webpack_require__(20);
	var YAMLException = __webpack_require__(21);
	var DEFAULT_FULL_SCHEMA = __webpack_require__(45);
	var DEFAULT_SAFE_SCHEMA = __webpack_require__(25);

	var _toString = Object.prototype.toString;
	var _hasOwnProperty = Object.prototype.hasOwnProperty;

	var CHAR_TAB = 0x09; /* Tab */
	var CHAR_LINE_FEED = 0x0A; /* LF */
	var CHAR_CARRIAGE_RETURN = 0x0D; /* CR */
	var CHAR_SPACE = 0x20; /* Space */
	var CHAR_EXCLAMATION = 0x21; /* ! */
	var CHAR_DOUBLE_QUOTE = 0x22; /* " */
	var CHAR_SHARP = 0x23; /* # */
	var CHAR_PERCENT = 0x25; /* % */
	var CHAR_AMPERSAND = 0x26; /* & */
	var CHAR_SINGLE_QUOTE = 0x27; /* ' */
	var CHAR_ASTERISK = 0x2A; /* * */
	var CHAR_COMMA = 0x2C; /* , */
	var CHAR_MINUS = 0x2D; /* - */
	var CHAR_COLON = 0x3A; /* : */
	var CHAR_GREATER_THAN = 0x3E; /* > */
	var CHAR_QUESTION = 0x3F; /* ? */
	var CHAR_COMMERCIAL_AT = 0x40; /* @ */
	var CHAR_LEFT_SQUARE_BRACKET = 0x5B; /* [ */
	var CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */
	var CHAR_GRAVE_ACCENT = 0x60; /* ` */
	var CHAR_LEFT_CURLY_BRACKET = 0x7B; /* { */
	var CHAR_VERTICAL_LINE = 0x7C; /* | */
	var CHAR_RIGHT_CURLY_BRACKET = 0x7D; /* } */

	var ESCAPE_SEQUENCES = {};

	ESCAPE_SEQUENCES[0x00] = '\\0';
	ESCAPE_SEQUENCES[0x07] = '\\a';
	ESCAPE_SEQUENCES[0x08] = '\\b';
	ESCAPE_SEQUENCES[0x09] = '\\t';
	ESCAPE_SEQUENCES[0x0A] = '\\n';
	ESCAPE_SEQUENCES[0x0B] = '\\v';
	ESCAPE_SEQUENCES[0x0C] = '\\f';
	ESCAPE_SEQUENCES[0x0D] = '\\r';
	ESCAPE_SEQUENCES[0x1B] = '\\e';
	ESCAPE_SEQUENCES[0x22] = '\\"';
	ESCAPE_SEQUENCES[0x5C] = '\\\\';
	ESCAPE_SEQUENCES[0x85] = '\\N';
	ESCAPE_SEQUENCES[0xA0] = '\\_';
	ESCAPE_SEQUENCES[0x2028] = '\\L';
	ESCAPE_SEQUENCES[0x2029] = '\\P';

	var DEPRECATED_BOOLEANS_SYNTAX = ['y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON', 'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'];

	function compileStyleMap(schema, map) {
	  var result, keys, index, length, tag, style, type;

	  if (null === map) {
	    return {};
	  }

	  result = {};
	  keys = Object.keys(map);

	  for (index = 0, length = keys.length; index < length; index += 1) {
	    tag = keys[index];
	    style = String(map[tag]);

	    if ('!!' === tag.slice(0, 2)) {
	      tag = 'tag:yaml.org,2002:' + tag.slice(2);
	    }

	    type = schema.compiledTypeMap[tag];

	    if (type && _hasOwnProperty.call(type.styleAliases, style)) {
	      style = type.styleAliases[style];
	    }

	    result[tag] = style;
	  }

	  return result;
	}

	function encodeHex(character) {
	  var string, handle, length;

	  string = character.toString(16).toUpperCase();

	  if (character <= 0xFF) {
	    handle = 'x';
	    length = 2;
	  } else if (character <= 0xFFFF) {
	    handle = 'u';
	    length = 4;
	  } else if (character <= 0xFFFFFFFF) {
	    handle = 'U';
	    length = 8;
	  } else {
	    throw new YAMLException('code point within a string may not be greater than 0xFFFFFFFF');
	  }

	  return '\\' + handle + common.repeat('0', length - string.length) + string;
	}

	function State(options) {
	  this.schema = options['schema'] || DEFAULT_FULL_SCHEMA;
	  this.indent = Math.max(1, options['indent'] || 2);
	  this.skipInvalid = options['skipInvalid'] || false;
	  this.flowLevel = common.isNothing(options['flowLevel']) ? -1 : options['flowLevel'];
	  this.styleMap = compileStyleMap(this.schema, options['styles'] || null);
	  this.sortKeys = options['sortKeys'] || false;
	  this.lineWidth = options['lineWidth'] || 80;

	  this.implicitTypes = this.schema.compiledImplicit;
	  this.explicitTypes = this.schema.compiledExplicit;

	  this.tag = null;
	  this.result = '';

	  this.duplicates = [];
	  this.usedDuplicates = null;
	}

	function indentString(string, spaces) {
	  var ind = common.repeat(' ', spaces),
	      position = 0,
	      next = -1,
	      result = '',
	      line,
	      length = string.length;

	  while (position < length) {
	    next = string.indexOf('\n', position);
	    if (next === -1) {
	      line = string.slice(position);
	      position = length;
	    } else {
	      line = string.slice(position, next + 1);
	      position = next + 1;
	    }
	    if (line.length && line !== '\n') {
	      result += ind;
	    }
	    result += line;
	  }

	  return result;
	}

	function generateNextLine(state, level) {
	  return '\n' + common.repeat(' ', state.indent * level);
	}

	function testImplicitResolving(state, str) {
	  var index, length, type;

	  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
	    type = state.implicitTypes[index];

	    if (type.resolve(str)) {
	      return true;
	    }
	  }

	  return false;
	}

	function StringBuilder(source) {
	  this.source = source;
	  this.result = '';
	  this.checkpoint = 0;
	}

	StringBuilder.prototype.takeUpTo = function (position) {
	  var er;

	  if (position < this.checkpoint) {
	    er = new Error('position should be > checkpoint');
	    er.position = position;
	    er.checkpoint = this.checkpoint;
	    throw er;
	  }

	  this.result += this.source.slice(this.checkpoint, position);
	  this.checkpoint = position;
	  return this;
	};

	StringBuilder.prototype.escapeChar = function () {
	  var character, esc;

	  character = this.source.charCodeAt(this.checkpoint);
	  esc = ESCAPE_SEQUENCES[character] || encodeHex(character);
	  this.result += esc;
	  this.checkpoint += 1;

	  return this;
	};

	StringBuilder.prototype.finish = function () {
	  if (this.source.length > this.checkpoint) {
	    this.takeUpTo(this.source.length);
	  }
	};

	function writeScalar(state, object, level, iskey) {
	  var simple, first, spaceWrap, folded, literal, single, double, sawLineFeed, linePosition, longestLine, indent, max, character, position, escapeSeq, hexEsc, previous, lineLength, modifier, trailingLineBreaks, result;

	  if (0 === object.length) {
	    state.dump = "''";
	    return;
	  }

	  if (-1 !== DEPRECATED_BOOLEANS_SYNTAX.indexOf(object)) {
	    state.dump = "'" + object + "'";
	    return;
	  }

	  simple = true;
	  first = object.length ? object.charCodeAt(0) : 0;
	  spaceWrap = CHAR_SPACE === first || CHAR_SPACE === object.charCodeAt(object.length - 1);

	  // Simplified check for restricted first characters
	  // http://www.yaml.org/spec/1.2/spec.html#ns-plain-first%28c%29
	  if (CHAR_MINUS === first || CHAR_QUESTION === first || CHAR_COMMERCIAL_AT === first || CHAR_GRAVE_ACCENT === first) {
	    simple = false;
	  }

	  // can only use > and | if not wrapped in spaces or is not a key.
	  if (spaceWrap) {
	    simple = false;
	    folded = false;
	    literal = false;
	  } else {
	    folded = !iskey;
	    literal = !iskey;
	  }

	  single = true;
	  double = new StringBuilder(object);

	  sawLineFeed = false;
	  linePosition = 0;
	  longestLine = 0;

	  indent = state.indent * level;
	  max = state.lineWidth;
	  if (max === -1) {
	    // Replace -1 with biggest ingeger number according to
	    // http://ecma262-5.com/ELS5_HTML.htm#Section_8.5
	    max = 9007199254740991;
	  }

	  if (indent < 40) {
	    max -= indent;
	  } else {
	    max = 40;
	  }

	  for (position = 0; position < object.length; position++) {
	    character = object.charCodeAt(position);
	    if (simple) {
	      // Characters that can never appear in the simple scalar
	      if (!simpleChar(character)) {
	        simple = false;
	      } else {
	        // Still simple.  If we make it all the way through like
	        // this, then we can just dump the string as-is.
	        continue;
	      }
	    }

	    if (single && character === CHAR_SINGLE_QUOTE) {
	      single = false;
	    }

	    escapeSeq = ESCAPE_SEQUENCES[character];
	    hexEsc = needsHexEscape(character);

	    if (!escapeSeq && !hexEsc) {
	      continue;
	    }

	    if (character !== CHAR_LINE_FEED && character !== CHAR_DOUBLE_QUOTE && character !== CHAR_SINGLE_QUOTE) {
	      folded = false;
	      literal = false;
	    } else if (character === CHAR_LINE_FEED) {
	      sawLineFeed = true;
	      single = false;
	      if (position > 0) {
	        previous = object.charCodeAt(position - 1);
	        if (previous === CHAR_SPACE) {
	          literal = false;
	          folded = false;
	        }
	      }
	      if (folded) {
	        lineLength = position - linePosition;
	        linePosition = position;
	        if (lineLength > longestLine) {
	          longestLine = lineLength;
	        }
	      }
	    }

	    if (character !== CHAR_DOUBLE_QUOTE) {
	      single = false;
	    }

	    double.takeUpTo(position);
	    double.escapeChar();
	  }

	  if (simple && testImplicitResolving(state, object)) {
	    simple = false;
	  }

	  modifier = '';
	  if (folded || literal) {
	    trailingLineBreaks = 0;
	    if (object.charCodeAt(object.length - 1) === CHAR_LINE_FEED) {
	      trailingLineBreaks += 1;
	      if (object.charCodeAt(object.length - 2) === CHAR_LINE_FEED) {
	        trailingLineBreaks += 1;
	      }
	    }

	    if (trailingLineBreaks === 0) {
	      modifier = '-';
	    } else if (trailingLineBreaks === 2) {
	      modifier = '+';
	    }
	  }

	  if (literal && longestLine < max) {
	    folded = false;
	  }

	  // If it's literally one line, then don't bother with the literal.
	  // We may still want to do a fold, though, if it's a super long line.
	  if (!sawLineFeed) {
	    literal = false;
	  }

	  if (simple) {
	    state.dump = object;
	  } else if (single) {
	    state.dump = '\'' + object + '\'';
	  } else if (folded) {
	    result = fold(object, max);
	    state.dump = '>' + modifier + '\n' + indentString(result, indent);
	  } else if (literal) {
	    if (!modifier) {
	      object = object.replace(/\n$/, '');
	    }
	    state.dump = '|' + modifier + '\n' + indentString(object, indent);
	  } else if (double) {
	    double.finish();
	    state.dump = '"' + double.result + '"';
	  } else {
	    throw new Error('Failed to dump scalar value');
	  }

	  return;
	}

	// The `trailing` var is a regexp match of any trailing `\n` characters.
	//
	// There are three cases we care about:
	//
	// 1. One trailing `\n` on the string.  Just use `|` or `>`.
	//    This is the assumed default. (trailing = null)
	// 2. No trailing `\n` on the string.  Use `|-` or `>-` to "chomp" the end.
	// 3. More than one trailing `\n` on the string.  Use `|+` or `>+`.
	//
	// In the case of `>+`, these line breaks are *not* doubled (like the line
	// breaks within the string), so it's important to only end with the exact
	// same number as we started.
	function fold(object, max) {
	  var result = '',
	      position = 0,
	      length = object.length,
	      trailing = /\n+$/.exec(object),
	      newLine;

	  if (trailing) {
	    length = trailing.index + 1;
	  }

	  while (position < length) {
	    newLine = object.indexOf('\n', position);
	    if (newLine > length || newLine === -1) {
	      if (result) {
	        result += '\n\n';
	      }
	      result += foldLine(object.slice(position, length), max);
	      position = length;
	    } else {
	      if (result) {
	        result += '\n\n';
	      }
	      result += foldLine(object.slice(position, newLine), max);
	      position = newLine + 1;
	    }
	  }
	  if (trailing && trailing[0] !== '\n') {
	    result += trailing[0];
	  }

	  return result;
	}

	function foldLine(line, max) {
	  if (line === '') {
	    return line;
	  }

	  var foldRe = /[^\s] [^\s]/g,
	      result = '',
	      prevMatch = 0,
	      foldStart = 0,
	      match = foldRe.exec(line),
	      index,
	      foldEnd,
	      folded;

	  while (match) {
	    index = match.index;

	    // when we cross the max len, if the previous match would've
	    // been ok, use that one, and carry on.  If there was no previous
	    // match on this fold section, then just have a long line.
	    if (index - foldStart > max) {
	      if (prevMatch !== foldStart) {
	        foldEnd = prevMatch;
	      } else {
	        foldEnd = index;
	      }

	      if (result) {
	        result += '\n';
	      }
	      folded = line.slice(foldStart, foldEnd);
	      result += folded;
	      foldStart = foldEnd + 1;
	    }
	    prevMatch = index + 1;
	    match = foldRe.exec(line);
	  }

	  if (result) {
	    result += '\n';
	  }

	  // if we end up with one last word at the end, then the last bit might
	  // be slightly bigger than we wanted, because we exited out of the loop.
	  if (foldStart !== prevMatch && line.length - foldStart > max) {
	    result += line.slice(foldStart, prevMatch) + '\n' + line.slice(prevMatch + 1);
	  } else {
	    result += line.slice(foldStart);
	  }

	  return result;
	}

	// Returns true if character can be found in a simple scalar
	function simpleChar(character) {
	  return CHAR_TAB !== character && CHAR_LINE_FEED !== character && CHAR_CARRIAGE_RETURN !== character && CHAR_COMMA !== character && CHAR_LEFT_SQUARE_BRACKET !== character && CHAR_RIGHT_SQUARE_BRACKET !== character && CHAR_LEFT_CURLY_BRACKET !== character && CHAR_RIGHT_CURLY_BRACKET !== character && CHAR_SHARP !== character && CHAR_AMPERSAND !== character && CHAR_ASTERISK !== character && CHAR_EXCLAMATION !== character && CHAR_VERTICAL_LINE !== character && CHAR_GREATER_THAN !== character && CHAR_SINGLE_QUOTE !== character && CHAR_DOUBLE_QUOTE !== character && CHAR_PERCENT !== character && CHAR_COLON !== character && !ESCAPE_SEQUENCES[character] && !needsHexEscape(character);
	}

	// Returns true if the character code needs to be escaped.
	function needsHexEscape(character) {
	  return !(0x00020 <= character && character <= 0x00007E || 0x00085 === character || 0x000A0 <= character && character <= 0x00D7FF || 0x0E000 <= character && character <= 0x00FFFD || 0x10000 <= character && character <= 0x10FFFF);
	}

	function writeFlowSequence(state, level, object) {
	  var _result = '',
	      _tag = state.tag,
	      index,
	      length;

	  for (index = 0, length = object.length; index < length; index += 1) {
	    // Write only valid elements.
	    if (writeNode(state, level, object[index], false, false)) {
	      if (0 !== index) {
	        _result += ', ';
	      }
	      _result += state.dump;
	    }
	  }

	  state.tag = _tag;
	  state.dump = '[' + _result + ']';
	}

	function writeBlockSequence(state, level, object, compact) {
	  var _result = '',
	      _tag = state.tag,
	      index,
	      length;

	  for (index = 0, length = object.length; index < length; index += 1) {
	    // Write only valid elements.
	    if (writeNode(state, level + 1, object[index], true, true)) {
	      if (!compact || 0 !== index) {
	        _result += generateNextLine(state, level);
	      }
	      _result += '- ' + state.dump;
	    }
	  }

	  state.tag = _tag;
	  state.dump = _result || '[]'; // Empty sequence if no valid values.
	}

	function writeFlowMapping(state, level, object) {
	  var _result = '',
	      _tag = state.tag,
	      objectKeyList = Object.keys(object),
	      index,
	      length,
	      objectKey,
	      objectValue,
	      pairBuffer;

	  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
	    pairBuffer = '';

	    if (0 !== index) {
	      pairBuffer += ', ';
	    }

	    objectKey = objectKeyList[index];
	    objectValue = object[objectKey];

	    if (!writeNode(state, level, objectKey, false, false)) {
	      continue; // Skip this pair because of invalid key;
	    }

	    if (state.dump.length > 1024) {
	      pairBuffer += '? ';
	    }

	    pairBuffer += state.dump + ': ';

	    if (!writeNode(state, level, objectValue, false, false)) {
	      continue; // Skip this pair because of invalid value.
	    }

	    pairBuffer += state.dump;

	    // Both key and value are valid.
	    _result += pairBuffer;
	  }

	  state.tag = _tag;
	  state.dump = '{' + _result + '}';
	}

	function writeBlockMapping(state, level, object, compact) {
	  var _result = '',
	      _tag = state.tag,
	      objectKeyList = Object.keys(object),
	      index,
	      length,
	      objectKey,
	      objectValue,
	      explicitPair,
	      pairBuffer;

	  // Allow sorting keys so that the output file is deterministic
	  if (state.sortKeys === true) {
	    // Default sorting
	    objectKeyList.sort();
	  } else if (typeof state.sortKeys === 'function') {
	    // Custom sort function
	    objectKeyList.sort(state.sortKeys);
	  } else if (state.sortKeys) {
	    // Something is wrong
	    throw new YAMLException('sortKeys must be a boolean or a function');
	  }

	  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
	    pairBuffer = '';

	    if (!compact || 0 !== index) {
	      pairBuffer += generateNextLine(state, level);
	    }

	    objectKey = objectKeyList[index];
	    objectValue = object[objectKey];

	    if (!writeNode(state, level + 1, objectKey, true, true, true)) {
	      continue; // Skip this pair because of invalid key.
	    }

	    explicitPair = null !== state.tag && '?' !== state.tag || state.dump && state.dump.length > 1024;

	    if (explicitPair) {
	      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
	        pairBuffer += '?';
	      } else {
	        pairBuffer += '? ';
	      }
	    }

	    pairBuffer += state.dump;

	    if (explicitPair) {
	      pairBuffer += generateNextLine(state, level);
	    }

	    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
	      continue; // Skip this pair because of invalid value.
	    }

	    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
	      pairBuffer += ':';
	    } else {
	      pairBuffer += ': ';
	    }

	    pairBuffer += state.dump;

	    // Both key and value are valid.
	    _result += pairBuffer;
	  }

	  state.tag = _tag;
	  state.dump = _result || '{}'; // Empty mapping if no valid pairs.
	}

	function detectType(state, object, explicit) {
	  var _result, typeList, index, length, type, style;

	  typeList = explicit ? state.explicitTypes : state.implicitTypes;

	  for (index = 0, length = typeList.length; index < length; index += 1) {
	    type = typeList[index];

	    if ((type.instanceOf || type.predicate) && (!type.instanceOf || 'object' === typeof object && object instanceof type.instanceOf) && (!type.predicate || type.predicate(object))) {

	      state.tag = explicit ? type.tag : '?';

	      if (type.represent) {
	        style = state.styleMap[type.tag] || type.defaultStyle;

	        if ('[object Function]' === _toString.call(type.represent)) {
	          _result = type.represent(object, style);
	        } else if (_hasOwnProperty.call(type.represent, style)) {
	          _result = type.represent[style](object, style);
	        } else {
	          throw new YAMLException('!<' + type.tag + '> tag resolver accepts not "' + style + '" style');
	        }

	        state.dump = _result;
	      }

	      return true;
	    }
	  }

	  return false;
	}

	// Serializes `object` and writes it to global `result`.
	// Returns true on success, or false on invalid object.
	//
	function writeNode(state, level, object, block, compact, iskey) {
	  state.tag = null;
	  state.dump = object;

	  if (!detectType(state, object, false)) {
	    detectType(state, object, true);
	  }

	  var type = _toString.call(state.dump);

	  if (block) {
	    block = 0 > state.flowLevel || state.flowLevel > level;
	  }

	  var objectOrArray = '[object Object]' === type || '[object Array]' === type,
	      duplicateIndex,
	      duplicate;

	  if (objectOrArray) {
	    duplicateIndex = state.duplicates.indexOf(object);
	    duplicate = duplicateIndex !== -1;
	  }

	  if (null !== state.tag && '?' !== state.tag || duplicate || 2 !== state.indent && level > 0) {
	    compact = false;
	  }

	  if (duplicate && state.usedDuplicates[duplicateIndex]) {
	    state.dump = '*ref_' + duplicateIndex;
	  } else {
	    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
	      state.usedDuplicates[duplicateIndex] = true;
	    }
	    if ('[object Object]' === type) {
	      if (block && 0 !== Object.keys(state.dump).length) {
	        writeBlockMapping(state, level, state.dump, compact);
	        if (duplicate) {
	          state.dump = '&ref_' + duplicateIndex + state.dump;
	        }
	      } else {
	        writeFlowMapping(state, level, state.dump);
	        if (duplicate) {
	          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
	        }
	      }
	    } else if ('[object Array]' === type) {
	      if (block && 0 !== state.dump.length) {
	        writeBlockSequence(state, level, state.dump, compact);
	        if (duplicate) {
	          state.dump = '&ref_' + duplicateIndex + state.dump;
	        }
	      } else {
	        writeFlowSequence(state, level, state.dump);
	        if (duplicate) {
	          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
	        }
	      }
	    } else if ('[object String]' === type) {
	      if ('?' !== state.tag) {
	        writeScalar(state, state.dump, level, iskey);
	      }
	    } else {
	      if (state.skipInvalid) {
	        return false;
	      }
	      throw new YAMLException('unacceptable kind of an object to dump ' + type);
	    }

	    if (null !== state.tag && '?' !== state.tag) {
	      state.dump = '!<' + state.tag + '> ' + state.dump;
	    }
	  }

	  return true;
	}

	function getDuplicateReferences(object, state) {
	  var objects = [],
	      duplicatesIndexes = [],
	      index,
	      length;

	  inspectNode(object, objects, duplicatesIndexes);

	  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
	    state.duplicates.push(objects[duplicatesIndexes[index]]);
	  }
	  state.usedDuplicates = new Array(length);
	}

	function inspectNode(object, objects, duplicatesIndexes) {
	  var objectKeyList, index, length;

	  if (null !== object && 'object' === typeof object) {
	    index = objects.indexOf(object);
	    if (-1 !== index) {
	      if (-1 === duplicatesIndexes.indexOf(index)) {
	        duplicatesIndexes.push(index);
	      }
	    } else {
	      objects.push(object);

	      if (Array.isArray(object)) {
	        for (index = 0, length = object.length; index < length; index += 1) {
	          inspectNode(object[index], objects, duplicatesIndexes);
	        }
	      } else {
	        objectKeyList = Object.keys(object);

	        for (index = 0, length = objectKeyList.length; index < length; index += 1) {
	          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
	        }
	      }
	    }
	  }
	}

	function dump(input, options) {
	  options = options || {};

	  var state = new State(options);

	  getDuplicateReferences(input, state);

	  if (writeNode(state, 0, input, true, true)) {
	    return state.dump + '\n';
	  }
	  return '';
	}

	function safeDump(input, options) {
	  return dump(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
	}

	module.exports.dump = dump;
	module.exports.safeDump = safeDump;

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	var parser = __webpack_require__(52);
	var compiler = __webpack_require__(53);

	module.exports = {
	  parse: function (input) {
	    var nodes = parser.parse(input.toString());
	    return compiler.compile(nodes);
	  }
	};

/***/ },
/* 52 */
/***/ function(module, exports) {

	module.exports=(function(){ /*
	   * Generated by PEG.js 0.8.0.
	   *
	   * http://pegjs.majda.cz/
	   */function peg$subclass(child,parent){function ctor(){this.constructor=child}ctor.prototype=parent.prototype;child.prototype=new ctor}function SyntaxError(message,expected,found,offset,line,column){this.message=message;this.expected=expected;this.found=found;this.offset=offset;this.line=line;this.column=column;this.name="SyntaxError"}peg$subclass(SyntaxError,Error);function parse(input){var options=arguments.length>1?arguments[1]:{},peg$FAILED={},peg$startRuleFunctions={start:peg$parsestart},peg$startRuleFunction=peg$parsestart,peg$c0=[],peg$c1=function(){return nodes},peg$c2=peg$FAILED,peg$c3="#",peg$c4={type:"literal",value:"#",description:"\"#\""},peg$c5=void 0,peg$c6={type:"any",description:"any character"},peg$c7="[",peg$c8={type:"literal",value:"[",description:"\"[\""},peg$c9="]",peg$c10={type:"literal",value:"]",description:"\"]\""},peg$c11=function(name){addNode(node('ObjectPath',name,line,column))},peg$c12=function(name){addNode(node('ArrayPath',name,line,column))},peg$c13=function(parts,name){return parts.concat(name)},peg$c14=function(name){return [name]},peg$c15=function(name){return name},peg$c16=".",peg$c17={type:"literal",value:".",description:"\".\""},peg$c18="=",peg$c19={type:"literal",value:"=",description:"\"=\""},peg$c20=function(key,value){addNode(node('Assign',value,line,column,key))},peg$c21=function(chars){return chars.join('')},peg$c22="\"",peg$c23={type:"literal",value:"\"",description:"\"\\\"\""},peg$c24=function(char){return char},peg$c25="\"\"\"",peg$c26={type:"literal",value:"\"\"\"",description:"\"\\\"\\\"\\\"\""},peg$c27=null,peg$c28=function(chars){return node('String',chars.join(''),line,column)},peg$c29="'''",peg$c30={type:"literal",value:"'''",description:"\"'''\""},peg$c31="'",peg$c32={type:"literal",value:"'",description:"\"'\""},peg$c33="\\",peg$c34={type:"literal",value:"\\",description:"\"\\\\\""},peg$c35=function(char){return char},peg$c36=function(){return ''},peg$c37="e",peg$c38={type:"literal",value:"e",description:"\"e\""},peg$c39="E",peg$c40={type:"literal",value:"E",description:"\"E\""},peg$c41=function(left,right){return node('Float',parseFloat(left+'e'+right),line,column)},peg$c42=function(text){return node('Float',parseFloat(text),line,column)},peg$c43="+",peg$c44={type:"literal",value:"+",description:"\"+\""},peg$c45=function(digits){return digits.join('')},peg$c46="-",peg$c47={type:"literal",value:"-",description:"\"-\""},peg$c48=function(digits){return '-'+digits.join('')},peg$c49=function(text){return node('Integer',parseInt(text,10),line,column)},peg$c50="true",peg$c51={type:"literal",value:"true",description:"\"true\""},peg$c52=function(){return node('Boolean',true,line,column)},peg$c53="false",peg$c54={type:"literal",value:"false",description:"\"false\""},peg$c55=function(){return node('Boolean',false,line,column)},peg$c56=function(){return node('Array',[],line,column)},peg$c57=function(value){return node('Array',value?[value]:[],line,column)},peg$c58=function(values){return node('Array',values,line,column)},peg$c59=function(values,value){return node('Array',values.concat(value),line,column)},peg$c60=function(value){return value},peg$c61=",",peg$c62={type:"literal",value:",",description:"\",\""},peg$c63="{",peg$c64={type:"literal",value:"{",description:"\"{\""},peg$c65="}",peg$c66={type:"literal",value:"}",description:"\"}\""},peg$c67=function(values){return node('InlineTable',values,line,column)},peg$c68=function(key,value){return node('InlineTableValue',value,line,column,key)},peg$c69=function(digits){return "."+digits},peg$c70=function(date){return date.join('')},peg$c71=":",peg$c72={type:"literal",value:":",description:"\":\""},peg$c73=function(time){return time.join('')},peg$c74="T",peg$c75={type:"literal",value:"T",description:"\"T\""},peg$c76="Z",peg$c77={type:"literal",value:"Z",description:"\"Z\""},peg$c78=function(date,time){return node('Date',new Date(date+"T"+time+"Z"),line,column)},peg$c79=function(date,time){return node('Date',new Date(date+"T"+time),line,column)},peg$c80=/^[ \t]/,peg$c81={type:"class",value:"[ \\t]",description:"[ \\t]"},peg$c82="\n",peg$c83={type:"literal",value:"\n",description:"\"\\n\""},peg$c84="\r",peg$c85={type:"literal",value:"\r",description:"\"\\r\""},peg$c86=/^[0-9a-f]/i,peg$c87={type:"class",value:"[0-9a-f]i",description:"[0-9a-f]i"},peg$c88=/^[0-9]/,peg$c89={type:"class",value:"[0-9]",description:"[0-9]"},peg$c90="_",peg$c91={type:"literal",value:"_",description:"\"_\""},peg$c92=function(){return ""},peg$c93=/^[A-Za-z0-9_\-]/,peg$c94={type:"class",value:"[A-Za-z0-9_\\-]",description:"[A-Za-z0-9_\\-]"},peg$c95=function(d){return d.join('')},peg$c96="\\\"",peg$c97={type:"literal",value:"\\\"",description:"\"\\\\\\\"\""},peg$c98=function(){return '"'},peg$c99="\\\\",peg$c100={type:"literal",value:"\\\\",description:"\"\\\\\\\\\""},peg$c101=function(){return '\\'},peg$c102="\\b",peg$c103={type:"literal",value:"\\b",description:"\"\\\\b\""},peg$c104=function(){return '\b'},peg$c105="\\t",peg$c106={type:"literal",value:"\\t",description:"\"\\\\t\""},peg$c107=function(){return '\t'},peg$c108="\\n",peg$c109={type:"literal",value:"\\n",description:"\"\\\\n\""},peg$c110=function(){return '\n'},peg$c111="\\f",peg$c112={type:"literal",value:"\\f",description:"\"\\\\f\""},peg$c113=function(){return '\f'},peg$c114="\\r",peg$c115={type:"literal",value:"\\r",description:"\"\\\\r\""},peg$c116=function(){return '\r'},peg$c117="\\U",peg$c118={type:"literal",value:"\\U",description:"\"\\\\U\""},peg$c119=function(digits){return convertCodePoint(digits.join(''))},peg$c120="\\u",peg$c121={type:"literal",value:"\\u",description:"\"\\\\u\""},peg$currPos=0,peg$reportedPos=0,peg$cachedPos=0,peg$cachedPosDetails={line:1,column:1,seenCR:false},peg$maxFailPos=0,peg$maxFailExpected=[],peg$silentFails=0,peg$cache={},peg$result;if("startRule" in options){if(!(options.startRule in peg$startRuleFunctions)){throw new Error("Can't start parsing from rule \""+options.startRule+"\".")}peg$startRuleFunction=peg$startRuleFunctions[options.startRule]}function text(){return input.substring(peg$reportedPos,peg$currPos)}function offset(){return peg$reportedPos}function line(){return peg$computePosDetails(peg$reportedPos).line}function column(){return peg$computePosDetails(peg$reportedPos).column}function expected(description){throw peg$buildException(null,[{type:"other",description:description}],peg$reportedPos)}function error(message){throw peg$buildException(message,null,peg$reportedPos)}function peg$computePosDetails(pos){function advance(details,startPos,endPos){var p,ch;for(p=startPos;p<endPos;p++){ch=input.charAt(p);if(ch==="\n"){if(!details.seenCR){details.line++}details.column=1;details.seenCR=false}else if(ch==="\r"||ch==="\u2028"||ch==="\u2029"){details.line++;details.column=1;details.seenCR=true}else {details.column++;details.seenCR=false}}}if(peg$cachedPos!==pos){if(peg$cachedPos>pos){peg$cachedPos=0;peg$cachedPosDetails={line:1,column:1,seenCR:false}}advance(peg$cachedPosDetails,peg$cachedPos,pos);peg$cachedPos=pos}return peg$cachedPosDetails}function peg$fail(expected){if(peg$currPos<peg$maxFailPos){return}if(peg$currPos>peg$maxFailPos){peg$maxFailPos=peg$currPos;peg$maxFailExpected=[]}peg$maxFailExpected.push(expected)}function peg$buildException(message,expected,pos){function cleanupExpected(expected){var i=1;expected.sort(function(a,b){if(a.description<b.description){return -1}else if(a.description>b.description){return 1}else {return 0}});while(i<expected.length){if(expected[i-1]===expected[i]){expected.splice(i,1)}else {i++}}}function buildMessage(expected,found){function stringEscape(s){function hex(ch){return ch.charCodeAt(0).toString(16).toUpperCase()}return s.replace(/\\/g,'\\\\').replace(/"/g,'\\"').replace(/\x08/g,'\\b').replace(/\t/g,'\\t').replace(/\n/g,'\\n').replace(/\f/g,'\\f').replace(/\r/g,'\\r').replace(/[\x00-\x07\x0B\x0E\x0F]/g,function(ch){return '\\x0'+hex(ch)}).replace(/[\x10-\x1F\x80-\xFF]/g,function(ch){return '\\x'+hex(ch)}).replace(/[\u0180-\u0FFF]/g,function(ch){return '\\u0'+hex(ch)}).replace(/[\u1080-\uFFFF]/g,function(ch){return '\\u'+hex(ch)})}var expectedDescs=new Array(expected.length),expectedDesc,foundDesc,i;for(i=0;i<expected.length;i++){expectedDescs[i]=expected[i].description}expectedDesc=expected.length>1?expectedDescs.slice(0,-1).join(", ")+" or "+expectedDescs[expected.length-1]:expectedDescs[0];foundDesc=found?"\""+stringEscape(found)+"\"":"end of input";return "Expected "+expectedDesc+" but "+foundDesc+" found."}var posDetails=peg$computePosDetails(pos),found=pos<input.length?input.charAt(pos):null;if(expected!==null){cleanupExpected(expected)}return new SyntaxError(message!==null?message:buildMessage(expected,found),expected,found,pos,posDetails.line,posDetails.column)}function peg$parsestart(){var s0,s1,s2;var key=peg$currPos*45+0,cached=peg$cache[key];if(cached){peg$currPos=cached.nextPos;return cached.result}s0=peg$currPos;s1=[];s2=peg$parseline();while(s2!==peg$FAILED){s1.push(s2);s2=peg$parseline()}if(s1!==peg$FAILED){peg$reportedPos=s0;s1=peg$c1()}s0=s1;peg$cache[key]={nextPos:peg$currPos,result:s0};return s0}function peg$parseline(){var s0,s1,s2,s3,s4,s5,s6;var key=peg$currPos*45+1,cached=peg$cache[key];if(cached){peg$currPos=cached.nextPos;return cached.result}s0=peg$currPos;s1=[];s2=peg$parseS();while(s2!==peg$FAILED){s1.push(s2);s2=peg$parseS()}if(s1!==peg$FAILED){s2=peg$parseexpression();if(s2!==peg$FAILED){s3=[];s4=peg$parseS();while(s4!==peg$FAILED){s3.push(s4);s4=peg$parseS()}if(s3!==peg$FAILED){s4=[];s5=peg$parsecomment();while(s5!==peg$FAILED){s4.push(s5);s5=peg$parsecomment()}if(s4!==peg$FAILED){s5=[];s6=peg$parseNL();if(s6!==peg$FAILED){while(s6!==peg$FAILED){s5.push(s6);s6=peg$parseNL()}}else {s5=peg$c2}if(s5===peg$FAILED){s5=peg$parseEOF()}if(s5!==peg$FAILED){s1=[s1,s2,s3,s4,s5];s0=s1}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}if(s0===peg$FAILED){s0=peg$currPos;s1=[];s2=peg$parseS();if(s2!==peg$FAILED){while(s2!==peg$FAILED){s1.push(s2);s2=peg$parseS()}}else {s1=peg$c2}if(s1!==peg$FAILED){s2=[];s3=peg$parseNL();if(s3!==peg$FAILED){while(s3!==peg$FAILED){s2.push(s3);s3=peg$parseNL()}}else {s2=peg$c2}if(s2===peg$FAILED){s2=peg$parseEOF()}if(s2!==peg$FAILED){s1=[s1,s2];s0=s1}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}if(s0===peg$FAILED){s0=peg$parseNL()}}peg$cache[key]={nextPos:peg$currPos,result:s0};return s0}function peg$parseexpression(){var s0;var key=peg$currPos*45+2,cached=peg$cache[key];if(cached){peg$currPos=cached.nextPos;return cached.result}s0=peg$parsecomment();if(s0===peg$FAILED){s0=peg$parsepath();if(s0===peg$FAILED){s0=peg$parsetablearray();if(s0===peg$FAILED){s0=peg$parseassignment()}}}peg$cache[key]={nextPos:peg$currPos,result:s0};return s0}function peg$parsecomment(){var s0,s1,s2,s3,s4,s5;var key=peg$currPos*45+3,cached=peg$cache[key];if(cached){peg$currPos=cached.nextPos;return cached.result}s0=peg$currPos;if(input.charCodeAt(peg$currPos)===35){s1=peg$c3;peg$currPos++}else {s1=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c4)}}if(s1!==peg$FAILED){s2=[];s3=peg$currPos;s4=peg$currPos;peg$silentFails++;s5=peg$parseNL();if(s5===peg$FAILED){s5=peg$parseEOF()}peg$silentFails--;if(s5===peg$FAILED){s4=peg$c5}else {peg$currPos=s4;s4=peg$c2}if(s4!==peg$FAILED){if(input.length>peg$currPos){s5=input.charAt(peg$currPos);peg$currPos++}else {s5=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c6)}}if(s5!==peg$FAILED){s4=[s4,s5];s3=s4}else {peg$currPos=s3;s3=peg$c2}}else {peg$currPos=s3;s3=peg$c2}while(s3!==peg$FAILED){s2.push(s3);s3=peg$currPos;s4=peg$currPos;peg$silentFails++;s5=peg$parseNL();if(s5===peg$FAILED){s5=peg$parseEOF()}peg$silentFails--;if(s5===peg$FAILED){s4=peg$c5}else {peg$currPos=s4;s4=peg$c2}if(s4!==peg$FAILED){if(input.length>peg$currPos){s5=input.charAt(peg$currPos);peg$currPos++}else {s5=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c6)}}if(s5!==peg$FAILED){s4=[s4,s5];s3=s4}else {peg$currPos=s3;s3=peg$c2}}else {peg$currPos=s3;s3=peg$c2}}if(s2!==peg$FAILED){s1=[s1,s2];s0=s1}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}peg$cache[key]={nextPos:peg$currPos,result:s0};return s0}function peg$parsepath(){var s0,s1,s2,s3,s4,s5;var key=peg$currPos*45+4,cached=peg$cache[key];if(cached){peg$currPos=cached.nextPos;return cached.result}s0=peg$currPos;if(input.charCodeAt(peg$currPos)===91){s1=peg$c7;peg$currPos++}else {s1=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c8)}}if(s1!==peg$FAILED){s2=[];s3=peg$parseS();while(s3!==peg$FAILED){s2.push(s3);s3=peg$parseS()}if(s2!==peg$FAILED){s3=peg$parsetable_key();if(s3!==peg$FAILED){s4=[];s5=peg$parseS();while(s5!==peg$FAILED){s4.push(s5);s5=peg$parseS()}if(s4!==peg$FAILED){if(input.charCodeAt(peg$currPos)===93){s5=peg$c9;peg$currPos++}else {s5=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c10)}}if(s5!==peg$FAILED){peg$reportedPos=s0;s1=peg$c11(s3);s0=s1}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}peg$cache[key]={nextPos:peg$currPos,result:s0};return s0}function peg$parsetablearray(){var s0,s1,s2,s3,s4,s5,s6,s7;var key=peg$currPos*45+5,cached=peg$cache[key];if(cached){peg$currPos=cached.nextPos;return cached.result}s0=peg$currPos;if(input.charCodeAt(peg$currPos)===91){s1=peg$c7;peg$currPos++}else {s1=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c8)}}if(s1!==peg$FAILED){if(input.charCodeAt(peg$currPos)===91){s2=peg$c7;peg$currPos++}else {s2=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c8)}}if(s2!==peg$FAILED){s3=[];s4=peg$parseS();while(s4!==peg$FAILED){s3.push(s4);s4=peg$parseS()}if(s3!==peg$FAILED){s4=peg$parsetable_key();if(s4!==peg$FAILED){s5=[];s6=peg$parseS();while(s6!==peg$FAILED){s5.push(s6);s6=peg$parseS()}if(s5!==peg$FAILED){if(input.charCodeAt(peg$currPos)===93){s6=peg$c9;peg$currPos++}else {s6=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c10)}}if(s6!==peg$FAILED){if(input.charCodeAt(peg$currPos)===93){s7=peg$c9;peg$currPos++}else {s7=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c10)}}if(s7!==peg$FAILED){peg$reportedPos=s0;s1=peg$c12(s4);s0=s1}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}peg$cache[key]={nextPos:peg$currPos,result:s0};return s0}function peg$parsetable_key(){var s0,s1,s2;var key=peg$currPos*45+6,cached=peg$cache[key];if(cached){peg$currPos=cached.nextPos;return cached.result}s0=peg$currPos;s1=[];s2=peg$parsedot_ended_table_key_part();if(s2!==peg$FAILED){while(s2!==peg$FAILED){s1.push(s2);s2=peg$parsedot_ended_table_key_part()}}else {s1=peg$c2}if(s1!==peg$FAILED){s2=peg$parsetable_key_part();if(s2!==peg$FAILED){peg$reportedPos=s0;s1=peg$c13(s1,s2);s0=s1}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}if(s0===peg$FAILED){s0=peg$currPos;s1=peg$parsetable_key_part();if(s1!==peg$FAILED){peg$reportedPos=s0;s1=peg$c14(s1)}s0=s1}peg$cache[key]={nextPos:peg$currPos,result:s0};return s0}function peg$parsetable_key_part(){var s0,s1,s2,s3,s4;var key=peg$currPos*45+7,cached=peg$cache[key];if(cached){peg$currPos=cached.nextPos;return cached.result}s0=peg$currPos;s1=[];s2=peg$parseS();while(s2!==peg$FAILED){s1.push(s2);s2=peg$parseS()}if(s1!==peg$FAILED){s2=peg$parsekey();if(s2!==peg$FAILED){s3=[];s4=peg$parseS();while(s4!==peg$FAILED){s3.push(s4);s4=peg$parseS()}if(s3!==peg$FAILED){peg$reportedPos=s0;s1=peg$c15(s2);s0=s1}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}if(s0===peg$FAILED){s0=peg$currPos;s1=[];s2=peg$parseS();while(s2!==peg$FAILED){s1.push(s2);s2=peg$parseS()}if(s1!==peg$FAILED){s2=peg$parsequoted_key();if(s2!==peg$FAILED){s3=[];s4=peg$parseS();while(s4!==peg$FAILED){s3.push(s4);s4=peg$parseS()}if(s3!==peg$FAILED){peg$reportedPos=s0;s1=peg$c15(s2);s0=s1}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}}peg$cache[key]={nextPos:peg$currPos,result:s0};return s0}function peg$parsedot_ended_table_key_part(){var s0,s1,s2,s3,s4,s5,s6;var key=peg$currPos*45+8,cached=peg$cache[key];if(cached){peg$currPos=cached.nextPos;return cached.result}s0=peg$currPos;s1=[];s2=peg$parseS();while(s2!==peg$FAILED){s1.push(s2);s2=peg$parseS()}if(s1!==peg$FAILED){s2=peg$parsekey();if(s2!==peg$FAILED){s3=[];s4=peg$parseS();while(s4!==peg$FAILED){s3.push(s4);s4=peg$parseS()}if(s3!==peg$FAILED){if(input.charCodeAt(peg$currPos)===46){s4=peg$c16;peg$currPos++}else {s4=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c17)}}if(s4!==peg$FAILED){s5=[];s6=peg$parseS();while(s6!==peg$FAILED){s5.push(s6);s6=peg$parseS()}if(s5!==peg$FAILED){peg$reportedPos=s0;s1=peg$c15(s2);s0=s1}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}if(s0===peg$FAILED){s0=peg$currPos;s1=[];s2=peg$parseS();while(s2!==peg$FAILED){s1.push(s2);s2=peg$parseS()}if(s1!==peg$FAILED){s2=peg$parsequoted_key();if(s2!==peg$FAILED){s3=[];s4=peg$parseS();while(s4!==peg$FAILED){s3.push(s4);s4=peg$parseS()}if(s3!==peg$FAILED){if(input.charCodeAt(peg$currPos)===46){s4=peg$c16;peg$currPos++}else {s4=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c17)}}if(s4!==peg$FAILED){s5=[];s6=peg$parseS();while(s6!==peg$FAILED){s5.push(s6);s6=peg$parseS()}if(s5!==peg$FAILED){peg$reportedPos=s0;s1=peg$c15(s2);s0=s1}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}}peg$cache[key]={nextPos:peg$currPos,result:s0};return s0}function peg$parseassignment(){var s0,s1,s2,s3,s4,s5;var key=peg$currPos*45+9,cached=peg$cache[key];if(cached){peg$currPos=cached.nextPos;return cached.result}s0=peg$currPos;s1=peg$parsekey();if(s1!==peg$FAILED){s2=[];s3=peg$parseS();while(s3!==peg$FAILED){s2.push(s3);s3=peg$parseS()}if(s2!==peg$FAILED){if(input.charCodeAt(peg$currPos)===61){s3=peg$c18;peg$currPos++}else {s3=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c19)}}if(s3!==peg$FAILED){s4=[];s5=peg$parseS();while(s5!==peg$FAILED){s4.push(s5);s5=peg$parseS()}if(s4!==peg$FAILED){s5=peg$parsevalue();if(s5!==peg$FAILED){peg$reportedPos=s0;s1=peg$c20(s1,s5);s0=s1}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}if(s0===peg$FAILED){s0=peg$currPos;s1=peg$parsequoted_key();if(s1!==peg$FAILED){s2=[];s3=peg$parseS();while(s3!==peg$FAILED){s2.push(s3);s3=peg$parseS()}if(s2!==peg$FAILED){if(input.charCodeAt(peg$currPos)===61){s3=peg$c18;peg$currPos++}else {s3=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c19)}}if(s3!==peg$FAILED){s4=[];s5=peg$parseS();while(s5!==peg$FAILED){s4.push(s5);s5=peg$parseS()}if(s4!==peg$FAILED){s5=peg$parsevalue();if(s5!==peg$FAILED){peg$reportedPos=s0;s1=peg$c20(s1,s5);s0=s1}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}}peg$cache[key]={nextPos:peg$currPos,result:s0};return s0}function peg$parsekey(){var s0,s1,s2;var key=peg$currPos*45+10,cached=peg$cache[key];if(cached){peg$currPos=cached.nextPos;return cached.result}s0=peg$currPos;s1=[];s2=peg$parseASCII_BASIC();if(s2!==peg$FAILED){while(s2!==peg$FAILED){s1.push(s2);s2=peg$parseASCII_BASIC()}}else {s1=peg$c2}if(s1!==peg$FAILED){peg$reportedPos=s0;s1=peg$c21(s1)}s0=s1;peg$cache[key]={nextPos:peg$currPos,result:s0};return s0}function peg$parsequoted_key(){var s0,s1,s2,s3,s4,s5;var key=peg$currPos*45+11,cached=peg$cache[key];if(cached){peg$currPos=cached.nextPos;return cached.result}s0=peg$currPos;if(input.charCodeAt(peg$currPos)===34){s1=peg$c22;peg$currPos++}else {s1=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c23)}}if(s1!==peg$FAILED){s2=[];s3=peg$currPos;s4=peg$currPos;peg$silentFails++;s5=peg$parseNL();if(s5===peg$FAILED){if(input.charCodeAt(peg$currPos)===91){s5=peg$c7;peg$currPos++}else {s5=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c8)}}if(s5===peg$FAILED){if(input.charCodeAt(peg$currPos)===93){s5=peg$c9;peg$currPos++}else {s5=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c10)}}if(s5===peg$FAILED){if(input.charCodeAt(peg$currPos)===61){s5=peg$c18;peg$currPos++}else {s5=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c19)}}if(s5===peg$FAILED){if(input.charCodeAt(peg$currPos)===34){s5=peg$c22;peg$currPos++}else {s5=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c23)}}}}}}peg$silentFails--;if(s5===peg$FAILED){s4=peg$c5}else {peg$currPos=s4;s4=peg$c2}if(s4!==peg$FAILED){s5=peg$parseESCAPED();if(s5===peg$FAILED){if(input.length>peg$currPos){s5=input.charAt(peg$currPos);peg$currPos++}else {s5=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c6)}}}if(s5!==peg$FAILED){peg$reportedPos=s3;s4=peg$c24(s5);s3=s4}else {peg$currPos=s3;s3=peg$c2}}else {peg$currPos=s3;s3=peg$c2}if(s3!==peg$FAILED){while(s3!==peg$FAILED){s2.push(s3);s3=peg$currPos;s4=peg$currPos;peg$silentFails++;s5=peg$parseNL();if(s5===peg$FAILED){if(input.charCodeAt(peg$currPos)===91){s5=peg$c7;peg$currPos++}else {s5=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c8)}}if(s5===peg$FAILED){if(input.charCodeAt(peg$currPos)===93){s5=peg$c9;peg$currPos++}else {s5=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c10)}}if(s5===peg$FAILED){if(input.charCodeAt(peg$currPos)===61){s5=peg$c18;peg$currPos++}else {s5=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c19)}}if(s5===peg$FAILED){if(input.charCodeAt(peg$currPos)===34){s5=peg$c22;peg$currPos++}else {s5=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c23)}}}}}}peg$silentFails--;if(s5===peg$FAILED){s4=peg$c5}else {peg$currPos=s4;s4=peg$c2}if(s4!==peg$FAILED){s5=peg$parseESCAPED();if(s5===peg$FAILED){if(input.length>peg$currPos){s5=input.charAt(peg$currPos);peg$currPos++}else {s5=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c6)}}}if(s5!==peg$FAILED){peg$reportedPos=s3;s4=peg$c24(s5);s3=s4}else {peg$currPos=s3;s3=peg$c2}}else {peg$currPos=s3;s3=peg$c2}}}else {s2=peg$c2}if(s2!==peg$FAILED){if(input.charCodeAt(peg$currPos)===34){s3=peg$c22;peg$currPos++}else {s3=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c23)}}if(s3!==peg$FAILED){peg$reportedPos=s0;s1=peg$c21(s2);s0=s1}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}peg$cache[key]={nextPos:peg$currPos,result:s0};return s0}function peg$parsevalue(){var s0;var key=peg$currPos*45+12,cached=peg$cache[key];if(cached){peg$currPos=cached.nextPos;return cached.result}s0=peg$parsestring();if(s0===peg$FAILED){s0=peg$parsedatetime();if(s0===peg$FAILED){s0=peg$parsefloat();if(s0===peg$FAILED){s0=peg$parseinteger();if(s0===peg$FAILED){s0=peg$parseboolean();if(s0===peg$FAILED){s0=peg$parsearray();if(s0===peg$FAILED){s0=peg$parseinline_table()}}}}}}peg$cache[key]={nextPos:peg$currPos,result:s0};return s0}function peg$parsestring(){var s0,s1,s2,s3,s4;var key=peg$currPos*45+13,cached=peg$cache[key];if(cached){peg$currPos=cached.nextPos;return cached.result}s0=peg$currPos;if(input.substr(peg$currPos,3)===peg$c25){s1=peg$c25;peg$currPos+=3}else {s1=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c26)}}if(s1!==peg$FAILED){s2=peg$parseNL();if(s2===peg$FAILED){s2=peg$c27}if(s2!==peg$FAILED){s3=[];s4=peg$parsemultiline_string_char();while(s4!==peg$FAILED){s3.push(s4);s4=peg$parsemultiline_string_char()}if(s3!==peg$FAILED){if(input.substr(peg$currPos,3)===peg$c25){s4=peg$c25;peg$currPos+=3}else {s4=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c26)}}if(s4!==peg$FAILED){peg$reportedPos=s0;s1=peg$c28(s3);s0=s1}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}if(s0===peg$FAILED){s0=peg$currPos;if(input.charCodeAt(peg$currPos)===34){s1=peg$c22;peg$currPos++}else {s1=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c23)}}if(s1!==peg$FAILED){s2=[];s3=peg$parsestring_char();while(s3!==peg$FAILED){s2.push(s3);s3=peg$parsestring_char()}if(s2!==peg$FAILED){if(input.charCodeAt(peg$currPos)===34){s3=peg$c22;peg$currPos++}else {s3=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c23)}}if(s3!==peg$FAILED){peg$reportedPos=s0;s1=peg$c28(s2);s0=s1}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}if(s0===peg$FAILED){s0=peg$currPos;if(input.substr(peg$currPos,3)===peg$c29){s1=peg$c29;peg$currPos+=3}else {s1=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c30)}}if(s1!==peg$FAILED){s2=peg$parseNL();if(s2===peg$FAILED){s2=peg$c27}if(s2!==peg$FAILED){s3=[];s4=peg$parsemultiline_literal_char();while(s4!==peg$FAILED){s3.push(s4);s4=peg$parsemultiline_literal_char()}if(s3!==peg$FAILED){if(input.substr(peg$currPos,3)===peg$c29){s4=peg$c29;peg$currPos+=3}else {s4=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c30)}}if(s4!==peg$FAILED){peg$reportedPos=s0;s1=peg$c28(s3);s0=s1}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}if(s0===peg$FAILED){s0=peg$currPos;if(input.charCodeAt(peg$currPos)===39){s1=peg$c31;peg$currPos++}else {s1=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c32)}}if(s1!==peg$FAILED){s2=[];s3=peg$parseliteral_char();while(s3!==peg$FAILED){s2.push(s3);s3=peg$parseliteral_char()}if(s2!==peg$FAILED){if(input.charCodeAt(peg$currPos)===39){s3=peg$c31;peg$currPos++}else {s3=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c32)}}if(s3!==peg$FAILED){peg$reportedPos=s0;s1=peg$c28(s2);s0=s1}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}}}}peg$cache[key]={nextPos:peg$currPos,result:s0};return s0}function peg$parsestring_char(){var s0,s1,s2,s3;var key=peg$currPos*45+14,cached=peg$cache[key];if(cached){peg$currPos=cached.nextPos;return cached.result}s0=peg$parseESCAPED();if(s0===peg$FAILED){s0=peg$currPos;s1=peg$currPos;peg$silentFails++;if(input.charCodeAt(peg$currPos)===34){s2=peg$c22;peg$currPos++}else {s2=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c23)}}peg$silentFails--;if(s2===peg$FAILED){s1=peg$c5}else {peg$currPos=s1;s1=peg$c2}if(s1!==peg$FAILED){s2=peg$currPos;peg$silentFails++;if(input.charCodeAt(peg$currPos)===92){s3=peg$c33;peg$currPos++}else {s3=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c34)}}peg$silentFails--;if(s3===peg$FAILED){s2=peg$c5}else {peg$currPos=s2;s2=peg$c2}if(s2!==peg$FAILED){if(input.length>peg$currPos){s3=input.charAt(peg$currPos);peg$currPos++}else {s3=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c6)}}if(s3!==peg$FAILED){peg$reportedPos=s0;s1=peg$c24(s3);s0=s1}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}}peg$cache[key]={nextPos:peg$currPos,result:s0};return s0}function peg$parseliteral_char(){var s0,s1,s2;var key=peg$currPos*45+15,cached=peg$cache[key];if(cached){peg$currPos=cached.nextPos;return cached.result}s0=peg$currPos;s1=peg$currPos;peg$silentFails++;if(input.charCodeAt(peg$currPos)===39){s2=peg$c31;peg$currPos++}else {s2=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c32)}}peg$silentFails--;if(s2===peg$FAILED){s1=peg$c5}else {peg$currPos=s1;s1=peg$c2}if(s1!==peg$FAILED){if(input.length>peg$currPos){s2=input.charAt(peg$currPos);peg$currPos++}else {s2=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c6)}}if(s2!==peg$FAILED){peg$reportedPos=s0;s1=peg$c24(s2);s0=s1}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}peg$cache[key]={nextPos:peg$currPos,result:s0};return s0}function peg$parsemultiline_string_char(){var s0,s1,s2;var key=peg$currPos*45+16,cached=peg$cache[key];if(cached){peg$currPos=cached.nextPos;return cached.result}s0=peg$parseESCAPED();if(s0===peg$FAILED){s0=peg$parsemultiline_string_delim();if(s0===peg$FAILED){s0=peg$currPos;s1=peg$currPos;peg$silentFails++;if(input.substr(peg$currPos,3)===peg$c25){s2=peg$c25;peg$currPos+=3}else {s2=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c26)}}peg$silentFails--;if(s2===peg$FAILED){s1=peg$c5}else {peg$currPos=s1;s1=peg$c2}if(s1!==peg$FAILED){if(input.length>peg$currPos){s2=input.charAt(peg$currPos);peg$currPos++}else {s2=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c6)}}if(s2!==peg$FAILED){peg$reportedPos=s0;s1=peg$c35(s2);s0=s1}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}}}peg$cache[key]={nextPos:peg$currPos,result:s0};return s0}function peg$parsemultiline_string_delim(){var s0,s1,s2,s3,s4;var key=peg$currPos*45+17,cached=peg$cache[key];if(cached){peg$currPos=cached.nextPos;return cached.result}s0=peg$currPos;if(input.charCodeAt(peg$currPos)===92){s1=peg$c33;peg$currPos++}else {s1=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c34)}}if(s1!==peg$FAILED){s2=peg$parseNL();if(s2!==peg$FAILED){s3=[];s4=peg$parseNLS();while(s4!==peg$FAILED){s3.push(s4);s4=peg$parseNLS()}if(s3!==peg$FAILED){peg$reportedPos=s0;s1=peg$c36();s0=s1}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}peg$cache[key]={nextPos:peg$currPos,result:s0};return s0}function peg$parsemultiline_literal_char(){var s0,s1,s2;var key=peg$currPos*45+18,cached=peg$cache[key];if(cached){peg$currPos=cached.nextPos;return cached.result}s0=peg$currPos;s1=peg$currPos;peg$silentFails++;if(input.substr(peg$currPos,3)===peg$c29){s2=peg$c29;peg$currPos+=3}else {s2=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c30)}}peg$silentFails--;if(s2===peg$FAILED){s1=peg$c5}else {peg$currPos=s1;s1=peg$c2}if(s1!==peg$FAILED){if(input.length>peg$currPos){s2=input.charAt(peg$currPos);peg$currPos++}else {s2=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c6)}}if(s2!==peg$FAILED){peg$reportedPos=s0;s1=peg$c24(s2);s0=s1}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}peg$cache[key]={nextPos:peg$currPos,result:s0};return s0}function peg$parsefloat(){var s0,s1,s2,s3;var key=peg$currPos*45+19,cached=peg$cache[key];if(cached){peg$currPos=cached.nextPos;return cached.result}s0=peg$currPos;s1=peg$parsefloat_text();if(s1===peg$FAILED){s1=peg$parseinteger_text()}if(s1!==peg$FAILED){if(input.charCodeAt(peg$currPos)===101){s2=peg$c37;peg$currPos++}else {s2=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c38)}}if(s2===peg$FAILED){if(input.charCodeAt(peg$currPos)===69){s2=peg$c39;peg$currPos++}else {s2=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c40)}}}if(s2!==peg$FAILED){s3=peg$parseinteger_text();if(s3!==peg$FAILED){peg$reportedPos=s0;s1=peg$c41(s1,s3);s0=s1}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}if(s0===peg$FAILED){s0=peg$currPos;s1=peg$parsefloat_text();if(s1!==peg$FAILED){peg$reportedPos=s0;s1=peg$c42(s1)}s0=s1}peg$cache[key]={nextPos:peg$currPos,result:s0};return s0}function peg$parsefloat_text(){var s0,s1,s2,s3,s4,s5;var key=peg$currPos*45+20,cached=peg$cache[key];if(cached){peg$currPos=cached.nextPos;return cached.result}s0=peg$currPos;if(input.charCodeAt(peg$currPos)===43){s1=peg$c43;peg$currPos++}else {s1=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c44)}}if(s1===peg$FAILED){s1=peg$c27}if(s1!==peg$FAILED){s2=peg$currPos;s3=peg$parseDIGITS();if(s3!==peg$FAILED){if(input.charCodeAt(peg$currPos)===46){s4=peg$c16;peg$currPos++}else {s4=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c17)}}if(s4!==peg$FAILED){s5=peg$parseDIGITS();if(s5!==peg$FAILED){s3=[s3,s4,s5];s2=s3}else {peg$currPos=s2;s2=peg$c2}}else {peg$currPos=s2;s2=peg$c2}}else {peg$currPos=s2;s2=peg$c2}if(s2!==peg$FAILED){peg$reportedPos=s0;s1=peg$c45(s2);s0=s1}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}if(s0===peg$FAILED){s0=peg$currPos;if(input.charCodeAt(peg$currPos)===45){s1=peg$c46;peg$currPos++}else {s1=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c47)}}if(s1!==peg$FAILED){s2=peg$currPos;s3=peg$parseDIGITS();if(s3!==peg$FAILED){if(input.charCodeAt(peg$currPos)===46){s4=peg$c16;peg$currPos++}else {s4=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c17)}}if(s4!==peg$FAILED){s5=peg$parseDIGITS();if(s5!==peg$FAILED){s3=[s3,s4,s5];s2=s3}else {peg$currPos=s2;s2=peg$c2}}else {peg$currPos=s2;s2=peg$c2}}else {peg$currPos=s2;s2=peg$c2}if(s2!==peg$FAILED){peg$reportedPos=s0;s1=peg$c48(s2);s0=s1}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}}peg$cache[key]={nextPos:peg$currPos,result:s0};return s0}function peg$parseinteger(){var s0,s1;var key=peg$currPos*45+21,cached=peg$cache[key];if(cached){peg$currPos=cached.nextPos;return cached.result}s0=peg$currPos;s1=peg$parseinteger_text();if(s1!==peg$FAILED){peg$reportedPos=s0;s1=peg$c49(s1)}s0=s1;peg$cache[key]={nextPos:peg$currPos,result:s0};return s0}function peg$parseinteger_text(){var s0,s1,s2,s3,s4;var key=peg$currPos*45+22,cached=peg$cache[key];if(cached){peg$currPos=cached.nextPos;return cached.result}s0=peg$currPos;if(input.charCodeAt(peg$currPos)===43){s1=peg$c43;peg$currPos++}else {s1=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c44)}}if(s1===peg$FAILED){s1=peg$c27}if(s1!==peg$FAILED){s2=[];s3=peg$parseDIGIT_OR_UNDER();if(s3!==peg$FAILED){while(s3!==peg$FAILED){s2.push(s3);s3=peg$parseDIGIT_OR_UNDER()}}else {s2=peg$c2}if(s2!==peg$FAILED){s3=peg$currPos;peg$silentFails++;if(input.charCodeAt(peg$currPos)===46){s4=peg$c16;peg$currPos++}else {s4=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c17)}}peg$silentFails--;if(s4===peg$FAILED){s3=peg$c5}else {peg$currPos=s3;s3=peg$c2}if(s3!==peg$FAILED){peg$reportedPos=s0;s1=peg$c45(s2);s0=s1}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}if(s0===peg$FAILED){s0=peg$currPos;if(input.charCodeAt(peg$currPos)===45){s1=peg$c46;peg$currPos++}else {s1=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c47)}}if(s1!==peg$FAILED){s2=[];s3=peg$parseDIGIT_OR_UNDER();if(s3!==peg$FAILED){while(s3!==peg$FAILED){s2.push(s3);s3=peg$parseDIGIT_OR_UNDER()}}else {s2=peg$c2}if(s2!==peg$FAILED){s3=peg$currPos;peg$silentFails++;if(input.charCodeAt(peg$currPos)===46){s4=peg$c16;peg$currPos++}else {s4=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c17)}}peg$silentFails--;if(s4===peg$FAILED){s3=peg$c5}else {peg$currPos=s3;s3=peg$c2}if(s3!==peg$FAILED){peg$reportedPos=s0;s1=peg$c48(s2);s0=s1}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}}peg$cache[key]={nextPos:peg$currPos,result:s0};return s0}function peg$parseboolean(){var s0,s1;var key=peg$currPos*45+23,cached=peg$cache[key];if(cached){peg$currPos=cached.nextPos;return cached.result}s0=peg$currPos;if(input.substr(peg$currPos,4)===peg$c50){s1=peg$c50;peg$currPos+=4}else {s1=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c51)}}if(s1!==peg$FAILED){peg$reportedPos=s0;s1=peg$c52()}s0=s1;if(s0===peg$FAILED){s0=peg$currPos;if(input.substr(peg$currPos,5)===peg$c53){s1=peg$c53;peg$currPos+=5}else {s1=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c54)}}if(s1!==peg$FAILED){peg$reportedPos=s0;s1=peg$c55()}s0=s1}peg$cache[key]={nextPos:peg$currPos,result:s0};return s0}function peg$parsearray(){var s0,s1,s2,s3,s4;var key=peg$currPos*45+24,cached=peg$cache[key];if(cached){peg$currPos=cached.nextPos;return cached.result}s0=peg$currPos;if(input.charCodeAt(peg$currPos)===91){s1=peg$c7;peg$currPos++}else {s1=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c8)}}if(s1!==peg$FAILED){s2=[];s3=peg$parsearray_sep();while(s3!==peg$FAILED){s2.push(s3);s3=peg$parsearray_sep()}if(s2!==peg$FAILED){if(input.charCodeAt(peg$currPos)===93){s3=peg$c9;peg$currPos++}else {s3=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c10)}}if(s3!==peg$FAILED){peg$reportedPos=s0;s1=peg$c56();s0=s1}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}if(s0===peg$FAILED){s0=peg$currPos;if(input.charCodeAt(peg$currPos)===91){s1=peg$c7;peg$currPos++}else {s1=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c8)}}if(s1!==peg$FAILED){s2=peg$parsearray_value();if(s2===peg$FAILED){s2=peg$c27}if(s2!==peg$FAILED){if(input.charCodeAt(peg$currPos)===93){s3=peg$c9;peg$currPos++}else {s3=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c10)}}if(s3!==peg$FAILED){peg$reportedPos=s0;s1=peg$c57(s2);s0=s1}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}if(s0===peg$FAILED){s0=peg$currPos;if(input.charCodeAt(peg$currPos)===91){s1=peg$c7;peg$currPos++}else {s1=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c8)}}if(s1!==peg$FAILED){s2=[];s3=peg$parsearray_value_list();if(s3!==peg$FAILED){while(s3!==peg$FAILED){s2.push(s3);s3=peg$parsearray_value_list()}}else {s2=peg$c2}if(s2!==peg$FAILED){if(input.charCodeAt(peg$currPos)===93){s3=peg$c9;peg$currPos++}else {s3=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c10)}}if(s3!==peg$FAILED){peg$reportedPos=s0;s1=peg$c58(s2);s0=s1}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}if(s0===peg$FAILED){s0=peg$currPos;if(input.charCodeAt(peg$currPos)===91){s1=peg$c7;peg$currPos++}else {s1=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c8)}}if(s1!==peg$FAILED){s2=[];s3=peg$parsearray_value_list();if(s3!==peg$FAILED){while(s3!==peg$FAILED){s2.push(s3);s3=peg$parsearray_value_list()}}else {s2=peg$c2}if(s2!==peg$FAILED){s3=peg$parsearray_value();if(s3!==peg$FAILED){if(input.charCodeAt(peg$currPos)===93){s4=peg$c9;peg$currPos++}else {s4=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c10)}}if(s4!==peg$FAILED){peg$reportedPos=s0;s1=peg$c59(s2,s3);s0=s1}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}}}}peg$cache[key]={nextPos:peg$currPos,result:s0};return s0}function peg$parsearray_value(){var s0,s1,s2,s3,s4;var key=peg$currPos*45+25,cached=peg$cache[key];if(cached){peg$currPos=cached.nextPos;return cached.result}s0=peg$currPos;s1=[];s2=peg$parsearray_sep();while(s2!==peg$FAILED){s1.push(s2);s2=peg$parsearray_sep()}if(s1!==peg$FAILED){s2=peg$parsevalue();if(s2!==peg$FAILED){s3=[];s4=peg$parsearray_sep();while(s4!==peg$FAILED){s3.push(s4);s4=peg$parsearray_sep()}if(s3!==peg$FAILED){peg$reportedPos=s0;s1=peg$c60(s2);s0=s1}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}peg$cache[key]={nextPos:peg$currPos,result:s0};return s0}function peg$parsearray_value_list(){var s0,s1,s2,s3,s4,s5,s6;var key=peg$currPos*45+26,cached=peg$cache[key];if(cached){peg$currPos=cached.nextPos;return cached.result}s0=peg$currPos;s1=[];s2=peg$parsearray_sep();while(s2!==peg$FAILED){s1.push(s2);s2=peg$parsearray_sep()}if(s1!==peg$FAILED){s2=peg$parsevalue();if(s2!==peg$FAILED){s3=[];s4=peg$parsearray_sep();while(s4!==peg$FAILED){s3.push(s4);s4=peg$parsearray_sep()}if(s3!==peg$FAILED){if(input.charCodeAt(peg$currPos)===44){s4=peg$c61;peg$currPos++}else {s4=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c62)}}if(s4!==peg$FAILED){s5=[];s6=peg$parsearray_sep();while(s6!==peg$FAILED){s5.push(s6);s6=peg$parsearray_sep()}if(s5!==peg$FAILED){peg$reportedPos=s0;s1=peg$c60(s2);s0=s1}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}peg$cache[key]={nextPos:peg$currPos,result:s0};return s0}function peg$parsearray_sep(){var s0;var key=peg$currPos*45+27,cached=peg$cache[key];if(cached){peg$currPos=cached.nextPos;return cached.result}s0=peg$parseS();if(s0===peg$FAILED){s0=peg$parseNL();if(s0===peg$FAILED){s0=peg$parsecomment()}}peg$cache[key]={nextPos:peg$currPos,result:s0};return s0}function peg$parseinline_table(){var s0,s1,s2,s3,s4,s5;var key=peg$currPos*45+28,cached=peg$cache[key];if(cached){peg$currPos=cached.nextPos;return cached.result}s0=peg$currPos;if(input.charCodeAt(peg$currPos)===123){s1=peg$c63;peg$currPos++}else {s1=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c64)}}if(s1!==peg$FAILED){s2=[];s3=peg$parseS();while(s3!==peg$FAILED){s2.push(s3);s3=peg$parseS()}if(s2!==peg$FAILED){s3=[];s4=peg$parseinline_table_assignment();while(s4!==peg$FAILED){s3.push(s4);s4=peg$parseinline_table_assignment()}if(s3!==peg$FAILED){s4=[];s5=peg$parseS();while(s5!==peg$FAILED){s4.push(s5);s5=peg$parseS()}if(s4!==peg$FAILED){if(input.charCodeAt(peg$currPos)===125){s5=peg$c65;peg$currPos++}else {s5=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c66)}}if(s5!==peg$FAILED){peg$reportedPos=s0;s1=peg$c67(s3);s0=s1}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}peg$cache[key]={nextPos:peg$currPos,result:s0};return s0}function peg$parseinline_table_assignment(){var s0,s1,s2,s3,s4,s5,s6,s7,s8,s9,s10;var key=peg$currPos*45+29,cached=peg$cache[key];if(cached){peg$currPos=cached.nextPos;return cached.result}s0=peg$currPos;s1=[];s2=peg$parseS();while(s2!==peg$FAILED){s1.push(s2);s2=peg$parseS()}if(s1!==peg$FAILED){s2=peg$parsekey();if(s2!==peg$FAILED){s3=[];s4=peg$parseS();while(s4!==peg$FAILED){s3.push(s4);s4=peg$parseS()}if(s3!==peg$FAILED){if(input.charCodeAt(peg$currPos)===61){s4=peg$c18;peg$currPos++}else {s4=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c19)}}if(s4!==peg$FAILED){s5=[];s6=peg$parseS();while(s6!==peg$FAILED){s5.push(s6);s6=peg$parseS()}if(s5!==peg$FAILED){s6=peg$parsevalue();if(s6!==peg$FAILED){s7=[];s8=peg$parseS();while(s8!==peg$FAILED){s7.push(s8);s8=peg$parseS()}if(s7!==peg$FAILED){if(input.charCodeAt(peg$currPos)===44){s8=peg$c61;peg$currPos++}else {s8=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c62)}}if(s8!==peg$FAILED){s9=[];s10=peg$parseS();while(s10!==peg$FAILED){s9.push(s10);s10=peg$parseS()}if(s9!==peg$FAILED){peg$reportedPos=s0;s1=peg$c68(s2,s6);s0=s1}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}if(s0===peg$FAILED){s0=peg$currPos;s1=[];s2=peg$parseS();while(s2!==peg$FAILED){s1.push(s2);s2=peg$parseS()}if(s1!==peg$FAILED){s2=peg$parsekey();if(s2!==peg$FAILED){s3=[];s4=peg$parseS();while(s4!==peg$FAILED){s3.push(s4);s4=peg$parseS()}if(s3!==peg$FAILED){if(input.charCodeAt(peg$currPos)===61){s4=peg$c18;peg$currPos++}else {s4=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c19)}}if(s4!==peg$FAILED){s5=[];s6=peg$parseS();while(s6!==peg$FAILED){s5.push(s6);s6=peg$parseS()}if(s5!==peg$FAILED){s6=peg$parsevalue();if(s6!==peg$FAILED){peg$reportedPos=s0;s1=peg$c68(s2,s6);s0=s1}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}}peg$cache[key]={nextPos:peg$currPos,result:s0};return s0}function peg$parsesecfragment(){var s0,s1,s2;var key=peg$currPos*45+30,cached=peg$cache[key];if(cached){peg$currPos=cached.nextPos;return cached.result}s0=peg$currPos;if(input.charCodeAt(peg$currPos)===46){s1=peg$c16;peg$currPos++}else {s1=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c17)}}if(s1!==peg$FAILED){s2=peg$parseDIGITS();if(s2!==peg$FAILED){peg$reportedPos=s0;s1=peg$c69(s2);s0=s1}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}peg$cache[key]={nextPos:peg$currPos,result:s0};return s0}function peg$parsedate(){var s0,s1,s2,s3,s4,s5,s6,s7,s8,s9,s10,s11;var key=peg$currPos*45+31,cached=peg$cache[key];if(cached){peg$currPos=cached.nextPos;return cached.result}s0=peg$currPos;s1=peg$currPos;s2=peg$parseDIGIT_OR_UNDER();if(s2!==peg$FAILED){s3=peg$parseDIGIT_OR_UNDER();if(s3!==peg$FAILED){s4=peg$parseDIGIT_OR_UNDER();if(s4!==peg$FAILED){s5=peg$parseDIGIT_OR_UNDER();if(s5!==peg$FAILED){if(input.charCodeAt(peg$currPos)===45){s6=peg$c46;peg$currPos++}else {s6=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c47)}}if(s6!==peg$FAILED){s7=peg$parseDIGIT_OR_UNDER();if(s7!==peg$FAILED){s8=peg$parseDIGIT_OR_UNDER();if(s8!==peg$FAILED){if(input.charCodeAt(peg$currPos)===45){s9=peg$c46;peg$currPos++}else {s9=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c47)}}if(s9!==peg$FAILED){s10=peg$parseDIGIT_OR_UNDER();if(s10!==peg$FAILED){s11=peg$parseDIGIT_OR_UNDER();if(s11!==peg$FAILED){s2=[s2,s3,s4,s5,s6,s7,s8,s9,s10,s11];s1=s2}else {peg$currPos=s1;s1=peg$c2}}else {peg$currPos=s1;s1=peg$c2}}else {peg$currPos=s1;s1=peg$c2}}else {peg$currPos=s1;s1=peg$c2}}else {peg$currPos=s1;s1=peg$c2}}else {peg$currPos=s1;s1=peg$c2}}else {peg$currPos=s1;s1=peg$c2}}else {peg$currPos=s1;s1=peg$c2}}else {peg$currPos=s1;s1=peg$c2}}else {peg$currPos=s1;s1=peg$c2}if(s1!==peg$FAILED){peg$reportedPos=s0;s1=peg$c70(s1)}s0=s1;peg$cache[key]={nextPos:peg$currPos,result:s0};return s0}function peg$parsetime(){var s0,s1,s2,s3,s4,s5,s6,s7,s8,s9,s10;var key=peg$currPos*45+32,cached=peg$cache[key];if(cached){peg$currPos=cached.nextPos;return cached.result}s0=peg$currPos;s1=peg$currPos;s2=peg$parseDIGIT_OR_UNDER();if(s2!==peg$FAILED){s3=peg$parseDIGIT_OR_UNDER();if(s3!==peg$FAILED){if(input.charCodeAt(peg$currPos)===58){s4=peg$c71;peg$currPos++}else {s4=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c72)}}if(s4!==peg$FAILED){s5=peg$parseDIGIT_OR_UNDER();if(s5!==peg$FAILED){s6=peg$parseDIGIT_OR_UNDER();if(s6!==peg$FAILED){if(input.charCodeAt(peg$currPos)===58){s7=peg$c71;peg$currPos++}else {s7=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c72)}}if(s7!==peg$FAILED){s8=peg$parseDIGIT_OR_UNDER();if(s8!==peg$FAILED){s9=peg$parseDIGIT_OR_UNDER();if(s9!==peg$FAILED){s10=peg$parsesecfragment();if(s10===peg$FAILED){s10=peg$c27}if(s10!==peg$FAILED){s2=[s2,s3,s4,s5,s6,s7,s8,s9,s10];s1=s2}else {peg$currPos=s1;s1=peg$c2}}else {peg$currPos=s1;s1=peg$c2}}else {peg$currPos=s1;s1=peg$c2}}else {peg$currPos=s1;s1=peg$c2}}else {peg$currPos=s1;s1=peg$c2}}else {peg$currPos=s1;s1=peg$c2}}else {peg$currPos=s1;s1=peg$c2}}else {peg$currPos=s1;s1=peg$c2}}else {peg$currPos=s1;s1=peg$c2}if(s1!==peg$FAILED){peg$reportedPos=s0;s1=peg$c73(s1)}s0=s1;peg$cache[key]={nextPos:peg$currPos,result:s0};return s0}function peg$parsetime_with_offset(){var s0,s1,s2,s3,s4,s5,s6,s7,s8,s9,s10,s11,s12,s13,s14,s15,s16;var key=peg$currPos*45+33,cached=peg$cache[key];if(cached){peg$currPos=cached.nextPos;return cached.result}s0=peg$currPos;s1=peg$currPos;s2=peg$parseDIGIT_OR_UNDER();if(s2!==peg$FAILED){s3=peg$parseDIGIT_OR_UNDER();if(s3!==peg$FAILED){if(input.charCodeAt(peg$currPos)===58){s4=peg$c71;peg$currPos++}else {s4=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c72)}}if(s4!==peg$FAILED){s5=peg$parseDIGIT_OR_UNDER();if(s5!==peg$FAILED){s6=peg$parseDIGIT_OR_UNDER();if(s6!==peg$FAILED){if(input.charCodeAt(peg$currPos)===58){s7=peg$c71;peg$currPos++}else {s7=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c72)}}if(s7!==peg$FAILED){s8=peg$parseDIGIT_OR_UNDER();if(s8!==peg$FAILED){s9=peg$parseDIGIT_OR_UNDER();if(s9!==peg$FAILED){s10=peg$parsesecfragment();if(s10===peg$FAILED){s10=peg$c27}if(s10!==peg$FAILED){if(input.charCodeAt(peg$currPos)===45){s11=peg$c46;peg$currPos++}else {s11=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c47)}}if(s11===peg$FAILED){if(input.charCodeAt(peg$currPos)===43){s11=peg$c43;peg$currPos++}else {s11=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c44)}}}if(s11!==peg$FAILED){s12=peg$parseDIGIT_OR_UNDER();if(s12!==peg$FAILED){s13=peg$parseDIGIT_OR_UNDER();if(s13!==peg$FAILED){if(input.charCodeAt(peg$currPos)===58){s14=peg$c71;peg$currPos++}else {s14=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c72)}}if(s14!==peg$FAILED){s15=peg$parseDIGIT_OR_UNDER();if(s15!==peg$FAILED){s16=peg$parseDIGIT_OR_UNDER();if(s16!==peg$FAILED){s2=[s2,s3,s4,s5,s6,s7,s8,s9,s10,s11,s12,s13,s14,s15,s16];s1=s2}else {peg$currPos=s1;s1=peg$c2}}else {peg$currPos=s1;s1=peg$c2}}else {peg$currPos=s1;s1=peg$c2}}else {peg$currPos=s1;s1=peg$c2}}else {peg$currPos=s1;s1=peg$c2}}else {peg$currPos=s1;s1=peg$c2}}else {peg$currPos=s1;s1=peg$c2}}else {peg$currPos=s1;s1=peg$c2}}else {peg$currPos=s1;s1=peg$c2}}else {peg$currPos=s1;s1=peg$c2}}else {peg$currPos=s1;s1=peg$c2}}else {peg$currPos=s1;s1=peg$c2}}else {peg$currPos=s1;s1=peg$c2}}else {peg$currPos=s1;s1=peg$c2}}else {peg$currPos=s1;s1=peg$c2}if(s1!==peg$FAILED){peg$reportedPos=s0;s1=peg$c73(s1)}s0=s1;peg$cache[key]={nextPos:peg$currPos,result:s0};return s0}function peg$parsedatetime(){var s0,s1,s2,s3,s4;var key=peg$currPos*45+34,cached=peg$cache[key];if(cached){peg$currPos=cached.nextPos;return cached.result}s0=peg$currPos;s1=peg$parsedate();if(s1!==peg$FAILED){if(input.charCodeAt(peg$currPos)===84){s2=peg$c74;peg$currPos++}else {s2=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c75)}}if(s2!==peg$FAILED){s3=peg$parsetime();if(s3!==peg$FAILED){if(input.charCodeAt(peg$currPos)===90){s4=peg$c76;peg$currPos++}else {s4=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c77)}}if(s4!==peg$FAILED){peg$reportedPos=s0;s1=peg$c78(s1,s3);s0=s1}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}if(s0===peg$FAILED){s0=peg$currPos;s1=peg$parsedate();if(s1!==peg$FAILED){if(input.charCodeAt(peg$currPos)===84){s2=peg$c74;peg$currPos++}else {s2=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c75)}}if(s2!==peg$FAILED){s3=peg$parsetime_with_offset();if(s3!==peg$FAILED){peg$reportedPos=s0;s1=peg$c79(s1,s3);s0=s1}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}}peg$cache[key]={nextPos:peg$currPos,result:s0};return s0}function peg$parseS(){var s0;var key=peg$currPos*45+35,cached=peg$cache[key];if(cached){peg$currPos=cached.nextPos;return cached.result}if(peg$c80.test(input.charAt(peg$currPos))){s0=input.charAt(peg$currPos);peg$currPos++}else {s0=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c81)}}peg$cache[key]={nextPos:peg$currPos,result:s0};return s0}function peg$parseNL(){var s0,s1,s2;var key=peg$currPos*45+36,cached=peg$cache[key];if(cached){peg$currPos=cached.nextPos;return cached.result}if(input.charCodeAt(peg$currPos)===10){s0=peg$c82;peg$currPos++}else {s0=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c83)}}if(s0===peg$FAILED){s0=peg$currPos;if(input.charCodeAt(peg$currPos)===13){s1=peg$c84;peg$currPos++}else {s1=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c85)}}if(s1!==peg$FAILED){if(input.charCodeAt(peg$currPos)===10){s2=peg$c82;peg$currPos++}else {s2=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c83)}}if(s2!==peg$FAILED){s1=[s1,s2];s0=s1}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}}peg$cache[key]={nextPos:peg$currPos,result:s0};return s0}function peg$parseNLS(){var s0;var key=peg$currPos*45+37,cached=peg$cache[key];if(cached){peg$currPos=cached.nextPos;return cached.result}s0=peg$parseNL();if(s0===peg$FAILED){s0=peg$parseS()}peg$cache[key]={nextPos:peg$currPos,result:s0};return s0}function peg$parseEOF(){var s0,s1;var key=peg$currPos*45+38,cached=peg$cache[key];if(cached){peg$currPos=cached.nextPos;return cached.result}s0=peg$currPos;peg$silentFails++;if(input.length>peg$currPos){s1=input.charAt(peg$currPos);peg$currPos++}else {s1=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c6)}}peg$silentFails--;if(s1===peg$FAILED){s0=peg$c5}else {peg$currPos=s0;s0=peg$c2}peg$cache[key]={nextPos:peg$currPos,result:s0};return s0}function peg$parseHEX(){var s0;var key=peg$currPos*45+39,cached=peg$cache[key];if(cached){peg$currPos=cached.nextPos;return cached.result}if(peg$c86.test(input.charAt(peg$currPos))){s0=input.charAt(peg$currPos);peg$currPos++}else {s0=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c87)}}peg$cache[key]={nextPos:peg$currPos,result:s0};return s0}function peg$parseDIGIT_OR_UNDER(){var s0,s1;var key=peg$currPos*45+40,cached=peg$cache[key];if(cached){peg$currPos=cached.nextPos;return cached.result}if(peg$c88.test(input.charAt(peg$currPos))){s0=input.charAt(peg$currPos);peg$currPos++}else {s0=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c89)}}if(s0===peg$FAILED){s0=peg$currPos;if(input.charCodeAt(peg$currPos)===95){s1=peg$c90;peg$currPos++}else {s1=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c91)}}if(s1!==peg$FAILED){peg$reportedPos=s0;s1=peg$c92()}s0=s1}peg$cache[key]={nextPos:peg$currPos,result:s0};return s0}function peg$parseASCII_BASIC(){var s0;var key=peg$currPos*45+41,cached=peg$cache[key];if(cached){peg$currPos=cached.nextPos;return cached.result}if(peg$c93.test(input.charAt(peg$currPos))){s0=input.charAt(peg$currPos);peg$currPos++}else {s0=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c94)}}peg$cache[key]={nextPos:peg$currPos,result:s0};return s0}function peg$parseDIGITS(){var s0,s1,s2;var key=peg$currPos*45+42,cached=peg$cache[key];if(cached){peg$currPos=cached.nextPos;return cached.result}s0=peg$currPos;s1=[];s2=peg$parseDIGIT_OR_UNDER();if(s2!==peg$FAILED){while(s2!==peg$FAILED){s1.push(s2);s2=peg$parseDIGIT_OR_UNDER()}}else {s1=peg$c2}if(s1!==peg$FAILED){peg$reportedPos=s0;s1=peg$c95(s1)}s0=s1;peg$cache[key]={nextPos:peg$currPos,result:s0};return s0}function peg$parseESCAPED(){var s0,s1;var key=peg$currPos*45+43,cached=peg$cache[key];if(cached){peg$currPos=cached.nextPos;return cached.result}s0=peg$currPos;if(input.substr(peg$currPos,2)===peg$c96){s1=peg$c96;peg$currPos+=2}else {s1=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c97)}}if(s1!==peg$FAILED){peg$reportedPos=s0;s1=peg$c98()}s0=s1;if(s0===peg$FAILED){s0=peg$currPos;if(input.substr(peg$currPos,2)===peg$c99){s1=peg$c99;peg$currPos+=2}else {s1=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c100)}}if(s1!==peg$FAILED){peg$reportedPos=s0;s1=peg$c101()}s0=s1;if(s0===peg$FAILED){s0=peg$currPos;if(input.substr(peg$currPos,2)===peg$c102){s1=peg$c102;peg$currPos+=2}else {s1=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c103)}}if(s1!==peg$FAILED){peg$reportedPos=s0;s1=peg$c104()}s0=s1;if(s0===peg$FAILED){s0=peg$currPos;if(input.substr(peg$currPos,2)===peg$c105){s1=peg$c105;peg$currPos+=2}else {s1=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c106)}}if(s1!==peg$FAILED){peg$reportedPos=s0;s1=peg$c107()}s0=s1;if(s0===peg$FAILED){s0=peg$currPos;if(input.substr(peg$currPos,2)===peg$c108){s1=peg$c108;peg$currPos+=2}else {s1=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c109)}}if(s1!==peg$FAILED){peg$reportedPos=s0;s1=peg$c110()}s0=s1;if(s0===peg$FAILED){s0=peg$currPos;if(input.substr(peg$currPos,2)===peg$c111){s1=peg$c111;peg$currPos+=2}else {s1=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c112)}}if(s1!==peg$FAILED){peg$reportedPos=s0;s1=peg$c113()}s0=s1;if(s0===peg$FAILED){s0=peg$currPos;if(input.substr(peg$currPos,2)===peg$c114){s1=peg$c114;peg$currPos+=2}else {s1=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c115)}}if(s1!==peg$FAILED){peg$reportedPos=s0;s1=peg$c116()}s0=s1;if(s0===peg$FAILED){s0=peg$parseESCAPED_UNICODE()}}}}}}}peg$cache[key]={nextPos:peg$currPos,result:s0};return s0}function peg$parseESCAPED_UNICODE(){var s0,s1,s2,s3,s4,s5,s6,s7,s8,s9,s10;var key=peg$currPos*45+44,cached=peg$cache[key];if(cached){peg$currPos=cached.nextPos;return cached.result}s0=peg$currPos;if(input.substr(peg$currPos,2)===peg$c117){s1=peg$c117;peg$currPos+=2}else {s1=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c118)}}if(s1!==peg$FAILED){s2=peg$currPos;s3=peg$parseHEX();if(s3!==peg$FAILED){s4=peg$parseHEX();if(s4!==peg$FAILED){s5=peg$parseHEX();if(s5!==peg$FAILED){s6=peg$parseHEX();if(s6!==peg$FAILED){s7=peg$parseHEX();if(s7!==peg$FAILED){s8=peg$parseHEX();if(s8!==peg$FAILED){s9=peg$parseHEX();if(s9!==peg$FAILED){s10=peg$parseHEX();if(s10!==peg$FAILED){s3=[s3,s4,s5,s6,s7,s8,s9,s10];s2=s3}else {peg$currPos=s2;s2=peg$c2}}else {peg$currPos=s2;s2=peg$c2}}else {peg$currPos=s2;s2=peg$c2}}else {peg$currPos=s2;s2=peg$c2}}else {peg$currPos=s2;s2=peg$c2}}else {peg$currPos=s2;s2=peg$c2}}else {peg$currPos=s2;s2=peg$c2}}else {peg$currPos=s2;s2=peg$c2}if(s2!==peg$FAILED){peg$reportedPos=s0;s1=peg$c119(s2);s0=s1}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}if(s0===peg$FAILED){s0=peg$currPos;if(input.substr(peg$currPos,2)===peg$c120){s1=peg$c120;peg$currPos+=2}else {s1=peg$FAILED;if(peg$silentFails===0){peg$fail(peg$c121)}}if(s1!==peg$FAILED){s2=peg$currPos;s3=peg$parseHEX();if(s3!==peg$FAILED){s4=peg$parseHEX();if(s4!==peg$FAILED){s5=peg$parseHEX();if(s5!==peg$FAILED){s6=peg$parseHEX();if(s6!==peg$FAILED){s3=[s3,s4,s5,s6];s2=s3}else {peg$currPos=s2;s2=peg$c2}}else {peg$currPos=s2;s2=peg$c2}}else {peg$currPos=s2;s2=peg$c2}}else {peg$currPos=s2;s2=peg$c2}if(s2!==peg$FAILED){peg$reportedPos=s0;s1=peg$c119(s2);s0=s1}else {peg$currPos=s0;s0=peg$c2}}else {peg$currPos=s0;s0=peg$c2}}peg$cache[key]={nextPos:peg$currPos,result:s0};return s0}var nodes=[];function genError(err,line,col){var ex=new Error(err);ex.line=line;ex.column=col;throw ex}function addNode(node){nodes.push(node)}function node(type,value,line,column,key){var obj={type:type,value:value,line:line(),column:column()};if(key)obj.key=key;return obj}function convertCodePoint(str,line,col){var num=parseInt("0x"+str);if(!isFinite(num)||Math.floor(num)!=num||num<0||num>0x10FFFF||num>0xD7FF&&num<0xE000){genError("Invalid Unicode escape code: "+str,line,col)}else {return fromCodePoint(num)}}function fromCodePoint(){var MAX_SIZE=0x4000;var codeUnits=[];var highSurrogate;var lowSurrogate;var index=-1;var length=arguments.length;if(!length){return ''}var result='';while(++index<length){var codePoint=Number(arguments[index]);if(codePoint<=0xFFFF){ // BMP code point
	codeUnits.push(codePoint)}else { // Astral code point; split in surrogate halves
	// http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
	codePoint-=0x10000;highSurrogate=(codePoint>>10)+0xD800;lowSurrogate=codePoint%0x400+0xDC00;codeUnits.push(highSurrogate,lowSurrogate)}if(index+1==length||codeUnits.length>MAX_SIZE){result+=String.fromCharCode.apply(null,codeUnits);codeUnits.length=0}}return result}peg$result=peg$startRuleFunction();if(peg$result!==peg$FAILED&&peg$currPos===input.length){return peg$result}else {if(peg$result!==peg$FAILED&&peg$currPos<input.length){peg$fail({type:"end",description:"end of input"})}throw peg$buildException(null,peg$maxFailExpected,peg$maxFailPos)}}return {SyntaxError:SyntaxError,parse:parse}})();

/***/ },
/* 53 */
/***/ function(module, exports) {

	function compile(nodes) {
	  "use strict";

	  var assignedPaths = [];
	  var valueAssignments = [];
	  var currentPath = "";
	  var data = {};
	  var context = data;
	  var arrayMode = false;

	  return reduce(nodes);

	  function reduce(nodes) {
	    var node;
	    for (var i in nodes) {
	      node = nodes[i];
	      switch (node.type) {
	        case "Assign":
	          assign(node);
	          break;
	        case "ObjectPath":
	          setPath(node);
	          break;
	        case "ArrayPath":
	          addTableArray(node);
	          break;
	      }
	    }

	    return data;
	  }

	  function genError(err, line, col) {
	    var ex = new Error(err);
	    ex.line = line;
	    ex.column = col;
	    throw ex;
	  }

	  function assign(node) {
	    var key = node.key;
	    var value = node.value;
	    var line = node.line;
	    var column = node.column;

	    var fullPath;
	    if (currentPath) {
	      fullPath = currentPath + "." + key;
	    } else {
	      fullPath = key;
	    }
	    if (typeof context[key] !== "undefined") {
	      genError("Cannot redefine existing key '" + fullPath + "'.", line, column);
	    }

	    context[key] = reduceValueNode(value);

	    if (!pathAssigned(fullPath)) {
	      assignedPaths.push(fullPath);
	      valueAssignments.push(fullPath);
	    }
	  }

	  function pathAssigned(path) {
	    return assignedPaths.indexOf(path) !== -1;
	  }

	  function reduceValueNode(node) {
	    if (node.type === "Array") {
	      return reduceArrayWithTypeChecking(node.value);
	    } else if (node.type === "InlineTable") {
	      return reduceInlineTableNode(node.value);
	    } else {
	      return node.value;
	    }
	  }

	  function reduceInlineTableNode(values) {
	    var obj = {};
	    for (var i = 0; i < values.length; i++) {
	      var val = values[i];
	      if (val.value.type === "InlineTable") {
	        obj[val.key] = reduceInlineTableNode(val.value.value);
	      } else if (val.type === "InlineTableValue") {
	        obj[val.key] = reduceValueNode(val.value);
	      }
	    }

	    return obj;
	  }

	  function setPath(node) {
	    var path = node.value;
	    var quotedPath = path.map(quoteDottedString).join(".");
	    var line = node.line;
	    var column = node.column;

	    if (pathAssigned(quotedPath)) {
	      genError("Cannot redefine existing key '" + path + "'.", line, column);
	    }
	    assignedPaths.push(quotedPath);
	    context = deepRef(data, path, {}, line, column);
	    currentPath = path;
	  }

	  function addTableArray(node) {
	    var path = node.value;
	    var quotedPath = path.map(quoteDottedString).join(".");
	    var line = node.line;
	    var column = node.column;

	    if (!pathAssigned(quotedPath)) {
	      assignedPaths.push(quotedPath);
	    }
	    assignedPaths = assignedPaths.filter(function (p) {
	      return p.indexOf(quotedPath) !== 0;
	    });
	    assignedPaths.push(quotedPath);
	    context = deepRef(data, path, [], line, column);
	    currentPath = quotedPath;

	    if (context instanceof Array) {
	      var newObj = {};
	      context.push(newObj);
	      context = newObj;
	    } else {
	      genError("Cannot redefine existing key '" + path + "'.", line, column);
	    }
	  }

	  // Given a path 'a.b.c', create (as necessary) `start.a`,
	  // `start.a.b`, and `start.a.b.c`, assigning `value` to `start.a.b.c`.
	  // If `a` or `b` are arrays and have items in them, the last item in the
	  // array is used as the context for the next sub-path.
	  function deepRef(start, keys, value, line, column) {
	    var key;
	    var traversed = [];
	    var traversedPath = "";
	    var path = keys.join(".");
	    var ctx = start;
	    var keysLen = keys.length;

	    for (var i in keys) {
	      key = keys[i];
	      traversed.push(key);
	      traversedPath = traversed.join(".");
	      if (typeof ctx[key] === "undefined") {
	        if (i === String(keysLen - 1)) {
	          ctx[key] = value;
	        } else {
	          ctx[key] = {};
	        }
	      } else if (i !== keysLen - 1 && valueAssignments.indexOf(traversedPath) > -1) {
	        // already a non-object value at key, can't be used as part of a new path
	        genError("Cannot redefine existing key '" + traversedPath + "'.", line, column);
	      }

	      ctx = ctx[key];
	      if (ctx instanceof Array && ctx.length && i < keys.length - 1) {
	        ctx = ctx[ctx.length - 1];
	      }
	    }

	    return ctx;
	  }

	  function reduceArrayWithTypeChecking(array) {
	    // Ensure that all items in the array are of the same type
	    var firstType = null;
	    for (var i in array) {
	      var node = array[i];
	      if (firstType === null) {
	        firstType = node.type;
	      } else {
	        if (node.type !== firstType) {
	          genError("Cannot add value of type " + node.type + " to array of type " + firstType + ".", node.line, node.column);
	        }
	      }
	    }

	    // Recursively reduce array of nodes into array of the nodes' values
	    return array.map(reduceValueNode);
	  }

	  function quoteDottedString(str) {
	    if (str.indexOf(".") > -1) {
	      return "\"" + str + "\"";
	    } else {
	      return str;
	    }
	  }
	}

	module.exports = {
	  compile: compile
	};

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	/* doT + auto-compilation of doT templates
	 *
	 * 2012, Laura Doktorova, https://github.com/olado/doT
	 * Licensed under the MIT license
	 *
	 * Compiles .def, .dot, .jst files found under the specified path.
	 * It ignores sub-directories.
	 * Template files can have multiple extensions at the same time.
	 * Files with .def extension can be included in other files via {{#def.name}}
	 * Files with .dot extension are compiled into functions with the same name and
	 * can be accessed as renderer.filename
	 * Files with .jst extension are compiled into .js files. Produced .js file can be
	 * loaded as a commonJS, AMD module, or just installed into a global variable
	 * (default is set to window.render).
	 * All inline defines defined in the .jst file are
	 * compiled into separate functions and are available via _render.filename.definename
	 *
	 * Basic usage:
	 * var dots = require("dot").process({path: "./views"});
	 * dots.mytemplate({foo:"hello world"});
	 *
	 * The above snippet will:
	 * 1. Compile all templates in views folder (.dot, .def, .jst)
	 * 2. Place .js files compiled from .jst templates into the same folder.
	 *    These files can be used with require, i.e. require("./views/mytemplate").
	 * 3. Return an object with functions compiled from .dot templates as its properties.
	 * 4. Render mytemplate template.
	 */

	var fs = __webpack_require__(11),
	    doT = module.exports = __webpack_require__(55);

	doT.process = function (options) {
		//path, destination, global, rendermodule, templateSettings
		return new InstallDots(options).compileAll();
	};

	function InstallDots(o) {
		this.__path = o.path || "./";
		if (this.__path[this.__path.length - 1] !== '/') this.__path += '/';
		this.__destination = o.destination || this.__path;
		if (this.__destination[this.__destination.length - 1] !== '/') this.__destination += '/';
		this.__global = o.global || "window.render";
		this.__rendermodule = o.rendermodule || {};
		this.__settings = o.templateSettings ? copy(o.templateSettings, copy(doT.templateSettings)) : undefined;
		this.__includes = {};
	}

	InstallDots.prototype.compileToFile = function (path, template, def) {
		def = def || {};
		var modulename = path.substring(path.lastIndexOf("/") + 1, path.lastIndexOf(".")),
		    defs = copy(this.__includes, copy(def)),
		    settings = this.__settings || doT.templateSettings,
		    compileoptions = copy(settings),
		    defaultcompiled = doT.template(template, settings, defs),
		    exports = [],
		    compiled = "",
		    fn;

		for (var property in defs) {
			if (defs[property] !== def[property] && defs[property] !== this.__includes[property]) {
				fn = undefined;
				if (typeof defs[property] === 'string') {
					fn = doT.template(defs[property], settings, defs);
				} else if (typeof defs[property] === 'function') {
					fn = defs[property];
				} else if (defs[property].arg) {
					compileoptions.varname = defs[property].arg;
					fn = doT.template(defs[property].text, compileoptions, defs);
				}
				if (fn) {
					compiled += fn.toString().replace('anonymous', property);
					exports.push(property);
				}
			}
		}
		compiled += defaultcompiled.toString().replace('anonymous', modulename);
		fs.writeFileSync(path, "(function(){" + compiled + "var itself=" + modulename + ", _encodeHTML=(" + doT.encodeHTMLSource.toString() + "(" + (settings.doNotSkipEncoded || '') + "));" + addexports(exports) + "if(typeof module!=='undefined' && module.exports) module.exports=itself;else if(typeof define==='function')define(function(){return itself;});else {" + this.__global + "=" + this.__global + "||{};" + this.__global + "['" + modulename + "']=itself;}}());");
	};

	function addexports(exports) {
		for (var ret = '', i = 0; i < exports.length; i++) {
			ret += "itself." + exports[i] + "=" + exports[i] + ";";
		}
		return ret;
	}

	function copy(o, to) {
		to = to || {};
		for (var property in o) {
			to[property] = o[property];
		}
		return to;
	}

	function readdata(path) {
		var data = fs.readFileSync(path);
		if (data) return data.toString();
		console.log("problems with " + path);
	}

	InstallDots.prototype.compilePath = function (path) {
		var data = readdata(path);
		if (data) {
			return doT.template(data, this.__settings || doT.templateSettings, copy(this.__includes));
		}
	};

	InstallDots.prototype.compileAll = function () {
		console.log("Compiling all doT templates...");

		var defFolder = this.__path,
		    sources = fs.readdirSync(defFolder),
		    k,
		    l,
		    name;

		for (k = 0, l = sources.length; k < l; k++) {
			name = sources[k];
			if (/\.def(\.dot|\.jst)?$/.test(name)) {
				console.log("Loaded def " + name);
				this.__includes[name.substring(0, name.indexOf('.'))] = readdata(defFolder + name);
			}
		}

		for (k = 0, l = sources.length; k < l; k++) {
			name = sources[k];
			if (/\.dot(\.def|\.jst)?$/.test(name)) {
				console.log("Compiling " + name + " to function");
				this.__rendermodule[name.substring(0, name.indexOf('.'))] = this.compilePath(defFolder + name);
			}
			if (/\.jst(\.dot|\.def)?$/.test(name)) {
				console.log("Compiling " + name + " to file");
				this.compileToFile(this.__destination + name.substring(0, name.indexOf('.')) + '.js', readdata(defFolder + name));
			}
		}
		return this.__rendermodule;
	};

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;// doT.js
	// 2011-2014, Laura Doktorova, https://github.com/olado/doT
	// Licensed under the MIT license.

	(function () {
		"use strict";

		var doT = {
			version: "1.0.3",
			templateSettings: {
				evaluate: /\{\{([\s\S]+?(\}?)+)\}\}/g,
				interpolate: /\{\{=([\s\S]+?)\}\}/g,
				encode: /\{\{!([\s\S]+?)\}\}/g,
				use: /\{\{#([\s\S]+?)\}\}/g,
				useParams: /(^|[^\w$])def(?:\.|\[[\'\"])([\w$\.]+)(?:[\'\"]\])?\s*\:\s*([\w$\.]+|\"[^\"]+\"|\'[^\']+\'|\{[^\}]+\})/g,
				define: /\{\{##\s*([\w\.$]+)\s*(\:|=)([\s\S]+?)#\}\}/g,
				defineParams: /^\s*([\w$]+):([\s\S]+)/,
				conditional: /\{\{\?(\?)?\s*([\s\S]*?)\s*\}\}/g,
				iterate: /\{\{~\s*(?:\}\}|([\s\S]+?)\s*\:\s*([\w$]+)\s*(?:\:\s*([\w$]+))?\s*\}\})/g,
				varname: "it",
				strip: true,
				append: true,
				selfcontained: false,
				doNotSkipEncoded: false
			},
			template: undefined, //fn, compile template
			compile: undefined //fn, for express
		},
		    _globals;

		doT.encodeHTMLSource = function (doNotSkipEncoded) {
			var encodeHTMLRules = { "&": "&#38;", "<": "&#60;", ">": "&#62;", '"': "&#34;", "'": "&#39;", "/": "&#47;" },
			    matchHTML = doNotSkipEncoded ? /[&<>"'\/]/g : /&(?!#?\w+;)|<|>|"|'|\//g;
			return function (code) {
				return code ? code.toString().replace(matchHTML, function (m) {
					return encodeHTMLRules[m] || m;
				}) : "";
			};
		};

		_globals = (function () {
			return this || (0, eval)("this");
		})();

		if (typeof module !== "undefined" && module.exports) {
			module.exports = doT;
		} else if (true) {
			!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
				return doT;
			}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else {
			_globals.doT = doT;
		}

		var startend = {
			append: { start: "'+(", end: ")+'", startencode: "'+encodeHTML(" },
			split: { start: "';out+=(", end: ");out+='", startencode: "';out+=encodeHTML(" }
		},
		    skip = /$^/;

		function resolveDefs(c, block, def) {
			return (typeof block === "string" ? block : block.toString()).replace(c.define || skip, function (m, code, assign, value) {
				if (code.indexOf("def.") === 0) {
					code = code.substring(4);
				}
				if (!(code in def)) {
					if (assign === ":") {
						if (c.defineParams) value.replace(c.defineParams, function (m, param, v) {
							def[code] = { arg: param, text: v };
						});
						if (!(code in def)) def[code] = value;
					} else {
						new Function("def", "def['" + code + "']=" + value)(def);
					}
				}
				return "";
			}).replace(c.use || skip, function (m, code) {
				if (c.useParams) code = code.replace(c.useParams, function (m, s, d, param) {
					if (def[d] && def[d].arg && param) {
						var rw = (d + ":" + param).replace(/'|\\/g, "_");
						def.__exp = def.__exp || {};
						def.__exp[rw] = def[d].text.replace(new RegExp("(^|[^\\w$])" + def[d].arg + "([^\\w$])", "g"), "$1" + param + "$2");
						return s + "def.__exp['" + rw + "']";
					}
				});
				var v = new Function("def", "return " + code)(def);
				return v ? resolveDefs(c, v, def) : v;
			});
		}

		function unescape(code) {
			return code.replace(/\\('|\\)/g, "$1").replace(/[\r\t\n]/g, " ");
		}

		doT.template = function (tmpl, c, def) {
			c = c || doT.templateSettings;
			var cse = c.append ? startend.append : startend.split,
			    needhtmlencode,
			    sid = 0,
			    indv,
			    str = c.use || c.define ? resolveDefs(c, tmpl, def || {}) : tmpl;

			str = ("var out='" + (c.strip ? str.replace(/(^|\r|\n)\t* +| +\t*(\r|\n|$)/g, " ").replace(/\r|\n|\t|\/\*[\s\S]*?\*\//g, "") : str).replace(/'|\\/g, "\\$&").replace(c.interpolate || skip, function (m, code) {
				return cse.start + unescape(code) + cse.end;
			}).replace(c.encode || skip, function (m, code) {
				needhtmlencode = true;
				return cse.startencode + unescape(code) + cse.end;
			}).replace(c.conditional || skip, function (m, elsecase, code) {
				return elsecase ? code ? "';}else if(" + unescape(code) + "){out+='" : "';}else{out+='" : code ? "';if(" + unescape(code) + "){out+='" : "';}out+='";
			}).replace(c.iterate || skip, function (m, iterate, vname, iname) {
				if (!iterate) return "';} } out+='";
				sid += 1;indv = iname || "i" + sid;iterate = unescape(iterate);
				return "';var arr" + sid + "=" + iterate + ";if(arr" + sid + "){var " + vname + "," + indv + "=-1,l" + sid + "=arr" + sid + ".length-1;while(" + indv + "<l" + sid + "){" + vname + "=arr" + sid + "[" + indv + "+=1];out+='";
			}).replace(c.evaluate || skip, function (m, code) {
				return "';" + unescape(code) + "out+='";
			}) + "';return out;").replace(/\n/g, "\\n").replace(/\t/g, '\\t').replace(/\r/g, "\\r").replace(/(\s|;|\}|^|\{)out\+='';/g, '$1').replace(/\+''/g, "");
			//.replace(/(\s|;|\}|^|\{)out\+=''\+/g,'$1out+=');

			if (needhtmlencode) {
				if (!c.selfcontained && _globals && !_globals._encodeHTML) _globals._encodeHTML = doT.encodeHTMLSource(c.doNotSkipEncoded);
				str = "var encodeHTML = typeof _encodeHTML !== 'undefined' ? _encodeHTML : (" + doT.encodeHTMLSource.toString() + "(" + (c.doNotSkipEncoded || '') + "));" + str;
			}
			try {
				return new Function(c.varname, str);
			} catch (e) {
				if (typeof console !== "undefined") console.log("Could not create a template function: " + str);
				throw e;
			}
		};

		doT.compile = function (tmpl, def) {
			return doT.template(tmpl, null, def);
		};
	})();

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = __webpack_require__(57);

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	// Main perser class

	'use strict';

	var utils = __webpack_require__(58);
	var helpers = __webpack_require__(72);
	var Renderer = __webpack_require__(76);
	var ParserCore = __webpack_require__(77);
	var ParserBlock = __webpack_require__(87);
	var ParserInline = __webpack_require__(102);
	var LinkifyIt = __webpack_require__(118);
	var mdurl = __webpack_require__(62);
	var punycode = __webpack_require__(120);

	var config = {
	  'default': __webpack_require__(122),
	  zero: __webpack_require__(123),
	  commonmark: __webpack_require__(124)
	};

	////////////////////////////////////////////////////////////////////////////////
	//
	// This validator can prohibit more than really needed to prevent XSS. It's a
	// tradeoff to keep code simple and to be secure by default.
	//
	// If you need different setup - override validator method as you wish. Or
	// replace it with dummy function and use external sanitizer.
	//

	var BAD_PROTO_RE = /^(vbscript|javascript|file|data):/;
	var GOOD_DATA_RE = /^data:image\/(gif|png|jpeg|webp);/;

	function validateLink(url) {
	  // url should be normalized at this point, and existing entities are decoded
	  var str = url.trim().toLowerCase();

	  return BAD_PROTO_RE.test(str) ? GOOD_DATA_RE.test(str) ? true : false : true;
	}

	////////////////////////////////////////////////////////////////////////////////

	var RECODE_HOSTNAME_FOR = ['http:', 'https:', 'mailto:'];

	function normalizeLink(url) {
	  var parsed = mdurl.parse(url, true);

	  if (parsed.hostname) {
	    // Encode hostnames in urls like:
	    // `http://host/`, `https://host/`, `mailto:user@host`, `//host/`
	    //
	    // We don't encode unknown schemas, because it's likely that we encode
	    // something we shouldn't (e.g. `skype:name` treated as `skype:host`)
	    //
	    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
	      try {
	        parsed.hostname = punycode.toASCII(parsed.hostname);
	      } catch (er) {/**/}
	    }
	  }

	  return mdurl.encode(mdurl.format(parsed));
	}

	function normalizeLinkText(url) {
	  var parsed = mdurl.parse(url, true);

	  if (parsed.hostname) {
	    // Encode hostnames in urls like:
	    // `http://host/`, `https://host/`, `mailto:user@host`, `//host/`
	    //
	    // We don't encode unknown schemas, because it's likely that we encode
	    // something we shouldn't (e.g. `skype:name` treated as `skype:host`)
	    //
	    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
	      try {
	        parsed.hostname = punycode.toUnicode(parsed.hostname);
	      } catch (er) {/**/}
	    }
	  }

	  return mdurl.decode(mdurl.format(parsed));
	}

	/**
	 * class MarkdownIt
	 *
	 * Main parser/renderer class.
	 *
	 * ##### Usage
	 *
	 * ```javascript
	 * // node.js, "classic" way:
	 * var MarkdownIt = require('markdown-it'),
	 *     md = new MarkdownIt();
	 * var result = md.render('# markdown-it rulezz!');
	 *
	 * // node.js, the same, but with sugar:
	 * var md = require('markdown-it')();
	 * var result = md.render('# markdown-it rulezz!');
	 *
	 * // browser without AMD, added to "window" on script load
	 * // Note, there are no dash.
	 * var md = window.markdownit();
	 * var result = md.render('# markdown-it rulezz!');
	 * ```
	 *
	 * Single line rendering, without paragraph wrap:
	 *
	 * ```javascript
	 * var md = require('markdown-it')();
	 * var result = md.renderInline('__markdown-it__ rulezz!');
	 * ```
	 **/

	/**
	 * new MarkdownIt([presetName, options])
	 * - presetName (String): optional, `commonmark` / `zero`
	 * - options (Object)
	 *
	 * Creates parser instanse with given config. Can be called without `new`.
	 *
	 * ##### presetName
	 *
	 * MarkdownIt provides named presets as a convenience to quickly
	 * enable/disable active syntax rules and options for common use cases.
	 *
	 * - ["commonmark"](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/commonmark.js) -
	 *   configures parser to strict [CommonMark](http://commonmark.org/) mode.
	 * - [default](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/default.js) -
	 *   similar to GFM, used when no preset name given. Enables all available rules,
	 *   but still without html, typographer & autolinker.
	 * - ["zero"](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/zero.js) -
	 *   all rules disabled. Useful to quickly setup your config via `.enable()`.
	 *   For example, when you need only `bold` and `italic` markup and nothing else.
	 *
	 * ##### options:
	 *
	 * - __html__ - `false`. Set `true` to enable HTML tags in source. Be careful!
	 *   That's not safe! You may need external sanitizer to protect output from XSS.
	 *   It's better to extend features via plugins, instead of enabling HTML.
	 * - __xhtmlOut__ - `false`. Set `true` to add '/' when closing single tags
	 *   (`<br />`). This is needed only for full CommonMark compatibility. In real
	 *   world you will need HTML output.
	 * - __breaks__ - `false`. Set `true` to convert `\n` in paragraphs into `<br>`.
	 * - __langPrefix__ - `language-`. CSS language class prefix for fenced blocks.
	 *   Can be useful for external highlighters.
	 * - __linkify__ - `false`. Set `true` to autoconvert URL-like text to links.
	 * - __typographer__  - `false`. Set `true` to enable [some language-neutral
	 *   replacement](https://github.com/markdown-it/markdown-it/blob/master/lib/rules_core/replacements.js) +
	 *   quotes beautification (smartquotes).
	 * - __quotes__ - ``, String or Array. Double + single quotes replacement
	 *   pairs, when typographer enabled and smartquotes on. For example, you can
	 *   use `''` for Russian, `''` for German, and
	 *   `['\xA0', '\xA0', '\xA0', '\xA0']` for French (including nbsp).
	 * - __highlight__ - `null`. Highlighter function for fenced code blocks.
	 *   Highlighter `function (str, lang)` should return escaped HTML. It can also
	 *   return empty string if the source was not changed and should be escaped externaly.
	 *
	 * ##### Example
	 *
	 * ```javascript
	 * // commonmark mode
	 * var md = require('markdown-it')('commonmark');
	 *
	 * // default mode
	 * var md = require('markdown-it')();
	 *
	 * // enable everything
	 * var md = require('markdown-it')({
	 *   html: true,
	 *   linkify: true,
	 *   typographer: true
	 * });
	 * ```
	 *
	 * ##### Syntax highlighting
	 *
	 * ```js
	 * var hljs = require('highlight.js') // https://highlightjs.org/
	 *
	 * var md = require('markdown-it')({
	 *   highlight: function (str, lang) {
	 *     if (lang && hljs.getLanguage(lang)) {
	 *       try {
	 *         return hljs.highlight(lang, str).value;
	 *       } catch (__) {}
	 *     }
	 *
	 *     try {
	 *       return hljs.highlightAuto(str).value;
	 *     } catch (__) {}
	 *
	 *     return ''; // use external default escaping
	 *   }
	 * });
	 * ```
	 **/
	function MarkdownIt(presetName, options) {
	  if (!(this instanceof MarkdownIt)) {
	    return new MarkdownIt(presetName, options);
	  }

	  if (!options) {
	    if (!utils.isString(presetName)) {
	      options = presetName || {};
	      presetName = 'default';
	    }
	  }

	  /**
	   * MarkdownIt#inline -> ParserInline
	   *
	   * Instance of [[ParserInline]]. You may need it to add new rules when
	   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and
	   * [[MarkdownIt.enable]].
	   **/
	  this.inline = new ParserInline();

	  /**
	   * MarkdownIt#block -> ParserBlock
	   *
	   * Instance of [[ParserBlock]]. You may need it to add new rules when
	   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and
	   * [[MarkdownIt.enable]].
	   **/
	  this.block = new ParserBlock();

	  /**
	   * MarkdownIt#core -> Core
	   *
	   * Instance of [[Core]] chain executor. You may need it to add new rules when
	   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and
	   * [[MarkdownIt.enable]].
	   **/
	  this.core = new ParserCore();

	  /**
	   * MarkdownIt#renderer -> Renderer
	   *
	   * Instance of [[Renderer]]. Use it to modify output look. Or to add rendering
	   * rules for new token types, generated by plugins.
	   *
	   * ##### Example
	   *
	   * ```javascript
	   * var md = require('markdown-it')();
	   *
	   * function myToken(tokens, idx, options, env, self) {
	   *   //...
	   *   return result;
	   * };
	   *
	   * md.renderer.rules['my_token'] = myToken
	   * ```
	   *
	   * See [[Renderer]] docs and [source code](https://github.com/markdown-it/markdown-it/blob/master/lib/renderer.js).
	   **/
	  this.renderer = new Renderer();

	  /**
	   * MarkdownIt#linkify -> LinkifyIt
	   *
	   * [linkify-it](https://github.com/markdown-it/linkify-it) instance.
	   * Used by [linkify](https://github.com/markdown-it/markdown-it/blob/master/lib/rules_core/linkify.js)
	   * rule.
	   **/
	  this.linkify = new LinkifyIt();

	  /**
	   * MarkdownIt#validateLink(url) -> Boolean
	   *
	   * Link validation function. CommonMark allows too much in links. By default
	   * we disable `javascript:`, `vbscript:`, `file:` schemas, and almost all `data:...` schemas
	   * except some embedded image types.
	   *
	   * You can change this behaviour:
	   *
	   * ```javascript
	   * var md = require('markdown-it')();
	   * // enable everything
	   * md.validateLink = function () { return true; }
	   * ```
	   **/
	  this.validateLink = validateLink;

	  /**
	   * MarkdownIt#normalizeLink(url) -> String
	   *
	   * Function used to encode link url to a machine-readable format,
	   * which includes url-encoding, punycode, etc.
	   **/
	  this.normalizeLink = normalizeLink;

	  /**
	   * MarkdownIt#normalizeLinkText(url) -> String
	   *
	   * Function used to decode link url to a human-readable format`
	   **/
	  this.normalizeLinkText = normalizeLinkText;

	  // Expose utils & helpers for easy acces from plugins

	  /**
	   * MarkdownIt#utils -> utils
	   *
	   * Assorted utility functions, useful to write plugins. See details
	   * [here](https://github.com/markdown-it/markdown-it/blob/master/lib/common/utils.js).
	   **/
	  this.utils = utils;

	  /**
	   * MarkdownIt#helpers -> helpers
	   *
	   * Link components parser functions, useful to write plugins. See details
	   * [here](https://github.com/markdown-it/markdown-it/blob/master/lib/helpers).
	   **/
	  this.helpers = helpers;

	  this.options = {};
	  this.configure(presetName);

	  if (options) {
	    this.set(options);
	  }
	}

	/** chainable
	 * MarkdownIt.set(options)
	 *
	 * Set parser options (in the same format as in constructor). Probably, you
	 * will never need it, but you can change options after constructor call.
	 *
	 * ##### Example
	 *
	 * ```javascript
	 * var md = require('markdown-it')()
	 *             .set({ html: true, breaks: true })
	 *             .set({ typographer, true });
	 * ```
	 *
	 * __Note:__ To achieve the best possible performance, don't modify a
	 * `markdown-it` instance options on the fly. If you need multiple configurations
	 * it's best to create multiple instances and initialize each with separate
	 * config.
	 **/
	MarkdownIt.prototype.set = function (options) {
	  utils.assign(this.options, options);
	  return this;
	};

	/** chainable, internal
	 * MarkdownIt.configure(presets)
	 *
	 * Batch load of all options and compenent settings. This is internal method,
	 * and you probably will not need it. But if you with - see available presets
	 * and data structure [here](https://github.com/markdown-it/markdown-it/tree/master/lib/presets)
	 *
	 * We strongly recommend to use presets instead of direct config loads. That
	 * will give better compatibility with next versions.
	 **/
	MarkdownIt.prototype.configure = function (presets) {
	  var self = this,
	      presetName;

	  if (utils.isString(presets)) {
	    presetName = presets;
	    presets = config[presetName];
	    if (!presets) {
	      throw new Error('Wrong `markdown-it` preset "' + presetName + '", check name');
	    }
	  }

	  if (!presets) {
	    throw new Error('Wrong `markdown-it` preset, can\'t be empty');
	  }

	  if (presets.options) {
	    self.set(presets.options);
	  }

	  if (presets.components) {
	    Object.keys(presets.components).forEach(function (name) {
	      if (presets.components[name].rules) {
	        self[name].ruler.enableOnly(presets.components[name].rules);
	      }
	      if (presets.components[name].rules2) {
	        self[name].ruler2.enableOnly(presets.components[name].rules2);
	      }
	    });
	  }
	  return this;
	};

	/** chainable
	 * MarkdownIt.enable(list, ignoreInvalid)
	 * - list (String|Array): rule name or list of rule names to enable
	 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
	 *
	 * Enable list or rules. It will automatically find appropriate components,
	 * containing rules with given names. If rule not found, and `ignoreInvalid`
	 * not set - throws exception.
	 *
	 * ##### Example
	 *
	 * ```javascript
	 * var md = require('markdown-it')()
	 *             .enable(['sub', 'sup'])
	 *             .disable('smartquotes');
	 * ```
	 **/
	MarkdownIt.prototype.enable = function (list, ignoreInvalid) {
	  var result = [];

	  if (!Array.isArray(list)) {
	    list = [list];
	  }

	  ['core', 'block', 'inline'].forEach(function (chain) {
	    result = result.concat(this[chain].ruler.enable(list, true));
	  }, this);

	  result = result.concat(this.inline.ruler2.enable(list, true));

	  var missed = list.filter(function (name) {
	    return result.indexOf(name) < 0;
	  });

	  if (missed.length && !ignoreInvalid) {
	    throw new Error('MarkdownIt. Failed to enable unknown rule(s): ' + missed);
	  }

	  return this;
	};

	/** chainable
	 * MarkdownIt.disable(list, ignoreInvalid)
	 * - list (String|Array): rule name or list of rule names to disable.
	 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
	 *
	 * The same as [[MarkdownIt.enable]], but turn specified rules off.
	 **/
	MarkdownIt.prototype.disable = function (list, ignoreInvalid) {
	  var result = [];

	  if (!Array.isArray(list)) {
	    list = [list];
	  }

	  ['core', 'block', 'inline'].forEach(function (chain) {
	    result = result.concat(this[chain].ruler.disable(list, true));
	  }, this);

	  result = result.concat(this.inline.ruler2.disable(list, true));

	  var missed = list.filter(function (name) {
	    return result.indexOf(name) < 0;
	  });

	  if (missed.length && !ignoreInvalid) {
	    throw new Error('MarkdownIt. Failed to disable unknown rule(s): ' + missed);
	  }
	  return this;
	};

	/** chainable
	 * MarkdownIt.use(plugin, params)
	 *
	 * Load specified plugin with given params into current parser instance.
	 * It's just a sugar to call `plugin(md, params)` with curring.
	 *
	 * ##### Example
	 *
	 * ```javascript
	 * var iterator = require('markdown-it-for-inline');
	 * var md = require('markdown-it')()
	 *             .use(iterator, 'foo_replace', 'text', function (tokens, idx) {
	 *               tokens[idx].content = tokens[idx].content.replace(/foo/g, 'bar');
	 *             });
	 * ```
	 **/
	MarkdownIt.prototype.use = function (plugin /*, params, ... */) {
	  var args = [this].concat(Array.prototype.slice.call(arguments, 1));
	  plugin.apply(plugin, args);
	  return this;
	};

	/** internal
	 * MarkdownIt.parse(src, env) -> Array
	 * - src (String): source string
	 * - env (Object): environment sandbox
	 *
	 * Parse input string and returns list of block tokens (special token type
	 * "inline" will contain list of inline tokens). You should not call this
	 * method directly, until you write custom renderer (for example, to produce
	 * AST).
	 *
	 * `env` is used to pass data between "distributed" rules and return additional
	 * metadata like reference info, needed for the renderer. It also can be used to
	 * inject data in specific cases. Usually, you will be ok to pass `{}`,
	 * and then pass updated object to renderer.
	 **/
	MarkdownIt.prototype.parse = function (src, env) {
	  var state = new this.core.State(src, this, env);

	  this.core.process(state);

	  return state.tokens;
	};

	/**
	 * MarkdownIt.render(src [, env]) -> String
	 * - src (String): source string
	 * - env (Object): environment sandbox
	 *
	 * Render markdown string into html. It does all magic for you :).
	 *
	 * `env` can be used to inject additional metadata (`{}` by default).
	 * But you will not need it with high probability. See also comment
	 * in [[MarkdownIt.parse]].
	 **/
	MarkdownIt.prototype.render = function (src, env) {
	  env = env || {};

	  return this.renderer.render(this.parse(src, env), this.options, env);
	};

	/** internal
	 * MarkdownIt.parseInline(src, env) -> Array
	 * - src (String): source string
	 * - env (Object): environment sandbox
	 *
	 * The same as [[MarkdownIt.parse]] but skip all block rules. It returns the
	 * block tokens list with the single `inline` element, containing parsed inline
	 * tokens in `children` property. Also updates `env` object.
	 **/
	MarkdownIt.prototype.parseInline = function (src, env) {
	  var state = new this.core.State(src, this, env);

	  state.inlineMode = true;
	  this.core.process(state);

	  return state.tokens;
	};

	/**
	 * MarkdownIt.renderInline(src [, env]) -> String
	 * - src (String): source string
	 * - env (Object): environment sandbox
	 *
	 * Similar to [[MarkdownIt.render]] but for single paragraph content. Result
	 * will NOT be wrapped into `<p>` tags.
	 **/
	MarkdownIt.prototype.renderInline = function (src, env) {
	  env = env || {};

	  return this.renderer.render(this.parseInline(src, env), this.options, env);
	};

	module.exports = MarkdownIt;

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	// Utilities
	//
	'use strict';

	function _class(obj) {
	  return Object.prototype.toString.call(obj);
	}

	function isString(obj) {
	  return _class(obj) === '[object String]';
	}

	var _hasOwnProperty = Object.prototype.hasOwnProperty;

	function has(object, key) {
	  return _hasOwnProperty.call(object, key);
	}

	// Merge objects
	//
	function assign(obj /*from1, from2, from3, ...*/) {
	  var sources = Array.prototype.slice.call(arguments, 1);

	  sources.forEach(function (source) {
	    if (!source) {
	      return;
	    }

	    if (typeof source !== 'object') {
	      throw new TypeError(source + 'must be object');
	    }

	    Object.keys(source).forEach(function (key) {
	      obj[key] = source[key];
	    });
	  });

	  return obj;
	}

	// Remove element from array and put another array at those position.
	// Useful for some operations with tokens
	function arrayReplaceAt(src, pos, newElements) {
	  return [].concat(src.slice(0, pos), newElements, src.slice(pos + 1));
	}

	////////////////////////////////////////////////////////////////////////////////

	function isValidEntityCode(c) {
	  /*eslint no-bitwise:0*/
	  // broken sequence
	  if (c >= 0xD800 && c <= 0xDFFF) {
	    return false;
	  }
	  // never used
	  if (c >= 0xFDD0 && c <= 0xFDEF) {
	    return false;
	  }
	  if ((c & 0xFFFF) === 0xFFFF || (c & 0xFFFF) === 0xFFFE) {
	    return false;
	  }
	  // control codes
	  if (c >= 0x00 && c <= 0x08) {
	    return false;
	  }
	  if (c === 0x0B) {
	    return false;
	  }
	  if (c >= 0x0E && c <= 0x1F) {
	    return false;
	  }
	  if (c >= 0x7F && c <= 0x9F) {
	    return false;
	  }
	  // out of range
	  if (c > 0x10FFFF) {
	    return false;
	  }
	  return true;
	}

	function fromCodePoint(c) {
	  /*eslint no-bitwise:0*/
	  if (c > 0xffff) {
	    c -= 0x10000;
	    var surrogate1 = 0xd800 + (c >> 10),
	        surrogate2 = 0xdc00 + (c & 0x3ff);

	    return String.fromCharCode(surrogate1, surrogate2);
	  }
	  return String.fromCharCode(c);
	}

	var UNESCAPE_MD_RE = /\\([!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~])/g;
	var ENTITY_RE = /&([a-z#][a-z0-9]{1,31});/gi;
	var UNESCAPE_ALL_RE = new RegExp(UNESCAPE_MD_RE.source + '|' + ENTITY_RE.source, 'gi');

	var DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))/i;

	var entities = __webpack_require__(59);

	function replaceEntityPattern(match, name) {
	  var code = 0;

	  if (has(entities, name)) {
	    return entities[name];
	  }

	  if (name.charCodeAt(0) === 0x23 /* # */ && DIGITAL_ENTITY_TEST_RE.test(name)) {
	    code = name[1].toLowerCase() === 'x' ? parseInt(name.slice(2), 16) : parseInt(name.slice(1), 10);
	    if (isValidEntityCode(code)) {
	      return fromCodePoint(code);
	    }
	  }

	  return match;
	}

	/*function replaceEntities(str) {
	  if (str.indexOf('&') < 0) { return str; }

	  return str.replace(ENTITY_RE, replaceEntityPattern);
	}*/

	function unescapeMd(str) {
	  if (str.indexOf('\\') < 0) {
	    return str;
	  }
	  return str.replace(UNESCAPE_MD_RE, '$1');
	}

	function unescapeAll(str) {
	  if (str.indexOf('\\') < 0 && str.indexOf('&') < 0) {
	    return str;
	  }

	  return str.replace(UNESCAPE_ALL_RE, function (match, escaped, entity) {
	    if (escaped) {
	      return escaped;
	    }
	    return replaceEntityPattern(match, entity);
	  });
	}

	////////////////////////////////////////////////////////////////////////////////

	var HTML_ESCAPE_TEST_RE = /[&<>"]/;
	var HTML_ESCAPE_REPLACE_RE = /[&<>"]/g;
	var HTML_REPLACEMENTS = {
	  '&': '&amp;',
	  '<': '&lt;',
	  '>': '&gt;',
	  '"': '&quot;'
	};

	function replaceUnsafeChar(ch) {
	  return HTML_REPLACEMENTS[ch];
	}

	function escapeHtml(str) {
	  if (HTML_ESCAPE_TEST_RE.test(str)) {
	    return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);
	  }
	  return str;
	}

	////////////////////////////////////////////////////////////////////////////////

	var REGEXP_ESCAPE_RE = /[.?*+^$[\]\\(){}|-]/g;

	function escapeRE(str) {
	  return str.replace(REGEXP_ESCAPE_RE, '\\$&');
	}

	////////////////////////////////////////////////////////////////////////////////

	function isSpace(code) {
	  switch (code) {
	    case 0x09:
	    case 0x20:
	      return true;
	  }
	  return false;
	}

	// Zs (unicode class) || [\t\f\v\r\n]
	function isWhiteSpace(code) {
	  if (code >= 0x2000 && code <= 0x200A) {
	    return true;
	  }
	  switch (code) {
	    case 0x09: // \t
	    case 0x0A: // \n
	    case 0x0B: // \v
	    case 0x0C: // \f
	    case 0x0D: // \r
	    case 0x20:
	    case 0xA0:
	    case 0x1680:
	    case 0x202F:
	    case 0x205F:
	    case 0x3000:
	      return true;
	  }
	  return false;
	}

	////////////////////////////////////////////////////////////////////////////////

	/*eslint-disable max-len*/
	var UNICODE_PUNCT_RE = __webpack_require__(61);

	// Currently without astral characters support.
	function isPunctChar(ch) {
	  return UNICODE_PUNCT_RE.test(ch);
	}

	// Markdown ASCII punctuation characters.
	//
	// !, ", #, $, %, &, ', (, ), *, +, ,, -, ., /, :, ;, <, =, >, ?, @, [, \, ], ^, _, `, {, |, }, or ~
	// http://spec.commonmark.org/0.15/#ascii-punctuation-character
	//
	// Don't confuse with unicode punctuation !!! It lacks some chars in ascii range.
	//
	function isMdAsciiPunct(ch) {
	  switch (ch) {
	    case 0x21 /* ! */:
	    case 0x22 /* " */:
	    case 0x23 /* # */:
	    case 0x24 /* $ */:
	    case 0x25 /* % */:
	    case 0x26 /* & */:
	    case 0x27 /* ' */:
	    case 0x28 /* ( */:
	    case 0x29 /* ) */:
	    case 0x2A /* * */:
	    case 0x2B /* + */:
	    case 0x2C /* , */:
	    case 0x2D /* - */:
	    case 0x2E /* . */:
	    case 0x2F /* / */:
	    case 0x3A /* : */:
	    case 0x3B /* ; */:
	    case 0x3C /* < */:
	    case 0x3D /* = */:
	    case 0x3E /* > */:
	    case 0x3F /* ? */:
	    case 0x40 /* @ */:
	    case 0x5B /* [ */:
	    case 0x5C /* \ */:
	    case 0x5D /* ] */:
	    case 0x5E /* ^ */:
	    case 0x5F /* _ */:
	    case 0x60 /* ` */:
	    case 0x7B /* { */:
	    case 0x7C /* | */:
	    case 0x7D /* } */:
	    case 0x7E /* ~ */:
	      return true;
	    default:
	      return false;
	  }
	}

	// Hepler to unify [reference labels].
	//
	function normalizeReference(str) {
	  // use .toUpperCase() instead of .toLowerCase()
	  // here to avoid a conflict with Object.prototype
	  // members (most notably, `__proto__`)
	  return str.trim().replace(/\s+/g, ' ').toUpperCase();
	}

	////////////////////////////////////////////////////////////////////////////////

	// Re-export libraries commonly used in both markdown-it and its plugins,
	// so plugins won't have to depend on them explicitly, which reduces their
	// bundled size (e.g. a browser build).
	//
	exports.lib = {};
	exports.lib.mdurl = __webpack_require__(62);
	exports.lib.ucmicro = __webpack_require__(67);

	exports.assign = assign;
	exports.isString = isString;
	exports.has = has;
	exports.unescapeMd = unescapeMd;
	exports.unescapeAll = unescapeAll;
	exports.isValidEntityCode = isValidEntityCode;
	exports.fromCodePoint = fromCodePoint;
	// exports.replaceEntities     = replaceEntities;
	exports.escapeHtml = escapeHtml;
	exports.arrayReplaceAt = arrayReplaceAt;
	exports.isSpace = isSpace;
	exports.isWhiteSpace = isWhiteSpace;
	exports.isMdAsciiPunct = isMdAsciiPunct;
	exports.isPunctChar = isPunctChar;
	exports.escapeRE = escapeRE;
	exports.normalizeReference = normalizeReference;

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	// HTML5 entities map: { name -> utf16string }
	//
	'use strict'

	/*eslint quotes:0*/
	;
	module.exports = __webpack_require__(60);

/***/ },
/* 60 */
/***/ function(module, exports) {

	module.exports = {
		"Aacute": "",
		"aacute": "",
		"Abreve": "",
		"abreve": "",
		"ac": "",
		"acd": "",
		"acE": "",
		"Acirc": "",
		"acirc": "",
		"acute": "",
		"Acy": "",
		"acy": "",
		"AElig": "",
		"aelig": "",
		"af": "",
		"Afr": "",
		"afr": "",
		"Agrave": "",
		"agrave": "",
		"alefsym": "",
		"aleph": "",
		"Alpha": "",
		"alpha": "",
		"Amacr": "",
		"amacr": "",
		"amalg": "",
		"amp": "&",
		"AMP": "&",
		"andand": "",
		"And": "",
		"and": "",
		"andd": "",
		"andslope": "",
		"andv": "",
		"ang": "",
		"ange": "",
		"angle": "",
		"angmsdaa": "",
		"angmsdab": "",
		"angmsdac": "",
		"angmsdad": "",
		"angmsdae": "",
		"angmsdaf": "",
		"angmsdag": "",
		"angmsdah": "",
		"angmsd": "",
		"angrt": "",
		"angrtvb": "",
		"angrtvbd": "",
		"angsph": "",
		"angst": "",
		"angzarr": "",
		"Aogon": "",
		"aogon": "",
		"Aopf": "",
		"aopf": "",
		"apacir": "",
		"ap": "",
		"apE": "",
		"ape": "",
		"apid": "",
		"apos": "'",
		"ApplyFunction": "",
		"approx": "",
		"approxeq": "",
		"Aring": "",
		"aring": "",
		"Ascr": "",
		"ascr": "",
		"Assign": "",
		"ast": "*",
		"asymp": "",
		"asympeq": "",
		"Atilde": "",
		"atilde": "",
		"Auml": "",
		"auml": "",
		"awconint": "",
		"awint": "",
		"backcong": "",
		"backepsilon": "",
		"backprime": "",
		"backsim": "",
		"backsimeq": "",
		"Backslash": "",
		"Barv": "",
		"barvee": "",
		"barwed": "",
		"Barwed": "",
		"barwedge": "",
		"bbrk": "",
		"bbrktbrk": "",
		"bcong": "",
		"Bcy": "",
		"bcy": "",
		"bdquo": "",
		"becaus": "",
		"because": "",
		"Because": "",
		"bemptyv": "",
		"bepsi": "",
		"bernou": "",
		"Bernoullis": "",
		"Beta": "",
		"beta": "",
		"beth": "",
		"between": "",
		"Bfr": "",
		"bfr": "",
		"bigcap": "",
		"bigcirc": "",
		"bigcup": "",
		"bigodot": "",
		"bigoplus": "",
		"bigotimes": "",
		"bigsqcup": "",
		"bigstar": "",
		"bigtriangledown": "",
		"bigtriangleup": "",
		"biguplus": "",
		"bigvee": "",
		"bigwedge": "",
		"bkarow": "",
		"blacklozenge": "",
		"blacksquare": "",
		"blacktriangle": "",
		"blacktriangledown": "",
		"blacktriangleleft": "",
		"blacktriangleright": "",
		"blank": "",
		"blk12": "",
		"blk14": "",
		"blk34": "",
		"block": "",
		"bne": "=",
		"bnequiv": "",
		"bNot": "",
		"bnot": "",
		"Bopf": "",
		"bopf": "",
		"bot": "",
		"bottom": "",
		"bowtie": "",
		"boxbox": "",
		"boxdl": "",
		"boxdL": "",
		"boxDl": "",
		"boxDL": "",
		"boxdr": "",
		"boxdR": "",
		"boxDr": "",
		"boxDR": "",
		"boxh": "",
		"boxH": "",
		"boxhd": "",
		"boxHd": "",
		"boxhD": "",
		"boxHD": "",
		"boxhu": "",
		"boxHu": "",
		"boxhU": "",
		"boxHU": "",
		"boxminus": "",
		"boxplus": "",
		"boxtimes": "",
		"boxul": "",
		"boxuL": "",
		"boxUl": "",
		"boxUL": "",
		"boxur": "",
		"boxuR": "",
		"boxUr": "",
		"boxUR": "",
		"boxv": "",
		"boxV": "",
		"boxvh": "",
		"boxvH": "",
		"boxVh": "",
		"boxVH": "",
		"boxvl": "",
		"boxvL": "",
		"boxVl": "",
		"boxVL": "",
		"boxvr": "",
		"boxvR": "",
		"boxVr": "",
		"boxVR": "",
		"bprime": "",
		"breve": "",
		"Breve": "",
		"brvbar": "",
		"bscr": "",
		"Bscr": "",
		"bsemi": "",
		"bsim": "",
		"bsime": "",
		"bsolb": "",
		"bsol": "\\",
		"bsolhsub": "",
		"bull": "",
		"bullet": "",
		"bump": "",
		"bumpE": "",
		"bumpe": "",
		"Bumpeq": "",
		"bumpeq": "",
		"Cacute": "",
		"cacute": "",
		"capand": "",
		"capbrcup": "",
		"capcap": "",
		"cap": "",
		"Cap": "",
		"capcup": "",
		"capdot": "",
		"CapitalDifferentialD": "",
		"caps": "",
		"caret": "",
		"caron": "",
		"Cayleys": "",
		"ccaps": "",
		"Ccaron": "",
		"ccaron": "",
		"Ccedil": "",
		"ccedil": "",
		"Ccirc": "",
		"ccirc": "",
		"Cconint": "",
		"ccups": "",
		"ccupssm": "",
		"Cdot": "",
		"cdot": "",
		"cedil": "",
		"Cedilla": "",
		"cemptyv": "",
		"cent": "",
		"centerdot": "",
		"CenterDot": "",
		"cfr": "",
		"Cfr": "",
		"CHcy": "",
		"chcy": "",
		"check": "",
		"checkmark": "",
		"Chi": "",
		"chi": "",
		"circ": "",
		"circeq": "",
		"circlearrowleft": "",
		"circlearrowright": "",
		"circledast": "",
		"circledcirc": "",
		"circleddash": "",
		"CircleDot": "",
		"circledR": "",
		"circledS": "",
		"CircleMinus": "",
		"CirclePlus": "",
		"CircleTimes": "",
		"cir": "",
		"cirE": "",
		"cire": "",
		"cirfnint": "",
		"cirmid": "",
		"cirscir": "",
		"ClockwiseContourIntegral": "",
		"CloseCurlyDoubleQuote": "",
		"CloseCurlyQuote": "",
		"clubs": "",
		"clubsuit": "",
		"colon": ":",
		"Colon": "",
		"Colone": "",
		"colone": "",
		"coloneq": "",
		"comma": ",",
		"commat": "@",
		"comp": "",
		"compfn": "",
		"complement": "",
		"complexes": "",
		"cong": "",
		"congdot": "",
		"Congruent": "",
		"conint": "",
		"Conint": "",
		"ContourIntegral": "",
		"copf": "",
		"Copf": "",
		"coprod": "",
		"Coproduct": "",
		"copy": "",
		"COPY": "",
		"copysr": "",
		"CounterClockwiseContourIntegral": "",
		"crarr": "",
		"cross": "",
		"Cross": "",
		"Cscr": "",
		"cscr": "",
		"csub": "",
		"csube": "",
		"csup": "",
		"csupe": "",
		"ctdot": "",
		"cudarrl": "",
		"cudarrr": "",
		"cuepr": "",
		"cuesc": "",
		"cularr": "",
		"cularrp": "",
		"cupbrcap": "",
		"cupcap": "",
		"CupCap": "",
		"cup": "",
		"Cup": "",
		"cupcup": "",
		"cupdot": "",
		"cupor": "",
		"cups": "",
		"curarr": "",
		"curarrm": "",
		"curlyeqprec": "",
		"curlyeqsucc": "",
		"curlyvee": "",
		"curlywedge": "",
		"curren": "",
		"curvearrowleft": "",
		"curvearrowright": "",
		"cuvee": "",
		"cuwed": "",
		"cwconint": "",
		"cwint": "",
		"cylcty": "",
		"dagger": "",
		"Dagger": "",
		"daleth": "",
		"darr": "",
		"Darr": "",
		"dArr": "",
		"dash": "",
		"Dashv": "",
		"dashv": "",
		"dbkarow": "",
		"dblac": "",
		"Dcaron": "",
		"dcaron": "",
		"Dcy": "",
		"dcy": "",
		"ddagger": "",
		"ddarr": "",
		"DD": "",
		"dd": "",
		"DDotrahd": "",
		"ddotseq": "",
		"deg": "",
		"Del": "",
		"Delta": "",
		"delta": "",
		"demptyv": "",
		"dfisht": "",
		"Dfr": "",
		"dfr": "",
		"dHar": "",
		"dharl": "",
		"dharr": "",
		"DiacriticalAcute": "",
		"DiacriticalDot": "",
		"DiacriticalDoubleAcute": "",
		"DiacriticalGrave": "`",
		"DiacriticalTilde": "",
		"diam": "",
		"diamond": "",
		"Diamond": "",
		"diamondsuit": "",
		"diams": "",
		"die": "",
		"DifferentialD": "",
		"digamma": "",
		"disin": "",
		"div": "",
		"divide": "",
		"divideontimes": "",
		"divonx": "",
		"DJcy": "",
		"djcy": "",
		"dlcorn": "",
		"dlcrop": "",
		"dollar": "$",
		"Dopf": "",
		"dopf": "",
		"Dot": "",
		"dot": "",
		"DotDot": "",
		"doteq": "",
		"doteqdot": "",
		"DotEqual": "",
		"dotminus": "",
		"dotplus": "",
		"dotsquare": "",
		"doublebarwedge": "",
		"DoubleContourIntegral": "",
		"DoubleDot": "",
		"DoubleDownArrow": "",
		"DoubleLeftArrow": "",
		"DoubleLeftRightArrow": "",
		"DoubleLeftTee": "",
		"DoubleLongLeftArrow": "",
		"DoubleLongLeftRightArrow": "",
		"DoubleLongRightArrow": "",
		"DoubleRightArrow": "",
		"DoubleRightTee": "",
		"DoubleUpArrow": "",
		"DoubleUpDownArrow": "",
		"DoubleVerticalBar": "",
		"DownArrowBar": "",
		"downarrow": "",
		"DownArrow": "",
		"Downarrow": "",
		"DownArrowUpArrow": "",
		"DownBreve": "",
		"downdownarrows": "",
		"downharpoonleft": "",
		"downharpoonright": "",
		"DownLeftRightVector": "",
		"DownLeftTeeVector": "",
		"DownLeftVectorBar": "",
		"DownLeftVector": "",
		"DownRightTeeVector": "",
		"DownRightVectorBar": "",
		"DownRightVector": "",
		"DownTeeArrow": "",
		"DownTee": "",
		"drbkarow": "",
		"drcorn": "",
		"drcrop": "",
		"Dscr": "",
		"dscr": "",
		"DScy": "",
		"dscy": "",
		"dsol": "",
		"Dstrok": "",
		"dstrok": "",
		"dtdot": "",
		"dtri": "",
		"dtrif": "",
		"duarr": "",
		"duhar": "",
		"dwangle": "",
		"DZcy": "",
		"dzcy": "",
		"dzigrarr": "",
		"Eacute": "",
		"eacute": "",
		"easter": "",
		"Ecaron": "",
		"ecaron": "",
		"Ecirc": "",
		"ecirc": "",
		"ecir": "",
		"ecolon": "",
		"Ecy": "",
		"ecy": "",
		"eDDot": "",
		"Edot": "",
		"edot": "",
		"eDot": "",
		"ee": "",
		"efDot": "",
		"Efr": "",
		"efr": "",
		"eg": "",
		"Egrave": "",
		"egrave": "",
		"egs": "",
		"egsdot": "",
		"el": "",
		"Element": "",
		"elinters": "",
		"ell": "",
		"els": "",
		"elsdot": "",
		"Emacr": "",
		"emacr": "",
		"empty": "",
		"emptyset": "",
		"EmptySmallSquare": "",
		"emptyv": "",
		"EmptyVerySmallSquare": "",
		"emsp13": "",
		"emsp14": "",
		"emsp": "",
		"ENG": "",
		"eng": "",
		"ensp": "",
		"Eogon": "",
		"eogon": "",
		"Eopf": "",
		"eopf": "",
		"epar": "",
		"eparsl": "",
		"eplus": "",
		"epsi": "",
		"Epsilon": "",
		"epsilon": "",
		"epsiv": "",
		"eqcirc": "",
		"eqcolon": "",
		"eqsim": "",
		"eqslantgtr": "",
		"eqslantless": "",
		"Equal": "",
		"equals": "=",
		"EqualTilde": "",
		"equest": "",
		"Equilibrium": "",
		"equiv": "",
		"equivDD": "",
		"eqvparsl": "",
		"erarr": "",
		"erDot": "",
		"escr": "",
		"Escr": "",
		"esdot": "",
		"Esim": "",
		"esim": "",
		"Eta": "",
		"eta": "",
		"ETH": "",
		"eth": "",
		"Euml": "",
		"euml": "",
		"euro": "",
		"excl": "!",
		"exist": "",
		"Exists": "",
		"expectation": "",
		"exponentiale": "",
		"ExponentialE": "",
		"fallingdotseq": "",
		"Fcy": "",
		"fcy": "",
		"female": "",
		"ffilig": "",
		"fflig": "",
		"ffllig": "",
		"Ffr": "",
		"ffr": "",
		"filig": "",
		"FilledSmallSquare": "",
		"FilledVerySmallSquare": "",
		"fjlig": "fj",
		"flat": "",
		"fllig": "",
		"fltns": "",
		"fnof": "",
		"Fopf": "",
		"fopf": "",
		"forall": "",
		"ForAll": "",
		"fork": "",
		"forkv": "",
		"Fouriertrf": "",
		"fpartint": "",
		"frac12": "",
		"frac13": "",
		"frac14": "",
		"frac15": "",
		"frac16": "",
		"frac18": "",
		"frac23": "",
		"frac25": "",
		"frac34": "",
		"frac35": "",
		"frac38": "",
		"frac45": "",
		"frac56": "",
		"frac58": "",
		"frac78": "",
		"frasl": "",
		"frown": "",
		"fscr": "",
		"Fscr": "",
		"gacute": "",
		"Gamma": "",
		"gamma": "",
		"Gammad": "",
		"gammad": "",
		"gap": "",
		"Gbreve": "",
		"gbreve": "",
		"Gcedil": "",
		"Gcirc": "",
		"gcirc": "",
		"Gcy": "",
		"gcy": "",
		"Gdot": "",
		"gdot": "",
		"ge": "",
		"gE": "",
		"gEl": "",
		"gel": "",
		"geq": "",
		"geqq": "",
		"geqslant": "",
		"gescc": "",
		"ges": "",
		"gesdot": "",
		"gesdoto": "",
		"gesdotol": "",
		"gesl": "",
		"gesles": "",
		"Gfr": "",
		"gfr": "",
		"gg": "",
		"Gg": "",
		"ggg": "",
		"gimel": "",
		"GJcy": "",
		"gjcy": "",
		"gla": "",
		"gl": "",
		"glE": "",
		"glj": "",
		"gnap": "",
		"gnapprox": "",
		"gne": "",
		"gnE": "",
		"gneq": "",
		"gneqq": "",
		"gnsim": "",
		"Gopf": "",
		"gopf": "",
		"grave": "`",
		"GreaterEqual": "",
		"GreaterEqualLess": "",
		"GreaterFullEqual": "",
		"GreaterGreater": "",
		"GreaterLess": "",
		"GreaterSlantEqual": "",
		"GreaterTilde": "",
		"Gscr": "",
		"gscr": "",
		"gsim": "",
		"gsime": "",
		"gsiml": "",
		"gtcc": "",
		"gtcir": "",
		"gt": ">",
		"GT": ">",
		"Gt": "",
		"gtdot": "",
		"gtlPar": "",
		"gtquest": "",
		"gtrapprox": "",
		"gtrarr": "",
		"gtrdot": "",
		"gtreqless": "",
		"gtreqqless": "",
		"gtrless": "",
		"gtrsim": "",
		"gvertneqq": "",
		"gvnE": "",
		"Hacek": "",
		"hairsp": "",
		"half": "",
		"hamilt": "",
		"HARDcy": "",
		"hardcy": "",
		"harrcir": "",
		"harr": "",
		"hArr": "",
		"harrw": "",
		"Hat": "^",
		"hbar": "",
		"Hcirc": "",
		"hcirc": "",
		"hearts": "",
		"heartsuit": "",
		"hellip": "",
		"hercon": "",
		"hfr": "",
		"Hfr": "",
		"HilbertSpace": "",
		"hksearow": "",
		"hkswarow": "",
		"hoarr": "",
		"homtht": "",
		"hookleftarrow": "",
		"hookrightarrow": "",
		"hopf": "",
		"Hopf": "",
		"horbar": "",
		"HorizontalLine": "",
		"hscr": "",
		"Hscr": "",
		"hslash": "",
		"Hstrok": "",
		"hstrok": "",
		"HumpDownHump": "",
		"HumpEqual": "",
		"hybull": "",
		"hyphen": "",
		"Iacute": "",
		"iacute": "",
		"ic": "",
		"Icirc": "",
		"icirc": "",
		"Icy": "",
		"icy": "",
		"Idot": "",
		"IEcy": "",
		"iecy": "",
		"iexcl": "",
		"iff": "",
		"ifr": "",
		"Ifr": "",
		"Igrave": "",
		"igrave": "",
		"ii": "",
		"iiiint": "",
		"iiint": "",
		"iinfin": "",
		"iiota": "",
		"IJlig": "",
		"ijlig": "",
		"Imacr": "",
		"imacr": "",
		"image": "",
		"ImaginaryI": "",
		"imagline": "",
		"imagpart": "",
		"imath": "",
		"Im": "",
		"imof": "",
		"imped": "",
		"Implies": "",
		"incare": "",
		"in": "",
		"infin": "",
		"infintie": "",
		"inodot": "",
		"intcal": "",
		"int": "",
		"Int": "",
		"integers": "",
		"Integral": "",
		"intercal": "",
		"Intersection": "",
		"intlarhk": "",
		"intprod": "",
		"InvisibleComma": "",
		"InvisibleTimes": "",
		"IOcy": "",
		"iocy": "",
		"Iogon": "",
		"iogon": "",
		"Iopf": "",
		"iopf": "",
		"Iota": "",
		"iota": "",
		"iprod": "",
		"iquest": "",
		"iscr": "",
		"Iscr": "",
		"isin": "",
		"isindot": "",
		"isinE": "",
		"isins": "",
		"isinsv": "",
		"isinv": "",
		"it": "",
		"Itilde": "",
		"itilde": "",
		"Iukcy": "",
		"iukcy": "",
		"Iuml": "",
		"iuml": "",
		"Jcirc": "",
		"jcirc": "",
		"Jcy": "",
		"jcy": "",
		"Jfr": "",
		"jfr": "",
		"jmath": "",
		"Jopf": "",
		"jopf": "",
		"Jscr": "",
		"jscr": "",
		"Jsercy": "",
		"jsercy": "",
		"Jukcy": "",
		"jukcy": "",
		"Kappa": "",
		"kappa": "",
		"kappav": "",
		"Kcedil": "",
		"kcedil": "",
		"Kcy": "",
		"kcy": "",
		"Kfr": "",
		"kfr": "",
		"kgreen": "",
		"KHcy": "",
		"khcy": "",
		"KJcy": "",
		"kjcy": "",
		"Kopf": "",
		"kopf": "",
		"Kscr": "",
		"kscr": "",
		"lAarr": "",
		"Lacute": "",
		"lacute": "",
		"laemptyv": "",
		"lagran": "",
		"Lambda": "",
		"lambda": "",
		"lang": "",
		"Lang": "",
		"langd": "",
		"langle": "",
		"lap": "",
		"Laplacetrf": "",
		"laquo": "",
		"larrb": "",
		"larrbfs": "",
		"larr": "",
		"Larr": "",
		"lArr": "",
		"larrfs": "",
		"larrhk": "",
		"larrlp": "",
		"larrpl": "",
		"larrsim": "",
		"larrtl": "",
		"latail": "",
		"lAtail": "",
		"lat": "",
		"late": "",
		"lates": "",
		"lbarr": "",
		"lBarr": "",
		"lbbrk": "",
		"lbrace": "{",
		"lbrack": "[",
		"lbrke": "",
		"lbrksld": "",
		"lbrkslu": "",
		"Lcaron": "",
		"lcaron": "",
		"Lcedil": "",
		"lcedil": "",
		"lceil": "",
		"lcub": "{",
		"Lcy": "",
		"lcy": "",
		"ldca": "",
		"ldquo": "",
		"ldquor": "",
		"ldrdhar": "",
		"ldrushar": "",
		"ldsh": "",
		"le": "",
		"lE": "",
		"LeftAngleBracket": "",
		"LeftArrowBar": "",
		"leftarrow": "",
		"LeftArrow": "",
		"Leftarrow": "",
		"LeftArrowRightArrow": "",
		"leftarrowtail": "",
		"LeftCeiling": "",
		"LeftDoubleBracket": "",
		"LeftDownTeeVector": "",
		"LeftDownVectorBar": "",
		"LeftDownVector": "",
		"LeftFloor": "",
		"leftharpoondown": "",
		"leftharpoonup": "",
		"leftleftarrows": "",
		"leftrightarrow": "",
		"LeftRightArrow": "",
		"Leftrightarrow": "",
		"leftrightarrows": "",
		"leftrightharpoons": "",
		"leftrightsquigarrow": "",
		"LeftRightVector": "",
		"LeftTeeArrow": "",
		"LeftTee": "",
		"LeftTeeVector": "",
		"leftthreetimes": "",
		"LeftTriangleBar": "",
		"LeftTriangle": "",
		"LeftTriangleEqual": "",
		"LeftUpDownVector": "",
		"LeftUpTeeVector": "",
		"LeftUpVectorBar": "",
		"LeftUpVector": "",
		"LeftVectorBar": "",
		"LeftVector": "",
		"lEg": "",
		"leg": "",
		"leq": "",
		"leqq": "",
		"leqslant": "",
		"lescc": "",
		"les": "",
		"lesdot": "",
		"lesdoto": "",
		"lesdotor": "",
		"lesg": "",
		"lesges": "",
		"lessapprox": "",
		"lessdot": "",
		"lesseqgtr": "",
		"lesseqqgtr": "",
		"LessEqualGreater": "",
		"LessFullEqual": "",
		"LessGreater": "",
		"lessgtr": "",
		"LessLess": "",
		"lesssim": "",
		"LessSlantEqual": "",
		"LessTilde": "",
		"lfisht": "",
		"lfloor": "",
		"Lfr": "",
		"lfr": "",
		"lg": "",
		"lgE": "",
		"lHar": "",
		"lhard": "",
		"lharu": "",
		"lharul": "",
		"lhblk": "",
		"LJcy": "",
		"ljcy": "",
		"llarr": "",
		"ll": "",
		"Ll": "",
		"llcorner": "",
		"Lleftarrow": "",
		"llhard": "",
		"lltri": "",
		"Lmidot": "",
		"lmidot": "",
		"lmoustache": "",
		"lmoust": "",
		"lnap": "",
		"lnapprox": "",
		"lne": "",
		"lnE": "",
		"lneq": "",
		"lneqq": "",
		"lnsim": "",
		"loang": "",
		"loarr": "",
		"lobrk": "",
		"longleftarrow": "",
		"LongLeftArrow": "",
		"Longleftarrow": "",
		"longleftrightarrow": "",
		"LongLeftRightArrow": "",
		"Longleftrightarrow": "",
		"longmapsto": "",
		"longrightarrow": "",
		"LongRightArrow": "",
		"Longrightarrow": "",
		"looparrowleft": "",
		"looparrowright": "",
		"lopar": "",
		"Lopf": "",
		"lopf": "",
		"loplus": "",
		"lotimes": "",
		"lowast": "",
		"lowbar": "_",
		"LowerLeftArrow": "",
		"LowerRightArrow": "",
		"loz": "",
		"lozenge": "",
		"lozf": "",
		"lpar": "(",
		"lparlt": "",
		"lrarr": "",
		"lrcorner": "",
		"lrhar": "",
		"lrhard": "",
		"lrm": "",
		"lrtri": "",
		"lsaquo": "",
		"lscr": "",
		"Lscr": "",
		"lsh": "",
		"Lsh": "",
		"lsim": "",
		"lsime": "",
		"lsimg": "",
		"lsqb": "[",
		"lsquo": "",
		"lsquor": "",
		"Lstrok": "",
		"lstrok": "",
		"ltcc": "",
		"ltcir": "",
		"lt": "<",
		"LT": "<",
		"Lt": "",
		"ltdot": "",
		"lthree": "",
		"ltimes": "",
		"ltlarr": "",
		"ltquest": "",
		"ltri": "",
		"ltrie": "",
		"ltrif": "",
		"ltrPar": "",
		"lurdshar": "",
		"luruhar": "",
		"lvertneqq": "",
		"lvnE": "",
		"macr": "",
		"male": "",
		"malt": "",
		"maltese": "",
		"Map": "",
		"map": "",
		"mapsto": "",
		"mapstodown": "",
		"mapstoleft": "",
		"mapstoup": "",
		"marker": "",
		"mcomma": "",
		"Mcy": "",
		"mcy": "",
		"mdash": "",
		"mDDot": "",
		"measuredangle": "",
		"MediumSpace": "",
		"Mellintrf": "",
		"Mfr": "",
		"mfr": "",
		"mho": "",
		"micro": "",
		"midast": "*",
		"midcir": "",
		"mid": "",
		"middot": "",
		"minusb": "",
		"minus": "",
		"minusd": "",
		"minusdu": "",
		"MinusPlus": "",
		"mlcp": "",
		"mldr": "",
		"mnplus": "",
		"models": "",
		"Mopf": "",
		"mopf": "",
		"mp": "",
		"mscr": "",
		"Mscr": "",
		"mstpos": "",
		"Mu": "",
		"mu": "",
		"multimap": "",
		"mumap": "",
		"nabla": "",
		"Nacute": "",
		"nacute": "",
		"nang": "",
		"nap": "",
		"napE": "",
		"napid": "",
		"napos": "",
		"napprox": "",
		"natural": "",
		"naturals": "",
		"natur": "",
		"nbsp": "",
		"nbump": "",
		"nbumpe": "",
		"ncap": "",
		"Ncaron": "",
		"ncaron": "",
		"Ncedil": "",
		"ncedil": "",
		"ncong": "",
		"ncongdot": "",
		"ncup": "",
		"Ncy": "",
		"ncy": "",
		"ndash": "",
		"nearhk": "",
		"nearr": "",
		"neArr": "",
		"nearrow": "",
		"ne": "",
		"nedot": "",
		"NegativeMediumSpace": "",
		"NegativeThickSpace": "",
		"NegativeThinSpace": "",
		"NegativeVeryThinSpace": "",
		"nequiv": "",
		"nesear": "",
		"nesim": "",
		"NestedGreaterGreater": "",
		"NestedLessLess": "",
		"NewLine": "\n",
		"nexist": "",
		"nexists": "",
		"Nfr": "",
		"nfr": "",
		"ngE": "",
		"nge": "",
		"ngeq": "",
		"ngeqq": "",
		"ngeqslant": "",
		"nges": "",
		"nGg": "",
		"ngsim": "",
		"nGt": "",
		"ngt": "",
		"ngtr": "",
		"nGtv": "",
		"nharr": "",
		"nhArr": "",
		"nhpar": "",
		"ni": "",
		"nis": "",
		"nisd": "",
		"niv": "",
		"NJcy": "",
		"njcy": "",
		"nlarr": "",
		"nlArr": "",
		"nldr": "",
		"nlE": "",
		"nle": "",
		"nleftarrow": "",
		"nLeftarrow": "",
		"nleftrightarrow": "",
		"nLeftrightarrow": "",
		"nleq": "",
		"nleqq": "",
		"nleqslant": "",
		"nles": "",
		"nless": "",
		"nLl": "",
		"nlsim": "",
		"nLt": "",
		"nlt": "",
		"nltri": "",
		"nltrie": "",
		"nLtv": "",
		"nmid": "",
		"NoBreak": "",
		"NonBreakingSpace": "",
		"nopf": "",
		"Nopf": "",
		"Not": "",
		"not": "",
		"NotCongruent": "",
		"NotCupCap": "",
		"NotDoubleVerticalBar": "",
		"NotElement": "",
		"NotEqual": "",
		"NotEqualTilde": "",
		"NotExists": "",
		"NotGreater": "",
		"NotGreaterEqual": "",
		"NotGreaterFullEqual": "",
		"NotGreaterGreater": "",
		"NotGreaterLess": "",
		"NotGreaterSlantEqual": "",
		"NotGreaterTilde": "",
		"NotHumpDownHump": "",
		"NotHumpEqual": "",
		"notin": "",
		"notindot": "",
		"notinE": "",
		"notinva": "",
		"notinvb": "",
		"notinvc": "",
		"NotLeftTriangleBar": "",
		"NotLeftTriangle": "",
		"NotLeftTriangleEqual": "",
		"NotLess": "",
		"NotLessEqual": "",
		"NotLessGreater": "",
		"NotLessLess": "",
		"NotLessSlantEqual": "",
		"NotLessTilde": "",
		"NotNestedGreaterGreater": "",
		"NotNestedLessLess": "",
		"notni": "",
		"notniva": "",
		"notnivb": "",
		"notnivc": "",
		"NotPrecedes": "",
		"NotPrecedesEqual": "",
		"NotPrecedesSlantEqual": "",
		"NotReverseElement": "",
		"NotRightTriangleBar": "",
		"NotRightTriangle": "",
		"NotRightTriangleEqual": "",
		"NotSquareSubset": "",
		"NotSquareSubsetEqual": "",
		"NotSquareSuperset": "",
		"NotSquareSupersetEqual": "",
		"NotSubset": "",
		"NotSubsetEqual": "",
		"NotSucceeds": "",
		"NotSucceedsEqual": "",
		"NotSucceedsSlantEqual": "",
		"NotSucceedsTilde": "",
		"NotSuperset": "",
		"NotSupersetEqual": "",
		"NotTilde": "",
		"NotTildeEqual": "",
		"NotTildeFullEqual": "",
		"NotTildeTilde": "",
		"NotVerticalBar": "",
		"nparallel": "",
		"npar": "",
		"nparsl": "",
		"npart": "",
		"npolint": "",
		"npr": "",
		"nprcue": "",
		"nprec": "",
		"npreceq": "",
		"npre": "",
		"nrarrc": "",
		"nrarr": "",
		"nrArr": "",
		"nrarrw": "",
		"nrightarrow": "",
		"nRightarrow": "",
		"nrtri": "",
		"nrtrie": "",
		"nsc": "",
		"nsccue": "",
		"nsce": "",
		"Nscr": "",
		"nscr": "",
		"nshortmid": "",
		"nshortparallel": "",
		"nsim": "",
		"nsime": "",
		"nsimeq": "",
		"nsmid": "",
		"nspar": "",
		"nsqsube": "",
		"nsqsupe": "",
		"nsub": "",
		"nsubE": "",
		"nsube": "",
		"nsubset": "",
		"nsubseteq": "",
		"nsubseteqq": "",
		"nsucc": "",
		"nsucceq": "",
		"nsup": "",
		"nsupE": "",
		"nsupe": "",
		"nsupset": "",
		"nsupseteq": "",
		"nsupseteqq": "",
		"ntgl": "",
		"Ntilde": "",
		"ntilde": "",
		"ntlg": "",
		"ntriangleleft": "",
		"ntrianglelefteq": "",
		"ntriangleright": "",
		"ntrianglerighteq": "",
		"Nu": "",
		"nu": "",
		"num": "#",
		"numero": "",
		"numsp": "",
		"nvap": "",
		"nvdash": "",
		"nvDash": "",
		"nVdash": "",
		"nVDash": "",
		"nvge": "",
		"nvgt": ">",
		"nvHarr": "",
		"nvinfin": "",
		"nvlArr": "",
		"nvle": "",
		"nvlt": "<",
		"nvltrie": "",
		"nvrArr": "",
		"nvrtrie": "",
		"nvsim": "",
		"nwarhk": "",
		"nwarr": "",
		"nwArr": "",
		"nwarrow": "",
		"nwnear": "",
		"Oacute": "",
		"oacute": "",
		"oast": "",
		"Ocirc": "",
		"ocirc": "",
		"ocir": "",
		"Ocy": "",
		"ocy": "",
		"odash": "",
		"Odblac": "",
		"odblac": "",
		"odiv": "",
		"odot": "",
		"odsold": "",
		"OElig": "",
		"oelig": "",
		"ofcir": "",
		"Ofr": "",
		"ofr": "",
		"ogon": "",
		"Ograve": "",
		"ograve": "",
		"ogt": "",
		"ohbar": "",
		"ohm": "",
		"oint": "",
		"olarr": "",
		"olcir": "",
		"olcross": "",
		"oline": "",
		"olt": "",
		"Omacr": "",
		"omacr": "",
		"Omega": "",
		"omega": "",
		"Omicron": "",
		"omicron": "",
		"omid": "",
		"ominus": "",
		"Oopf": "",
		"oopf": "",
		"opar": "",
		"OpenCurlyDoubleQuote": "",
		"OpenCurlyQuote": "",
		"operp": "",
		"oplus": "",
		"orarr": "",
		"Or": "",
		"or": "",
		"ord": "",
		"order": "",
		"orderof": "",
		"ordf": "",
		"ordm": "",
		"origof": "",
		"oror": "",
		"orslope": "",
		"orv": "",
		"oS": "",
		"Oscr": "",
		"oscr": "",
		"Oslash": "",
		"oslash": "",
		"osol": "",
		"Otilde": "",
		"otilde": "",
		"otimesas": "",
		"Otimes": "",
		"otimes": "",
		"Ouml": "",
		"ouml": "",
		"ovbar": "",
		"OverBar": "",
		"OverBrace": "",
		"OverBracket": "",
		"OverParenthesis": "",
		"para": "",
		"parallel": "",
		"par": "",
		"parsim": "",
		"parsl": "",
		"part": "",
		"PartialD": "",
		"Pcy": "",
		"pcy": "",
		"percnt": "%",
		"period": ".",
		"permil": "",
		"perp": "",
		"pertenk": "",
		"Pfr": "",
		"pfr": "",
		"Phi": "",
		"phi": "",
		"phiv": "",
		"phmmat": "",
		"phone": "",
		"Pi": "",
		"pi": "",
		"pitchfork": "",
		"piv": "",
		"planck": "",
		"planckh": "",
		"plankv": "",
		"plusacir": "",
		"plusb": "",
		"pluscir": "",
		"plus": "+",
		"plusdo": "",
		"plusdu": "",
		"pluse": "",
		"PlusMinus": "",
		"plusmn": "",
		"plussim": "",
		"plustwo": "",
		"pm": "",
		"Poincareplane": "",
		"pointint": "",
		"popf": "",
		"Popf": "",
		"pound": "",
		"prap": "",
		"Pr": "",
		"pr": "",
		"prcue": "",
		"precapprox": "",
		"prec": "",
		"preccurlyeq": "",
		"Precedes": "",
		"PrecedesEqual": "",
		"PrecedesSlantEqual": "",
		"PrecedesTilde": "",
		"preceq": "",
		"precnapprox": "",
		"precneqq": "",
		"precnsim": "",
		"pre": "",
		"prE": "",
		"precsim": "",
		"prime": "",
		"Prime": "",
		"primes": "",
		"prnap": "",
		"prnE": "",
		"prnsim": "",
		"prod": "",
		"Product": "",
		"profalar": "",
		"profline": "",
		"profsurf": "",
		"prop": "",
		"Proportional": "",
		"Proportion": "",
		"propto": "",
		"prsim": "",
		"prurel": "",
		"Pscr": "",
		"pscr": "",
		"Psi": "",
		"psi": "",
		"puncsp": "",
		"Qfr": "",
		"qfr": "",
		"qint": "",
		"qopf": "",
		"Qopf": "",
		"qprime": "",
		"Qscr": "",
		"qscr": "",
		"quaternions": "",
		"quatint": "",
		"quest": "?",
		"questeq": "",
		"quot": "\"",
		"QUOT": "\"",
		"rAarr": "",
		"race": "",
		"Racute": "",
		"racute": "",
		"radic": "",
		"raemptyv": "",
		"rang": "",
		"Rang": "",
		"rangd": "",
		"range": "",
		"rangle": "",
		"raquo": "",
		"rarrap": "",
		"rarrb": "",
		"rarrbfs": "",
		"rarrc": "",
		"rarr": "",
		"Rarr": "",
		"rArr": "",
		"rarrfs": "",
		"rarrhk": "",
		"rarrlp": "",
		"rarrpl": "",
		"rarrsim": "",
		"Rarrtl": "",
		"rarrtl": "",
		"rarrw": "",
		"ratail": "",
		"rAtail": "",
		"ratio": "",
		"rationals": "",
		"rbarr": "",
		"rBarr": "",
		"RBarr": "",
		"rbbrk": "",
		"rbrace": "}",
		"rbrack": "]",
		"rbrke": "",
		"rbrksld": "",
		"rbrkslu": "",
		"Rcaron": "",
		"rcaron": "",
		"Rcedil": "",
		"rcedil": "",
		"rceil": "",
		"rcub": "}",
		"Rcy": "",
		"rcy": "",
		"rdca": "",
		"rdldhar": "",
		"rdquo": "",
		"rdquor": "",
		"rdsh": "",
		"real": "",
		"realine": "",
		"realpart": "",
		"reals": "",
		"Re": "",
		"rect": "",
		"reg": "",
		"REG": "",
		"ReverseElement": "",
		"ReverseEquilibrium": "",
		"ReverseUpEquilibrium": "",
		"rfisht": "",
		"rfloor": "",
		"rfr": "",
		"Rfr": "",
		"rHar": "",
		"rhard": "",
		"rharu": "",
		"rharul": "",
		"Rho": "",
		"rho": "",
		"rhov": "",
		"RightAngleBracket": "",
		"RightArrowBar": "",
		"rightarrow": "",
		"RightArrow": "",
		"Rightarrow": "",
		"RightArrowLeftArrow": "",
		"rightarrowtail": "",
		"RightCeiling": "",
		"RightDoubleBracket": "",
		"RightDownTeeVector": "",
		"RightDownVectorBar": "",
		"RightDownVector": "",
		"RightFloor": "",
		"rightharpoondown": "",
		"rightharpoonup": "",
		"rightleftarrows": "",
		"rightleftharpoons": "",
		"rightrightarrows": "",
		"rightsquigarrow": "",
		"RightTeeArrow": "",
		"RightTee": "",
		"RightTeeVector": "",
		"rightthreetimes": "",
		"RightTriangleBar": "",
		"RightTriangle": "",
		"RightTriangleEqual": "",
		"RightUpDownVector": "",
		"RightUpTeeVector": "",
		"RightUpVectorBar": "",
		"RightUpVector": "",
		"RightVectorBar": "",
		"RightVector": "",
		"ring": "",
		"risingdotseq": "",
		"rlarr": "",
		"rlhar": "",
		"rlm": "",
		"rmoustache": "",
		"rmoust": "",
		"rnmid": "",
		"roang": "",
		"roarr": "",
		"robrk": "",
		"ropar": "",
		"ropf": "",
		"Ropf": "",
		"roplus": "",
		"rotimes": "",
		"RoundImplies": "",
		"rpar": ")",
		"rpargt": "",
		"rppolint": "",
		"rrarr": "",
		"Rrightarrow": "",
		"rsaquo": "",
		"rscr": "",
		"Rscr": "",
		"rsh": "",
		"Rsh": "",
		"rsqb": "]",
		"rsquo": "",
		"rsquor": "",
		"rthree": "",
		"rtimes": "",
		"rtri": "",
		"rtrie": "",
		"rtrif": "",
		"rtriltri": "",
		"RuleDelayed": "",
		"ruluhar": "",
		"rx": "",
		"Sacute": "",
		"sacute": "",
		"sbquo": "",
		"scap": "",
		"Scaron": "",
		"scaron": "",
		"Sc": "",
		"sc": "",
		"sccue": "",
		"sce": "",
		"scE": "",
		"Scedil": "",
		"scedil": "",
		"Scirc": "",
		"scirc": "",
		"scnap": "",
		"scnE": "",
		"scnsim": "",
		"scpolint": "",
		"scsim": "",
		"Scy": "",
		"scy": "",
		"sdotb": "",
		"sdot": "",
		"sdote": "",
		"searhk": "",
		"searr": "",
		"seArr": "",
		"searrow": "",
		"sect": "",
		"semi": ";",
		"seswar": "",
		"setminus": "",
		"setmn": "",
		"sext": "",
		"Sfr": "",
		"sfr": "",
		"sfrown": "",
		"sharp": "",
		"SHCHcy": "",
		"shchcy": "",
		"SHcy": "",
		"shcy": "",
		"ShortDownArrow": "",
		"ShortLeftArrow": "",
		"shortmid": "",
		"shortparallel": "",
		"ShortRightArrow": "",
		"ShortUpArrow": "",
		"shy": "",
		"Sigma": "",
		"sigma": "",
		"sigmaf": "",
		"sigmav": "",
		"sim": "",
		"simdot": "",
		"sime": "",
		"simeq": "",
		"simg": "",
		"simgE": "",
		"siml": "",
		"simlE": "",
		"simne": "",
		"simplus": "",
		"simrarr": "",
		"slarr": "",
		"SmallCircle": "",
		"smallsetminus": "",
		"smashp": "",
		"smeparsl": "",
		"smid": "",
		"smile": "",
		"smt": "",
		"smte": "",
		"smtes": "",
		"SOFTcy": "",
		"softcy": "",
		"solbar": "",
		"solb": "",
		"sol": "/",
		"Sopf": "",
		"sopf": "",
		"spades": "",
		"spadesuit": "",
		"spar": "",
		"sqcap": "",
		"sqcaps": "",
		"sqcup": "",
		"sqcups": "",
		"Sqrt": "",
		"sqsub": "",
		"sqsube": "",
		"sqsubset": "",
		"sqsubseteq": "",
		"sqsup": "",
		"sqsupe": "",
		"sqsupset": "",
		"sqsupseteq": "",
		"square": "",
		"Square": "",
		"SquareIntersection": "",
		"SquareSubset": "",
		"SquareSubsetEqual": "",
		"SquareSuperset": "",
		"SquareSupersetEqual": "",
		"SquareUnion": "",
		"squarf": "",
		"squ": "",
		"squf": "",
		"srarr": "",
		"Sscr": "",
		"sscr": "",
		"ssetmn": "",
		"ssmile": "",
		"sstarf": "",
		"Star": "",
		"star": "",
		"starf": "",
		"straightepsilon": "",
		"straightphi": "",
		"strns": "",
		"sub": "",
		"Sub": "",
		"subdot": "",
		"subE": "",
		"sube": "",
		"subedot": "",
		"submult": "",
		"subnE": "",
		"subne": "",
		"subplus": "",
		"subrarr": "",
		"subset": "",
		"Subset": "",
		"subseteq": "",
		"subseteqq": "",
		"SubsetEqual": "",
		"subsetneq": "",
		"subsetneqq": "",
		"subsim": "",
		"subsub": "",
		"subsup": "",
		"succapprox": "",
		"succ": "",
		"succcurlyeq": "",
		"Succeeds": "",
		"SucceedsEqual": "",
		"SucceedsSlantEqual": "",
		"SucceedsTilde": "",
		"succeq": "",
		"succnapprox": "",
		"succneqq": "",
		"succnsim": "",
		"succsim": "",
		"SuchThat": "",
		"sum": "",
		"Sum": "",
		"sung": "",
		"sup1": "",
		"sup2": "",
		"sup3": "",
		"sup": "",
		"Sup": "",
		"supdot": "",
		"supdsub": "",
		"supE": "",
		"supe": "",
		"supedot": "",
		"Superset": "",
		"SupersetEqual": "",
		"suphsol": "",
		"suphsub": "",
		"suplarr": "",
		"supmult": "",
		"supnE": "",
		"supne": "",
		"supplus": "",
		"supset": "",
		"Supset": "",
		"supseteq": "",
		"supseteqq": "",
		"supsetneq": "",
		"supsetneqq": "",
		"supsim": "",
		"supsub": "",
		"supsup": "",
		"swarhk": "",
		"swarr": "",
		"swArr": "",
		"swarrow": "",
		"swnwar": "",
		"szlig": "",
		"Tab": "\t",
		"target": "",
		"Tau": "",
		"tau": "",
		"tbrk": "",
		"Tcaron": "",
		"tcaron": "",
		"Tcedil": "",
		"tcedil": "",
		"Tcy": "",
		"tcy": "",
		"tdot": "",
		"telrec": "",
		"Tfr": "",
		"tfr": "",
		"there4": "",
		"therefore": "",
		"Therefore": "",
		"Theta": "",
		"theta": "",
		"thetasym": "",
		"thetav": "",
		"thickapprox": "",
		"thicksim": "",
		"ThickSpace": "",
		"ThinSpace": "",
		"thinsp": "",
		"thkap": "",
		"thksim": "",
		"THORN": "",
		"thorn": "",
		"tilde": "",
		"Tilde": "",
		"TildeEqual": "",
		"TildeFullEqual": "",
		"TildeTilde": "",
		"timesbar": "",
		"timesb": "",
		"times": "",
		"timesd": "",
		"tint": "",
		"toea": "",
		"topbot": "",
		"topcir": "",
		"top": "",
		"Topf": "",
		"topf": "",
		"topfork": "",
		"tosa": "",
		"tprime": "",
		"trade": "",
		"TRADE": "",
		"triangle": "",
		"triangledown": "",
		"triangleleft": "",
		"trianglelefteq": "",
		"triangleq": "",
		"triangleright": "",
		"trianglerighteq": "",
		"tridot": "",
		"trie": "",
		"triminus": "",
		"TripleDot": "",
		"triplus": "",
		"trisb": "",
		"tritime": "",
		"trpezium": "",
		"Tscr": "",
		"tscr": "",
		"TScy": "",
		"tscy": "",
		"TSHcy": "",
		"tshcy": "",
		"Tstrok": "",
		"tstrok": "",
		"twixt": "",
		"twoheadleftarrow": "",
		"twoheadrightarrow": "",
		"Uacute": "",
		"uacute": "",
		"uarr": "",
		"Uarr": "",
		"uArr": "",
		"Uarrocir": "",
		"Ubrcy": "",
		"ubrcy": "",
		"Ubreve": "",
		"ubreve": "",
		"Ucirc": "",
		"ucirc": "",
		"Ucy": "",
		"ucy": "",
		"udarr": "",
		"Udblac": "",
		"udblac": "",
		"udhar": "",
		"ufisht": "",
		"Ufr": "",
		"ufr": "",
		"Ugrave": "",
		"ugrave": "",
		"uHar": "",
		"uharl": "",
		"uharr": "",
		"uhblk": "",
		"ulcorn": "",
		"ulcorner": "",
		"ulcrop": "",
		"ultri": "",
		"Umacr": "",
		"umacr": "",
		"uml": "",
		"UnderBar": "_",
		"UnderBrace": "",
		"UnderBracket": "",
		"UnderParenthesis": "",
		"Union": "",
		"UnionPlus": "",
		"Uogon": "",
		"uogon": "",
		"Uopf": "",
		"uopf": "",
		"UpArrowBar": "",
		"uparrow": "",
		"UpArrow": "",
		"Uparrow": "",
		"UpArrowDownArrow": "",
		"updownarrow": "",
		"UpDownArrow": "",
		"Updownarrow": "",
		"UpEquilibrium": "",
		"upharpoonleft": "",
		"upharpoonright": "",
		"uplus": "",
		"UpperLeftArrow": "",
		"UpperRightArrow": "",
		"upsi": "",
		"Upsi": "",
		"upsih": "",
		"Upsilon": "",
		"upsilon": "",
		"UpTeeArrow": "",
		"UpTee": "",
		"upuparrows": "",
		"urcorn": "",
		"urcorner": "",
		"urcrop": "",
		"Uring": "",
		"uring": "",
		"urtri": "",
		"Uscr": "",
		"uscr": "",
		"utdot": "",
		"Utilde": "",
		"utilde": "",
		"utri": "",
		"utrif": "",
		"uuarr": "",
		"Uuml": "",
		"uuml": "",
		"uwangle": "",
		"vangrt": "",
		"varepsilon": "",
		"varkappa": "",
		"varnothing": "",
		"varphi": "",
		"varpi": "",
		"varpropto": "",
		"varr": "",
		"vArr": "",
		"varrho": "",
		"varsigma": "",
		"varsubsetneq": "",
		"varsubsetneqq": "",
		"varsupsetneq": "",
		"varsupsetneqq": "",
		"vartheta": "",
		"vartriangleleft": "",
		"vartriangleright": "",
		"vBar": "",
		"Vbar": "",
		"vBarv": "",
		"Vcy": "",
		"vcy": "",
		"vdash": "",
		"vDash": "",
		"Vdash": "",
		"VDash": "",
		"Vdashl": "",
		"veebar": "",
		"vee": "",
		"Vee": "",
		"veeeq": "",
		"vellip": "",
		"verbar": "|",
		"Verbar": "",
		"vert": "|",
		"Vert": "",
		"VerticalBar": "",
		"VerticalLine": "|",
		"VerticalSeparator": "",
		"VerticalTilde": "",
		"VeryThinSpace": "",
		"Vfr": "",
		"vfr": "",
		"vltri": "",
		"vnsub": "",
		"vnsup": "",
		"Vopf": "",
		"vopf": "",
		"vprop": "",
		"vrtri": "",
		"Vscr": "",
		"vscr": "",
		"vsubnE": "",
		"vsubne": "",
		"vsupnE": "",
		"vsupne": "",
		"Vvdash": "",
		"vzigzag": "",
		"Wcirc": "",
		"wcirc": "",
		"wedbar": "",
		"wedge": "",
		"Wedge": "",
		"wedgeq": "",
		"weierp": "",
		"Wfr": "",
		"wfr": "",
		"Wopf": "",
		"wopf": "",
		"wp": "",
		"wr": "",
		"wreath": "",
		"Wscr": "",
		"wscr": "",
		"xcap": "",
		"xcirc": "",
		"xcup": "",
		"xdtri": "",
		"Xfr": "",
		"xfr": "",
		"xharr": "",
		"xhArr": "",
		"Xi": "",
		"xi": "",
		"xlarr": "",
		"xlArr": "",
		"xmap": "",
		"xnis": "",
		"xodot": "",
		"Xopf": "",
		"xopf": "",
		"xoplus": "",
		"xotime": "",
		"xrarr": "",
		"xrArr": "",
		"Xscr": "",
		"xscr": "",
		"xsqcup": "",
		"xuplus": "",
		"xutri": "",
		"xvee": "",
		"xwedge": "",
		"Yacute": "",
		"yacute": "",
		"YAcy": "",
		"yacy": "",
		"Ycirc": "",
		"ycirc": "",
		"Ycy": "",
		"ycy": "",
		"yen": "",
		"Yfr": "",
		"yfr": "",
		"YIcy": "",
		"yicy": "",
		"Yopf": "",
		"yopf": "",
		"Yscr": "",
		"yscr": "",
		"YUcy": "",
		"yucy": "",
		"yuml": "",
		"Yuml": "",
		"Zacute": "",
		"zacute": "",
		"Zcaron": "",
		"zcaron": "",
		"Zcy": "",
		"zcy": "",
		"Zdot": "",
		"zdot": "",
		"zeetrf": "",
		"ZeroWidthSpace": "",
		"Zeta": "",
		"zeta": "",
		"zfr": "",
		"Zfr": "",
		"ZHcy": "",
		"zhcy": "",
		"zigrarr": "",
		"zopf": "",
		"Zopf": "",
		"Zscr": "",
		"zscr": "",
		"zwj": "",
		"zwnj": ""
	};

/***/ },
/* 61 */
/***/ function(module, exports) {

	module.exports = /[!-#%-\*,-/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E42\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDE38-\uDE3D]|\uD805[\uDCC6\uDDC1-\uDDC9\uDE41-\uDE43]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD82F\uDC9F/;

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	module.exports.encode = __webpack_require__(63);
	module.exports.decode = __webpack_require__(64);
	module.exports.format = __webpack_require__(65);
	module.exports.parse = __webpack_require__(66);

/***/ },
/* 63 */
/***/ function(module, exports) {

	'use strict';

	var encodeCache = {};

	// Create a lookup array where anything but characters in `chars` string
	// and alphanumeric chars is percent-encoded.
	//
	function getEncodeCache(exclude) {
	  var i,
	      ch,
	      cache = encodeCache[exclude];
	  if (cache) {
	    return cache;
	  }

	  cache = encodeCache[exclude] = [];

	  for (i = 0; i < 128; i++) {
	    ch = String.fromCharCode(i);

	    if (/^[0-9a-z]$/i.test(ch)) {
	      // always allow unencoded alphanumeric characters
	      cache.push(ch);
	    } else {
	      cache.push('%' + ('0' + i.toString(16).toUpperCase()).slice(-2));
	    }
	  }

	  for (i = 0; i < exclude.length; i++) {
	    cache[exclude.charCodeAt(i)] = exclude[i];
	  }

	  return cache;
	}

	// Encode unsafe characters with percent-encoding, skipping already
	// encoded sequences.
	//
	//  - string       - string to encode
	//  - exclude      - list of characters to ignore (in addition to a-zA-Z0-9)
	//  - keepEscaped  - don't encode '%' in a correct escape sequence (default: true)
	//
	function encode(string, exclude, keepEscaped) {
	  var i,
	      l,
	      code,
	      nextCode,
	      cache,
	      result = '';

	  if (typeof exclude !== 'string') {
	    // encode(string, keepEscaped)
	    keepEscaped = exclude;
	    exclude = encode.defaultChars;
	  }

	  if (typeof keepEscaped === 'undefined') {
	    keepEscaped = true;
	  }

	  cache = getEncodeCache(exclude);

	  for (i = 0, l = string.length; i < l; i++) {
	    code = string.charCodeAt(i);

	    if (keepEscaped && code === 0x25 /* % */ && i + 2 < l) {
	      if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {
	        result += string.slice(i, i + 3);
	        i += 2;
	        continue;
	      }
	    }

	    if (code < 128) {
	      result += cache[code];
	      continue;
	    }

	    if (code >= 0xD800 && code <= 0xDFFF) {
	      if (code >= 0xD800 && code <= 0xDBFF && i + 1 < l) {
	        nextCode = string.charCodeAt(i + 1);
	        if (nextCode >= 0xDC00 && nextCode <= 0xDFFF) {
	          result += encodeURIComponent(string[i] + string[i + 1]);
	          i++;
	          continue;
	        }
	      }
	      result += '%EF%BF%BD';
	      continue;
	    }

	    result += encodeURIComponent(string[i]);
	  }

	  return result;
	}

	encode.defaultChars = ";/?:@&=+$,-_.!~*'()#";
	encode.componentChars = "-_.!~*'()";

	module.exports = encode;

/***/ },
/* 64 */
/***/ function(module, exports) {

	'use strict'

	/* eslint-disable no-bitwise */

	;
	var decodeCache = {};

	function getDecodeCache(exclude) {
	  var i,
	      ch,
	      cache = decodeCache[exclude];
	  if (cache) {
	    return cache;
	  }

	  cache = decodeCache[exclude] = [];

	  for (i = 0; i < 128; i++) {
	    ch = String.fromCharCode(i);
	    cache.push(ch);
	  }

	  for (i = 0; i < exclude.length; i++) {
	    ch = exclude.charCodeAt(i);
	    cache[ch] = '%' + ('0' + ch.toString(16).toUpperCase()).slice(-2);
	  }

	  return cache;
	}

	// Decode percent-encoded string.
	//
	function decode(string, exclude) {
	  var cache;

	  if (typeof exclude !== 'string') {
	    exclude = decode.defaultChars;
	  }

	  cache = getDecodeCache(exclude);

	  return string.replace(/(%[a-f0-9]{2})+/gi, function (seq) {
	    var i,
	        l,
	        b1,
	        b2,
	        b3,
	        b4,
	        chr,
	        result = '';

	    for (i = 0, l = seq.length; i < l; i += 3) {
	      b1 = parseInt(seq.slice(i + 1, i + 3), 16);

	      if (b1 < 0x80) {
	        result += cache[b1];
	        continue;
	      }

	      if ((b1 & 0xE0) === 0xC0 && i + 3 < l) {
	        // 110xxxxx 10xxxxxx
	        b2 = parseInt(seq.slice(i + 4, i + 6), 16);

	        if ((b2 & 0xC0) === 0x80) {
	          chr = b1 << 6 & 0x7C0 | b2 & 0x3F;

	          if (chr < 0x80) {
	            result += '\ufffd\ufffd';
	          } else {
	            result += String.fromCharCode(chr);
	          }

	          i += 3;
	          continue;
	        }
	      }

	      if ((b1 & 0xF0) === 0xE0 && i + 6 < l) {
	        // 1110xxxx 10xxxxxx 10xxxxxx
	        b2 = parseInt(seq.slice(i + 4, i + 6), 16);
	        b3 = parseInt(seq.slice(i + 7, i + 9), 16);

	        if ((b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80) {
	          chr = b1 << 12 & 0xF000 | b2 << 6 & 0xFC0 | b3 & 0x3F;

	          if (chr < 0x800 || chr >= 0xD800 && chr <= 0xDFFF) {
	            result += '\ufffd\ufffd\ufffd';
	          } else {
	            result += String.fromCharCode(chr);
	          }

	          i += 6;
	          continue;
	        }
	      }

	      if ((b1 & 0xF8) === 0xF0 && i + 9 < l) {
	        // 111110xx 10xxxxxx 10xxxxxx 10xxxxxx
	        b2 = parseInt(seq.slice(i + 4, i + 6), 16);
	        b3 = parseInt(seq.slice(i + 7, i + 9), 16);
	        b4 = parseInt(seq.slice(i + 10, i + 12), 16);

	        if ((b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80 && (b4 & 0xC0) === 0x80) {
	          chr = b1 << 18 & 0x1C0000 | b2 << 12 & 0x3F000 | b3 << 6 & 0xFC0 | b4 & 0x3F;

	          if (chr < 0x10000 || chr > 0x10FFFF) {
	            result += '\ufffd\ufffd\ufffd\ufffd';
	          } else {
	            chr -= 0x10000;
	            result += String.fromCharCode(0xD800 + (chr >> 10), 0xDC00 + (chr & 0x3FF));
	          }

	          i += 9;
	          continue;
	        }
	      }

	      result += '\ufffd';
	    }

	    return result;
	  });
	}

	decode.defaultChars = ';/?:@&=+$,#';
	decode.componentChars = '';

	module.exports = decode;

/***/ },
/* 65 */
/***/ function(module, exports) {

	'use strict';

	module.exports = function format(url) {
	  var result = '';

	  result += url.protocol || '';
	  result += url.slashes ? '//' : '';
	  result += url.auth ? url.auth + '@' : '';

	  if (url.hostname && url.hostname.indexOf(':') !== -1) {
	    // ipv6 address
	    result += '[' + url.hostname + ']';
	  } else {
	    result += url.hostname || '';
	  }

	  result += url.port ? ':' + url.port : '';
	  result += url.pathname || '';
	  result += url.search || '';
	  result += url.hash || '';

	  return result;
	};

/***/ },
/* 66 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	'use strict'

	//
	// Changes from joyent/node:
	//
	// 1. No leading slash in paths,
	//    e.g. in `url.parse('http://foo?bar')` pathname is ``, not `/`
	//
	// 2. Backslashes are not replaced with slashes,
	//    so `http:\\example.org\` is treated like a relative path
	//
	// 3. Trailing colon is treated like a part of the path,
	//    i.e. in `http://example.org:foo` pathname is `:foo`
	//
	// 4. Nothing is URL-encoded in the resulting object,
	//    (in joyent/node some chars in auth and paths are encoded)
	//
	// 5. `url.parse()` does not have `parseQueryString` argument
	//
	// 6. Removed extraneous result properties: `host`, `path`, `query`, etc.,
	//    which can be constructed using other parts of the url.
	//

	;
	function Url() {
	  this.protocol = null;
	  this.slashes = null;
	  this.auth = null;
	  this.port = null;
	  this.hostname = null;
	  this.hash = null;
	  this.search = null;
	  this.pathname = null;
	}

	// Reference: RFC 3986, RFC 1808, RFC 2396

	// define these here so at least they only have to be
	// compiled once on the first module load.
	var protocolPattern = /^([a-z0-9.+-]+:)/i,
	    portPattern = /:[0-9]*$/,

	// Special case for a simple path URL
	simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

	// RFC 2396: characters reserved for delimiting URLs.
	// We actually just auto-escape these.
	delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

	// RFC 2396: characters not allowed for various reasons.
	unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

	// Allowed by RFCs, but cause of XSS attacks.  Always escape these.
	autoEscape = ['\''].concat(unwise),

	// Characters that are never ever allowed in a hostname.
	// Note that any invalid chars are also handled, but these
	// are the ones that are *expected* to be seen, so we fast-path
	// them.
	nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
	    hostEndingChars = ['/', '?', '#'],
	    hostnameMaxLen = 255,
	    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
	    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,

	// protocols that can allow "unsafe" and "unwise" chars.
	/* eslint-disable no-script-url */
	// protocols that never have a hostname.
	hostlessProtocol = {
	  'javascript': true,
	  'javascript:': true
	},

	// protocols that always contain a // bit.
	slashedProtocol = {
	  'http': true,
	  'https': true,
	  'ftp': true,
	  'gopher': true,
	  'file': true,
	  'http:': true,
	  'https:': true,
	  'ftp:': true,
	  'gopher:': true,
	  'file:': true
	};
	/* eslint-enable no-script-url */

	function urlParse(url, slashesDenoteHost) {
	  if (url && url instanceof Url) {
	    return url;
	  }

	  var u = new Url();
	  u.parse(url, slashesDenoteHost);
	  return u;
	}

	Url.prototype.parse = function (url, slashesDenoteHost) {
	  var i,
	      l,
	      lowerProto,
	      hec,
	      slashes,
	      rest = url;

	  // trim before proceeding.
	  // This is to support parse stuff like "  http://foo.com  \n"
	  rest = rest.trim();

	  if (!slashesDenoteHost && url.split('#').length === 1) {
	    // Try fast path regexp
	    var simplePath = simplePathPattern.exec(rest);
	    if (simplePath) {
	      this.pathname = simplePath[1];
	      if (simplePath[2]) {
	        this.search = simplePath[2];
	      }
	      return this;
	    }
	  }

	  var proto = protocolPattern.exec(rest);
	  if (proto) {
	    proto = proto[0];
	    lowerProto = proto.toLowerCase();
	    this.protocol = proto;
	    rest = rest.substr(proto.length);
	  }

	  // figure out if it's got a host
	  // user@server is *always* interpreted as a hostname, and url
	  // resolution will treat //foo/bar as host=foo,path=bar because that's
	  // how the browser resolves relative URLs.
	  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
	    slashes = rest.substr(0, 2) === '//';
	    if (slashes && !(proto && hostlessProtocol[proto])) {
	      rest = rest.substr(2);
	      this.slashes = true;
	    }
	  }

	  if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {

	    // there's a hostname.
	    // the first instance of /, ?, ;, or # ends the host.
	    //
	    // If there is an @ in the hostname, then non-host chars *are* allowed
	    // to the left of the last @ sign, unless some host-ending character
	    // comes *before* the @-sign.
	    // URLs are obnoxious.
	    //
	    // ex:
	    // http://a@b@c/ => user:a@b host:c
	    // http://a@b?@c => user:a host:c path:/?@c

	    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
	    // Review our test case against browsers more comprehensively.

	    // find the first instance of any hostEndingChars
	    var hostEnd = -1;
	    for (i = 0; i < hostEndingChars.length; i++) {
	      hec = rest.indexOf(hostEndingChars[i]);
	      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
	        hostEnd = hec;
	      }
	    }

	    // at this point, either we have an explicit point where the
	    // auth portion cannot go past, or the last @ char is the decider.
	    var auth, atSign;
	    if (hostEnd === -1) {
	      // atSign can be anywhere.
	      atSign = rest.lastIndexOf('@');
	    } else {
	      // atSign must be in auth portion.
	      // http://a@b/c@d => host:b auth:a path:/c@d
	      atSign = rest.lastIndexOf('@', hostEnd);
	    }

	    // Now we have a portion which is definitely the auth.
	    // Pull that off.
	    if (atSign !== -1) {
	      auth = rest.slice(0, atSign);
	      rest = rest.slice(atSign + 1);
	      this.auth = auth;
	    }

	    // the host is the remaining to the left of the first non-host char
	    hostEnd = -1;
	    for (i = 0; i < nonHostChars.length; i++) {
	      hec = rest.indexOf(nonHostChars[i]);
	      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
	        hostEnd = hec;
	      }
	    }
	    // if we still have not hit it, then the entire thing is a host.
	    if (hostEnd === -1) {
	      hostEnd = rest.length;
	    }

	    if (rest[hostEnd - 1] === ':') {
	      hostEnd--;
	    }
	    var host = rest.slice(0, hostEnd);
	    rest = rest.slice(hostEnd);

	    // pull out port.
	    this.parseHost(host);

	    // we've indicated that there is a hostname,
	    // so even if it's empty, it has to be present.
	    this.hostname = this.hostname || '';

	    // if hostname begins with [ and ends with ]
	    // assume that it's an IPv6 address.
	    var ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']';

	    // validate a little.
	    if (!ipv6Hostname) {
	      var hostparts = this.hostname.split(/\./);
	      for (i = 0, l = hostparts.length; i < l; i++) {
	        var part = hostparts[i];
	        if (!part) {
	          continue;
	        }
	        if (!part.match(hostnamePartPattern)) {
	          var newpart = '';
	          for (var j = 0, k = part.length; j < k; j++) {
	            if (part.charCodeAt(j) > 127) {
	              // we replace non-ASCII char with a temporary placeholder
	              // we need this to make sure size of hostname is not
	              // broken by replacing non-ASCII by nothing
	              newpart += 'x';
	            } else {
	              newpart += part[j];
	            }
	          }
	          // we test again with ASCII char only
	          if (!newpart.match(hostnamePartPattern)) {
	            var validParts = hostparts.slice(0, i);
	            var notHost = hostparts.slice(i + 1);
	            var bit = part.match(hostnamePartStart);
	            if (bit) {
	              validParts.push(bit[1]);
	              notHost.unshift(bit[2]);
	            }
	            if (notHost.length) {
	              rest = notHost.join('.') + rest;
	            }
	            this.hostname = validParts.join('.');
	            break;
	          }
	        }
	      }
	    }

	    if (this.hostname.length > hostnameMaxLen) {
	      this.hostname = '';
	    }

	    // strip [ and ] from the hostname
	    // the host field still retains them, though
	    if (ipv6Hostname) {
	      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
	    }
	  }

	  // chop off from the tail first.
	  var hash = rest.indexOf('#');
	  if (hash !== -1) {
	    // got a fragment string.
	    this.hash = rest.substr(hash);
	    rest = rest.slice(0, hash);
	  }
	  var qm = rest.indexOf('?');
	  if (qm !== -1) {
	    this.search = rest.substr(qm);
	    rest = rest.slice(0, qm);
	  }
	  if (rest) {
	    this.pathname = rest;
	  }
	  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
	    this.pathname = '';
	  }

	  return this;
	};

	Url.prototype.parseHost = function (host) {
	  var port = portPattern.exec(host);
	  if (port) {
	    port = port[0];
	    if (port !== ':') {
	      this.port = port.substr(1);
	    }
	    host = host.substr(0, host.length - port.length);
	  }
	  if (host) {
	    this.hostname = host;
	  }
	};

	module.exports = urlParse;

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	
	module.exports.Any = __webpack_require__(68);
	module.exports.Cc = __webpack_require__(69);
	module.exports.Cf = __webpack_require__(70);
	module.exports.P = __webpack_require__(61);
	module.exports.Z = __webpack_require__(71);

/***/ },
/* 68 */
/***/ function(module, exports) {

	module.exports = /[\0-\uD7FF\uDC00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF]/;

/***/ },
/* 69 */
/***/ function(module, exports) {

	module.exports = /[\0-\x1F\x7F-\x9F]/;

/***/ },
/* 70 */
/***/ function(module, exports) {

	module.exports = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804\uDCBD|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/;

/***/ },
/* 71 */
/***/ function(module, exports) {

	module.exports = /[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/;

/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	// Just a shortcut for bulk export
	'use strict';

	exports.parseLinkLabel = __webpack_require__(73);
	exports.parseLinkDestination = __webpack_require__(74);
	exports.parseLinkTitle = __webpack_require__(75);

/***/ },
/* 73 */
/***/ function(module, exports) {

	// Parse link label
	//
	// this function assumes that first character ("[") already matches;
	// returns the end of the label
	//
	'use strict';

	module.exports = function parseLinkLabel(state, start, disableNested) {
	  var level,
	      found,
	      marker,
	      prevPos,
	      labelEnd = -1,
	      max = state.posMax,
	      oldPos = state.pos;

	  state.pos = start + 1;
	  level = 1;

	  while (state.pos < max) {
	    marker = state.src.charCodeAt(state.pos);
	    if (marker === 0x5D /* ] */) {
	        level--;
	        if (level === 0) {
	          found = true;
	          break;
	        }
	      }

	    prevPos = state.pos;
	    state.md.inline.skipToken(state);
	    if (marker === 0x5B /* [ */) {
	        if (prevPos === state.pos - 1) {
	          // increase level if we find text `[`, which is not a part of any token
	          level++;
	        } else if (disableNested) {
	          state.pos = oldPos;
	          return -1;
	        }
	      }
	  }

	  if (found) {
	    labelEnd = state.pos;
	  }

	  // restore old state
	  state.pos = oldPos;

	  return labelEnd;
	};

/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	// Parse link destination
	//
	'use strict';

	var unescapeAll = __webpack_require__(58).unescapeAll;

	module.exports = function parseLinkDestination(str, pos, max) {
	  var code,
	      level,
	      lines = 0,
	      start = pos,
	      result = {
	    ok: false,
	    pos: 0,
	    lines: 0,
	    str: ''
	  };

	  if (str.charCodeAt(pos) === 0x3C /* < */) {
	      pos++;
	      while (pos < max) {
	        code = str.charCodeAt(pos);
	        if (code === 0x0A /* \n */) {
	            return result;
	          }
	        if (code === 0x3E /* > */) {
	            result.pos = pos + 1;
	            result.str = unescapeAll(str.slice(start + 1, pos));
	            result.ok = true;
	            return result;
	          }
	        if (code === 0x5C /* \ */ && pos + 1 < max) {
	          pos += 2;
	          continue;
	        }

	        pos++;
	      }

	      // no closing '>'
	      return result;
	    }

	  // this should be ... } else { ... branch

	  level = 0;
	  while (pos < max) {
	    code = str.charCodeAt(pos);

	    if (code === 0x20) {
	      break;
	    }

	    // ascii control characters
	    if (code < 0x20 || code === 0x7F) {
	      break;
	    }

	    if (code === 0x5C /* \ */ && pos + 1 < max) {
	      pos += 2;
	      continue;
	    }

	    if (code === 0x28 /* ( */) {
	        level++;
	        if (level > 1) {
	          break;
	        }
	      }

	    if (code === 0x29 /* ) */) {
	        level--;
	        if (level < 0) {
	          break;
	        }
	      }

	    pos++;
	  }

	  if (start === pos) {
	    return result;
	  }

	  result.str = unescapeAll(str.slice(start, pos));
	  result.lines = lines;
	  result.pos = pos;
	  result.ok = true;
	  return result;
	};

/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	// Parse link title
	//
	'use strict';

	var unescapeAll = __webpack_require__(58).unescapeAll;

	module.exports = function parseLinkTitle(str, pos, max) {
	  var code,
	      marker,
	      lines = 0,
	      start = pos,
	      result = {
	    ok: false,
	    pos: 0,
	    lines: 0,
	    str: ''
	  };

	  if (pos >= max) {
	    return result;
	  }

	  marker = str.charCodeAt(pos);

	  if (marker !== 0x22 /* " */ && marker !== 0x27 /* ' */ && marker !== 0x28 /* ( */) {
	      return result;
	    }

	  pos++;

	  // if opening marker is "(", switch it to closing marker ")"
	  if (marker === 0x28) {
	    marker = 0x29;
	  }

	  while (pos < max) {
	    code = str.charCodeAt(pos);
	    if (code === marker) {
	      result.pos = pos + 1;
	      result.lines = lines;
	      result.str = unescapeAll(str.slice(start + 1, pos));
	      result.ok = true;
	      return result;
	    } else if (code === 0x0A) {
	      lines++;
	    } else if (code === 0x5C /* \ */ && pos + 1 < max) {
	      pos++;
	      if (str.charCodeAt(pos) === 0x0A) {
	        lines++;
	      }
	    }

	    pos++;
	  }

	  return result;
	};

/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * class Renderer
	 *
	 * Generates HTML from parsed token stream. Each instance has independent
	 * copy of rules. Those can be rewritten with ease. Also, you can add new
	 * rules if you create plugin and adds new token types.
	 **/
	'use strict';

	var assign = __webpack_require__(58).assign;
	var unescapeAll = __webpack_require__(58).unescapeAll;
	var escapeHtml = __webpack_require__(58).escapeHtml;

	////////////////////////////////////////////////////////////////////////////////

	var default_rules = {};

	default_rules.code_inline = function (tokens, idx /*, options, env */) {
	  return '<code>' + escapeHtml(tokens[idx].content) + '</code>';
	};

	default_rules.code_block = function (tokens, idx /*, options, env */) {
	  return '<pre><code>' + escapeHtml(tokens[idx].content) + '</code></pre>\n';
	};

	default_rules.fence = function (tokens, idx, options, env, slf) {
	  var token = tokens[idx],
	      info = token.info ? unescapeAll(token.info).trim() : '',
	      langName = '',
	      highlighted;

	  if (info) {
	    langName = info.split(/\s+/g)[0];
	    token.attrPush(['class', options.langPrefix + langName]);
	  }

	  if (options.highlight) {
	    highlighted = options.highlight(token.content, langName) || escapeHtml(token.content);
	  } else {
	    highlighted = escapeHtml(token.content);
	  }

	  return '<pre><code' + slf.renderAttrs(token) + '>' + highlighted + '</code></pre>\n';
	};

	default_rules.image = function (tokens, idx, options, env, slf) {
	  var token = tokens[idx];

	  // "alt" attr MUST be set, even if empty. Because it's mandatory and
	  // should be placed on proper position for tests.
	  //
	  // Replace content with actual value

	  token.attrs[token.attrIndex('alt')][1] = slf.renderInlineAsText(token.children, options, env);

	  return slf.renderToken(tokens, idx, options);
	};

	default_rules.hardbreak = function (tokens, idx, options /*, env */) {
	  return options.xhtmlOut ? '<br />\n' : '<br>\n';
	};
	default_rules.softbreak = function (tokens, idx, options /*, env */) {
	  return options.breaks ? options.xhtmlOut ? '<br />\n' : '<br>\n' : '\n';
	};

	default_rules.text = function (tokens, idx /*, options, env */) {
	  return escapeHtml(tokens[idx].content);
	};

	default_rules.html_block = function (tokens, idx /*, options, env */) {
	  return tokens[idx].content;
	};
	default_rules.html_inline = function (tokens, idx /*, options, env */) {
	  return tokens[idx].content;
	};

	/**
	 * new Renderer()
	 *
	 * Creates new [[Renderer]] instance and fill [[Renderer#rules]] with defaults.
	 **/
	function Renderer() {

	  /**
	   * Renderer#rules -> Object
	   *
	   * Contains render rules for tokens. Can be updated and extended.
	   *
	   * ##### Example
	   *
	   * ```javascript
	   * var md = require('markdown-it')();
	   *
	   * md.renderer.rules.strong_open  = function () { return '<b>'; };
	   * md.renderer.rules.strong_close = function () { return '</b>'; };
	   *
	   * var result = md.renderInline(...);
	   * ```
	   *
	   * Each rule is called as independed static function with fixed signature:
	   *
	   * ```javascript
	   * function my_token_render(tokens, idx, options, env, renderer) {
	   *   // ...
	   *   return renderedHTML;
	   * }
	   * ```
	   *
	   * See [source code](https://github.com/markdown-it/markdown-it/blob/master/lib/renderer.js)
	   * for more details and examples.
	   **/
	  this.rules = assign({}, default_rules);
	}

	/**
	 * Renderer.renderAttrs(token) -> String
	 *
	 * Render token attributes to string.
	 **/
	Renderer.prototype.renderAttrs = function renderAttrs(token) {
	  var i, l, result;

	  if (!token.attrs) {
	    return '';
	  }

	  result = '';

	  for (i = 0, l = token.attrs.length; i < l; i++) {
	    result += ' ' + escapeHtml(token.attrs[i][0]) + '="' + escapeHtml(token.attrs[i][1]) + '"';
	  }

	  return result;
	};

	/**
	 * Renderer.renderToken(tokens, idx, options) -> String
	 * - tokens (Array): list of tokens
	 * - idx (Numbed): token index to render
	 * - options (Object): params of parser instance
	 *
	 * Default token renderer. Can be overriden by custom function
	 * in [[Renderer#rules]].
	 **/
	Renderer.prototype.renderToken = function renderToken(tokens, idx, options) {
	  var nextToken,
	      result = '',
	      needLf = false,
	      token = tokens[idx];

	  // Tight list paragraphs
	  if (token.hidden) {
	    return '';
	  }

	  // Insert a newline between hidden paragraph and subsequent opening
	  // block-level tag.
	  //
	  // For example, here we should insert a newline before blockquote:
	  //  - a
	  //    >
	  //
	  if (token.block && token.nesting !== -1 && idx && tokens[idx - 1].hidden) {
	    result += '\n';
	  }

	  // Add token name, e.g. `<img`
	  result += (token.nesting === -1 ? '</' : '<') + token.tag;

	  // Encode attributes, e.g. `<img src="foo"`
	  result += this.renderAttrs(token);

	  // Add a slash for self-closing tags, e.g. `<img src="foo" /`
	  if (token.nesting === 0 && options.xhtmlOut) {
	    result += ' /';
	  }

	  // Check if we need to add a newline after this tag
	  if (token.block) {
	    needLf = true;

	    if (token.nesting === 1) {
	      if (idx + 1 < tokens.length) {
	        nextToken = tokens[idx + 1];

	        if (nextToken.type === 'inline' || nextToken.hidden) {
	          // Block-level tag containing an inline tag.
	          //
	          needLf = false;
	        } else if (nextToken.nesting === -1 && nextToken.tag === token.tag) {
	          // Opening tag + closing tag of the same type. E.g. `<li></li>`.
	          //
	          needLf = false;
	        }
	      }
	    }
	  }

	  result += needLf ? '>\n' : '>';

	  return result;
	};

	/**
	 * Renderer.renderInline(tokens, options, env) -> String
	 * - tokens (Array): list on block tokens to renter
	 * - options (Object): params of parser instance
	 * - env (Object): additional data from parsed input (references, for example)
	 *
	 * The same as [[Renderer.render]], but for single token of `inline` type.
	 **/
	Renderer.prototype.renderInline = function (tokens, options, env) {
	  var type,
	      result = '',
	      rules = this.rules;

	  for (var i = 0, len = tokens.length; i < len; i++) {
	    type = tokens[i].type;

	    if (typeof rules[type] !== 'undefined') {
	      result += rules[type](tokens, i, options, env, this);
	    } else {
	      result += this.renderToken(tokens, i, options);
	    }
	  }

	  return result;
	};

	/** internal
	 * Renderer.renderInlineAsText(tokens, options, env) -> String
	 * - tokens (Array): list on block tokens to renter
	 * - options (Object): params of parser instance
	 * - env (Object): additional data from parsed input (references, for example)
	 *
	 * Special kludge for image `alt` attributes to conform CommonMark spec.
	 * Don't try to use it! Spec requires to show `alt` content with stripped markup,
	 * instead of simple escaping.
	 **/
	Renderer.prototype.renderInlineAsText = function (tokens, options, env) {
	  var result = '',
	      rules = this.rules;

	  for (var i = 0, len = tokens.length; i < len; i++) {
	    if (tokens[i].type === 'text') {
	      result += rules.text(tokens, i, options, env, this);
	    } else if (tokens[i].type === 'image') {
	      result += this.renderInlineAsText(tokens[i].children, options, env);
	    }
	  }

	  return result;
	};

	/**
	 * Renderer.render(tokens, options, env) -> String
	 * - tokens (Array): list on block tokens to renter
	 * - options (Object): params of parser instance
	 * - env (Object): additional data from parsed input (references, for example)
	 *
	 * Takes token stream and generates HTML. Probably, you will never need to call
	 * this method directly.
	 **/
	Renderer.prototype.render = function (tokens, options, env) {
	  var i,
	      len,
	      type,
	      result = '',
	      rules = this.rules;

	  for (i = 0, len = tokens.length; i < len; i++) {
	    type = tokens[i].type;

	    if (type === 'inline') {
	      result += this.renderInline(tokens[i].children, options, env);
	    } else if (typeof rules[type] !== 'undefined') {
	      result += rules[tokens[i].type](tokens, i, options, env, this);
	    } else {
	      result += this.renderToken(tokens, i, options, env);
	    }
	  }

	  return result;
	};

	module.exports = Renderer;

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	/** internal
	 * class Core
	 *
	 * Top-level rules executor. Glues block/inline parsers and does intermediate
	 * transformations.
	 **/
	'use strict';

	var Ruler = __webpack_require__(78);

	var _rules = [['normalize', __webpack_require__(79)], ['block', __webpack_require__(80)], ['inline', __webpack_require__(81)], ['linkify', __webpack_require__(82)], ['replacements', __webpack_require__(83)], ['smartquotes', __webpack_require__(84)]];

	/**
	 * new Core()
	 **/
	function Core() {
	  /**
	   * Core#ruler -> Ruler
	   *
	   * [[Ruler]] instance. Keep configuration of core rules.
	   **/
	  this.ruler = new Ruler();

	  for (var i = 0; i < _rules.length; i++) {
	    this.ruler.push(_rules[i][0], _rules[i][1]);
	  }
	}

	/**
	 * Core.process(state)
	 *
	 * Executes core chain rules.
	 **/
	Core.prototype.process = function (state) {
	  var i, l, rules;

	  rules = this.ruler.getRules('');

	  for (i = 0, l = rules.length; i < l; i++) {
	    rules[i](state);
	  }
	};

	Core.prototype.State = __webpack_require__(85);

	module.exports = Core;

/***/ },
/* 78 */
/***/ function(module, exports) {

	/**
	 * class Ruler
	 *
	 * Helper class, used by [[MarkdownIt#core]], [[MarkdownIt#block]] and
	 * [[MarkdownIt#inline]] to manage sequences of functions (rules):
	 *
	 * - keep rules in defined order
	 * - assign the name to each rule
	 * - enable/disable rules
	 * - add/replace rules
	 * - allow assign rules to additional named chains (in the same)
	 * - cacheing lists of active rules
	 *
	 * You will not need use this class directly until write plugins. For simple
	 * rules control use [[MarkdownIt.disable]], [[MarkdownIt.enable]] and
	 * [[MarkdownIt.use]].
	 **/
	'use strict'

	/**
	 * new Ruler()
	 **/
	;
	function Ruler() {
	  // List of added rules. Each element is:
	  //
	  // {
	  //   name: XXX,
	  //   enabled: Boolean,
	  //   fn: Function(),
	  //   alt: [ name2, name3 ]
	  // }
	  //
	  this.__rules__ = [];

	  // Cached rule chains.
	  //
	  // First level - chain name, '' for default.
	  // Second level - diginal anchor for fast filtering by charcodes.
	  //
	  this.__cache__ = null;
	}

	////////////////////////////////////////////////////////////////////////////////
	// Helper methods, should not be used directly

	// Find rule index by name
	//
	Ruler.prototype.__find__ = function (name) {
	  for (var i = 0; i < this.__rules__.length; i++) {
	    if (this.__rules__[i].name === name) {
	      return i;
	    }
	  }
	  return -1;
	};

	// Build rules lookup cache
	//
	Ruler.prototype.__compile__ = function () {
	  var self = this;
	  var chains = [''];

	  // collect unique names
	  self.__rules__.forEach(function (rule) {
	    if (!rule.enabled) {
	      return;
	    }

	    rule.alt.forEach(function (altName) {
	      if (chains.indexOf(altName) < 0) {
	        chains.push(altName);
	      }
	    });
	  });

	  self.__cache__ = {};

	  chains.forEach(function (chain) {
	    self.__cache__[chain] = [];
	    self.__rules__.forEach(function (rule) {
	      if (!rule.enabled) {
	        return;
	      }

	      if (chain && rule.alt.indexOf(chain) < 0) {
	        return;
	      }

	      self.__cache__[chain].push(rule.fn);
	    });
	  });
	};

	/**
	 * Ruler.at(name, fn [, options])
	 * - name (String): rule name to replace.
	 * - fn (Function): new rule function.
	 * - options (Object): new rule options (not mandatory).
	 *
	 * Replace rule by name with new function & options. Throws error if name not
	 * found.
	 *
	 * ##### Options:
	 *
	 * - __alt__ - array with names of "alternate" chains.
	 *
	 * ##### Example
	 *
	 * Replace existing typorgapher replacement rule with new one:
	 *
	 * ```javascript
	 * var md = require('markdown-it')();
	 *
	 * md.core.ruler.at('replacements', function replace(state) {
	 *   //...
	 * });
	 * ```
	 **/
	Ruler.prototype.at = function (name, fn, options) {
	  var index = this.__find__(name);
	  var opt = options || {};

	  if (index === -1) {
	    throw new Error('Parser rule not found: ' + name);
	  }

	  this.__rules__[index].fn = fn;
	  this.__rules__[index].alt = opt.alt || [];
	  this.__cache__ = null;
	};

	/**
	 * Ruler.before(beforeName, ruleName, fn [, options])
	 * - beforeName (String): new rule will be added before this one.
	 * - ruleName (String): name of added rule.
	 * - fn (Function): rule function.
	 * - options (Object): rule options (not mandatory).
	 *
	 * Add new rule to chain before one with given name. See also
	 * [[Ruler.after]], [[Ruler.push]].
	 *
	 * ##### Options:
	 *
	 * - __alt__ - array with names of "alternate" chains.
	 *
	 * ##### Example
	 *
	 * ```javascript
	 * var md = require('markdown-it')();
	 *
	 * md.block.ruler.before('paragraph', 'my_rule', function replace(state) {
	 *   //...
	 * });
	 * ```
	 **/
	Ruler.prototype.before = function (beforeName, ruleName, fn, options) {
	  var index = this.__find__(beforeName);
	  var opt = options || {};

	  if (index === -1) {
	    throw new Error('Parser rule not found: ' + beforeName);
	  }

	  this.__rules__.splice(index, 0, {
	    name: ruleName,
	    enabled: true,
	    fn: fn,
	    alt: opt.alt || []
	  });

	  this.__cache__ = null;
	};

	/**
	 * Ruler.after(afterName, ruleName, fn [, options])
	 * - afterName (String): new rule will be added after this one.
	 * - ruleName (String): name of added rule.
	 * - fn (Function): rule function.
	 * - options (Object): rule options (not mandatory).
	 *
	 * Add new rule to chain after one with given name. See also
	 * [[Ruler.before]], [[Ruler.push]].
	 *
	 * ##### Options:
	 *
	 * - __alt__ - array with names of "alternate" chains.
	 *
	 * ##### Example
	 *
	 * ```javascript
	 * var md = require('markdown-it')();
	 *
	 * md.inline.ruler.after('text', 'my_rule', function replace(state) {
	 *   //...
	 * });
	 * ```
	 **/
	Ruler.prototype.after = function (afterName, ruleName, fn, options) {
	  var index = this.__find__(afterName);
	  var opt = options || {};

	  if (index === -1) {
	    throw new Error('Parser rule not found: ' + afterName);
	  }

	  this.__rules__.splice(index + 1, 0, {
	    name: ruleName,
	    enabled: true,
	    fn: fn,
	    alt: opt.alt || []
	  });

	  this.__cache__ = null;
	};

	/**
	 * Ruler.push(ruleName, fn [, options])
	 * - ruleName (String): name of added rule.
	 * - fn (Function): rule function.
	 * - options (Object): rule options (not mandatory).
	 *
	 * Push new rule to the end of chain. See also
	 * [[Ruler.before]], [[Ruler.after]].
	 *
	 * ##### Options:
	 *
	 * - __alt__ - array with names of "alternate" chains.
	 *
	 * ##### Example
	 *
	 * ```javascript
	 * var md = require('markdown-it')();
	 *
	 * md.core.ruler.push('my_rule', function replace(state) {
	 *   //...
	 * });
	 * ```
	 **/
	Ruler.prototype.push = function (ruleName, fn, options) {
	  var opt = options || {};

	  this.__rules__.push({
	    name: ruleName,
	    enabled: true,
	    fn: fn,
	    alt: opt.alt || []
	  });

	  this.__cache__ = null;
	};

	/**
	 * Ruler.enable(list [, ignoreInvalid]) -> Array
	 * - list (String|Array): list of rule names to enable.
	 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
	 *
	 * Enable rules with given names. If any rule name not found - throw Error.
	 * Errors can be disabled by second param.
	 *
	 * Returns list of found rule names (if no exception happened).
	 *
	 * See also [[Ruler.disable]], [[Ruler.enableOnly]].
	 **/
	Ruler.prototype.enable = function (list, ignoreInvalid) {
	  if (!Array.isArray(list)) {
	    list = [list];
	  }

	  var result = [];

	  // Search by name and enable
	  list.forEach(function (name) {
	    var idx = this.__find__(name);

	    if (idx < 0) {
	      if (ignoreInvalid) {
	        return;
	      }
	      throw new Error('Rules manager: invalid rule name ' + name);
	    }
	    this.__rules__[idx].enabled = true;
	    result.push(name);
	  }, this);

	  this.__cache__ = null;
	  return result;
	};

	/**
	 * Ruler.enableOnly(list [, ignoreInvalid])
	 * - list (String|Array): list of rule names to enable (whitelist).
	 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
	 *
	 * Enable rules with given names, and disable everything else. If any rule name
	 * not found - throw Error. Errors can be disabled by second param.
	 *
	 * See also [[Ruler.disable]], [[Ruler.enable]].
	 **/
	Ruler.prototype.enableOnly = function (list, ignoreInvalid) {
	  if (!Array.isArray(list)) {
	    list = [list];
	  }

	  this.__rules__.forEach(function (rule) {
	    rule.enabled = false;
	  });

	  this.enable(list, ignoreInvalid);
	};

	/**
	 * Ruler.disable(list [, ignoreInvalid]) -> Array
	 * - list (String|Array): list of rule names to disable.
	 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
	 *
	 * Disable rules with given names. If any rule name not found - throw Error.
	 * Errors can be disabled by second param.
	 *
	 * Returns list of found rule names (if no exception happened).
	 *
	 * See also [[Ruler.enable]], [[Ruler.enableOnly]].
	 **/
	Ruler.prototype.disable = function (list, ignoreInvalid) {
	  if (!Array.isArray(list)) {
	    list = [list];
	  }

	  var result = [];

	  // Search by name and disable
	  list.forEach(function (name) {
	    var idx = this.__find__(name);

	    if (idx < 0) {
	      if (ignoreInvalid) {
	        return;
	      }
	      throw new Error('Rules manager: invalid rule name ' + name);
	    }
	    this.__rules__[idx].enabled = false;
	    result.push(name);
	  }, this);

	  this.__cache__ = null;
	  return result;
	};

	/**
	 * Ruler.getRules(chainName) -> Array
	 *
	 * Return array of active functions (rules) for given chain name. It analyzes
	 * rules configuration, compiles caches if not exists and returns result.
	 *
	 * Default chain name is `''` (empty string). It can't be skipped. That's
	 * done intentionally, to keep signature monomorphic for high speed.
	 **/
	Ruler.prototype.getRules = function (chainName) {
	  if (this.__cache__ === null) {
	    this.__compile__();
	  }

	  // Chain can be empty, if rules disabled. But we still have to return Array.
	  return this.__cache__[chainName] || [];
	};

	module.exports = Ruler;

/***/ },
/* 79 */
/***/ function(module, exports) {

	// Normalize input string

	'use strict';

	var NEWLINES_RE = /\r[\n\u0085]|[\u2424\u2028\u0085]/g;
	var NULL_RE = /\u0000/g;

	module.exports = function inline(state) {
	  var str;

	  // Normalize newlines
	  str = state.src.replace(NEWLINES_RE, '\n');

	  // Replace NULL characters
	  str = str.replace(NULL_RE, '\uFFFD');

	  state.src = str;
	};

/***/ },
/* 80 */
/***/ function(module, exports) {

	'use strict';

	module.exports = function block(state) {
	  var token;

	  if (state.inlineMode) {
	    token = new state.Token('inline', '', 0);
	    token.content = state.src;
	    token.map = [0, 1];
	    token.children = [];
	    state.tokens.push(token);
	  } else {
	    state.md.block.parse(state.src, state.md, state.env, state.tokens);
	  }
	};

/***/ },
/* 81 */
/***/ function(module, exports) {

	'use strict';

	module.exports = function inline(state) {
	  var tokens = state.tokens,
	      tok,
	      i,
	      l;

	  // Parse inlines
	  for (i = 0, l = tokens.length; i < l; i++) {
	    tok = tokens[i];
	    if (tok.type === 'inline') {
	      state.md.inline.parse(tok.content, state.md, state.env, tok.children);
	    }
	  }
	};

/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	// Replace link-like texts with link nodes.
	//
	// Currently restricted by `md.validateLink()` to http/https/ftp
	//
	'use strict';

	var arrayReplaceAt = __webpack_require__(58).arrayReplaceAt;

	function isLinkOpen(str) {
	  return (/^<a[>\s]/i.test(str)
	  );
	}
	function isLinkClose(str) {
	  return (/^<\/a\s*>/i.test(str)
	  );
	}

	module.exports = function linkify(state) {
	  var i,
	      j,
	      l,
	      tokens,
	      token,
	      currentToken,
	      nodes,
	      ln,
	      text,
	      pos,
	      lastPos,
	      level,
	      htmlLinkLevel,
	      url,
	      fullUrl,
	      urlText,
	      blockTokens = state.tokens,
	      links;

	  if (!state.md.options.linkify) {
	    return;
	  }

	  for (j = 0, l = blockTokens.length; j < l; j++) {
	    if (blockTokens[j].type !== 'inline' || !state.md.linkify.pretest(blockTokens[j].content)) {
	      continue;
	    }

	    tokens = blockTokens[j].children;

	    htmlLinkLevel = 0;

	    // We scan from the end, to keep position when new tags added.
	    // Use reversed logic in links start/end match
	    for (i = tokens.length - 1; i >= 0; i--) {
	      currentToken = tokens[i];

	      // Skip content of markdown links
	      if (currentToken.type === 'link_close') {
	        i--;
	        while (tokens[i].level !== currentToken.level && tokens[i].type !== 'link_open') {
	          i--;
	        }
	        continue;
	      }

	      // Skip content of html tag links
	      if (currentToken.type === 'html_inline') {
	        if (isLinkOpen(currentToken.content) && htmlLinkLevel > 0) {
	          htmlLinkLevel--;
	        }
	        if (isLinkClose(currentToken.content)) {
	          htmlLinkLevel++;
	        }
	      }
	      if (htmlLinkLevel > 0) {
	        continue;
	      }

	      if (currentToken.type === 'text' && state.md.linkify.test(currentToken.content)) {

	        text = currentToken.content;
	        links = state.md.linkify.match(text);

	        // Now split string to nodes
	        nodes = [];
	        level = currentToken.level;
	        lastPos = 0;

	        for (ln = 0; ln < links.length; ln++) {

	          url = links[ln].url;
	          fullUrl = state.md.normalizeLink(url);
	          if (!state.md.validateLink(fullUrl)) {
	            continue;
	          }

	          urlText = links[ln].text;

	          // Linkifier might send raw hostnames like "example.com", where url
	          // starts with domain name. So we prepend http:// in those cases,
	          // and remove it afterwards.
	          //
	          if (!links[ln].schema) {
	            urlText = state.md.normalizeLinkText('http://' + urlText).replace(/^http:\/\//, '');
	          } else if (links[ln].schema === 'mailto:' && !/^mailto:/i.test(urlText)) {
	            urlText = state.md.normalizeLinkText('mailto:' + urlText).replace(/^mailto:/, '');
	          } else {
	            urlText = state.md.normalizeLinkText(urlText);
	          }

	          pos = links[ln].index;

	          if (pos > lastPos) {
	            token = new state.Token('text', '', 0);
	            token.content = text.slice(lastPos, pos);
	            token.level = level;
	            nodes.push(token);
	          }

	          token = new state.Token('link_open', 'a', 1);
	          token.attrs = [['href', fullUrl]];
	          token.level = level++;
	          token.markup = 'linkify';
	          token.info = 'auto';
	          nodes.push(token);

	          token = new state.Token('text', '', 0);
	          token.content = urlText;
	          token.level = level;
	          nodes.push(token);

	          token = new state.Token('link_close', 'a', -1);
	          token.level = --level;
	          token.markup = 'linkify';
	          token.info = 'auto';
	          nodes.push(token);

	          lastPos = links[ln].lastIndex;
	        }
	        if (lastPos < text.length) {
	          token = new state.Token('text', '', 0);
	          token.content = text.slice(lastPos);
	          token.level = level;
	          nodes.push(token);
	        }

	        // replace current node
	        blockTokens[j].children = tokens = arrayReplaceAt(tokens, i, nodes);
	      }
	    }
	  }
	};

/***/ },
/* 83 */
/***/ function(module, exports) {

	// Simple typographyc replacements
	//
	// (c) (C)  
	// (tm) (TM)  
	// (r) (R)  
	// +-  
	// (p) (P) -> 
	// ...   (also ?....  ?.., !....  !..)
	// ????????  ???, !!!!!  !!!, `,,`  `,`
	// --  &ndash;, ---  &mdash;
	//
	'use strict'

	// TODO:
	// - fractionals 1/2, 1/4, 3/4 -> , , 
	// - miltiplication 2 x 4 -> 2  4

	;
	var RARE_RE = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/;

	// Workaround for phantomjs - need regex without /g flag,
	// or root check will fail every second time
	var SCOPED_ABBR_TEST_RE = /\((c|tm|r|p)\)/i;

	var SCOPED_ABBR_RE = /\((c|tm|r|p)\)/ig;
	var SCOPED_ABBR = {
	  'c': '',
	  'r': '',
	  'p': '',
	  'tm': ''
	};

	function replaceFn(match, name) {
	  return SCOPED_ABBR[name.toLowerCase()];
	}

	function replace_scoped(inlineTokens) {
	  var i, token;

	  for (i = inlineTokens.length - 1; i >= 0; i--) {
	    token = inlineTokens[i];
	    if (token.type === 'text') {
	      token.content = token.content.replace(SCOPED_ABBR_RE, replaceFn);
	    }
	  }
	}

	function replace_rare(inlineTokens) {
	  var i, token;

	  for (i = inlineTokens.length - 1; i >= 0; i--) {
	    token = inlineTokens[i];
	    if (token.type === 'text') {
	      if (RARE_RE.test(token.content)) {
	        token.content = token.content.replace(/\+-/g, '')
	        // .., ..., ....... -> 
	        // but ?..... & !..... -> ?.. & !..
	        .replace(/\.{2,}/g, '').replace(/([?!])/g, '$1..').replace(/([?!]){4,}/g, '$1$1$1').replace(/,{2,}/g, ',')
	        // em-dash
	        .replace(/(^|[^-])---([^-]|$)/mg, '$1\u2014$2')
	        // en-dash
	        .replace(/(^|\s)--(\s|$)/mg, '$1\u2013$2').replace(/(^|[^-\s])--([^-\s]|$)/mg, '$1\u2013$2');
	      }
	    }
	  }
	}

	module.exports = function replace(state) {
	  var blkIdx;

	  if (!state.md.options.typographer) {
	    return;
	  }

	  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {

	    if (state.tokens[blkIdx].type !== 'inline') {
	      continue;
	    }

	    if (SCOPED_ABBR_TEST_RE.test(state.tokens[blkIdx].content)) {
	      replace_scoped(state.tokens[blkIdx].children);
	    }

	    if (RARE_RE.test(state.tokens[blkIdx].content)) {
	      replace_rare(state.tokens[blkIdx].children);
	    }
	  }
	};

/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	// Convert straight quotation marks to typographic ones
	//
	'use strict';

	var isWhiteSpace = __webpack_require__(58).isWhiteSpace;
	var isPunctChar = __webpack_require__(58).isPunctChar;
	var isMdAsciiPunct = __webpack_require__(58).isMdAsciiPunct;

	var QUOTE_TEST_RE = /['"]/;
	var QUOTE_RE = /['"]/g;
	var APOSTROPHE = '\u2019'; /*  */

	function replaceAt(str, index, ch) {
	  return str.substr(0, index) + ch + str.substr(index + 1);
	}

	function process_inlines(tokens, state) {
	  var i, token, text, t, pos, max, thisLevel, item, lastChar, nextChar, isLastPunctChar, isNextPunctChar, isLastWhiteSpace, isNextWhiteSpace, canOpen, canClose, j, isSingle, stack, openQuote, closeQuote;

	  stack = [];

	  for (i = 0; i < tokens.length; i++) {
	    token = tokens[i];

	    thisLevel = tokens[i].level;

	    for (j = stack.length - 1; j >= 0; j--) {
	      if (stack[j].level <= thisLevel) {
	        break;
	      }
	    }
	    stack.length = j + 1;

	    if (token.type !== 'text') {
	      continue;
	    }

	    text = token.content;
	    pos = 0;
	    max = text.length;

	    /*eslint no-labels:0,block-scoped-var:0*/
	    OUTER: while (pos < max) {
	      QUOTE_RE.lastIndex = pos;
	      t = QUOTE_RE.exec(text);
	      if (!t) {
	        break;
	      }

	      canOpen = canClose = true;
	      pos = t.index + 1;
	      isSingle = t[0] === "'";

	      // treat begin/end of the line as a whitespace
	      lastChar = t.index - 1 >= 0 ? text.charCodeAt(t.index - 1) : 0x20;
	      nextChar = pos < max ? text.charCodeAt(pos) : 0x20;

	      isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
	      isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));

	      isLastWhiteSpace = isWhiteSpace(lastChar);
	      isNextWhiteSpace = isWhiteSpace(nextChar);

	      if (isNextWhiteSpace) {
	        canOpen = false;
	      } else if (isNextPunctChar) {
	        if (!(isLastWhiteSpace || isLastPunctChar)) {
	          canOpen = false;
	        }
	      }

	      if (isLastWhiteSpace) {
	        canClose = false;
	      } else if (isLastPunctChar) {
	        if (!(isNextWhiteSpace || isNextPunctChar)) {
	          canClose = false;
	        }
	      }

	      if (nextChar === 0x22 /* " */ && t[0] === '"') {
	        if (lastChar >= 0x30 /* 0 */ && lastChar <= 0x39 /* 9 */) {
	            // special case: 1"" - count first quote as an inch
	            canClose = canOpen = false;
	          }
	      }

	      if (canOpen && canClose) {
	        // treat this as the middle of the word
	        canOpen = false;
	        canClose = isNextPunctChar;
	      }

	      if (!canOpen && !canClose) {
	        // middle of word
	        if (isSingle) {
	          token.content = replaceAt(token.content, t.index, APOSTROPHE);
	        }
	        continue;
	      }

	      if (canClose) {
	        // this could be a closing quote, rewind the stack to get a match
	        for (j = stack.length - 1; j >= 0; j--) {
	          item = stack[j];
	          if (stack[j].level < thisLevel) {
	            break;
	          }
	          if (item.single === isSingle && stack[j].level === thisLevel) {
	            item = stack[j];

	            if (isSingle) {
	              openQuote = state.md.options.quotes[2];
	              closeQuote = state.md.options.quotes[3];
	            } else {
	              openQuote = state.md.options.quotes[0];
	              closeQuote = state.md.options.quotes[1];
	            }

	            // replace token.content *before* tokens[item.token].content,
	            // because, if they are pointing at the same token, replaceAt
	            // could mess up indices when quote length != 1
	            token.content = replaceAt(token.content, t.index, closeQuote);
	            tokens[item.token].content = replaceAt(tokens[item.token].content, item.pos, openQuote);

	            pos += closeQuote.length - 1;
	            if (item.token === i) {
	              pos += openQuote.length - 1;
	            }

	            text = token.content;
	            max = text.length;

	            stack.length = j;
	            continue OUTER;
	          }
	        }
	      }

	      if (canOpen) {
	        stack.push({
	          token: i,
	          pos: t.index,
	          single: isSingle,
	          level: thisLevel
	        });
	      } else if (canClose && isSingle) {
	        token.content = replaceAt(token.content, t.index, APOSTROPHE);
	      }
	    }
	  }
	}

	module.exports = function smartquotes(state) {
	  /*eslint max-depth:0*/
	  var blkIdx;

	  if (!state.md.options.typographer) {
	    return;
	  }

	  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {

	    if (state.tokens[blkIdx].type !== 'inline' || !QUOTE_TEST_RE.test(state.tokens[blkIdx].content)) {
	      continue;
	    }

	    process_inlines(state.tokens[blkIdx].children, state);
	  }
	};

/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	// Core state object
	//
	'use strict';

	var Token = __webpack_require__(86);

	function StateCore(src, md, env) {
	  this.src = src;
	  this.env = env;
	  this.tokens = [];
	  this.inlineMode = false;
	  this.md = md; // link to parser instance
	}

	// re-export Token class to use in core rules
	StateCore.prototype.Token = Token;

	module.exports = StateCore;

/***/ },
/* 86 */
/***/ function(module, exports) {

	// Token class

	'use strict'

	/**
	 * class Token
	 **/

	/**
	 * new Token(type, tag, nesting)
	 *
	 * Create new token and fill passed properties.
	 **/
	;
	function Token(type, tag, nesting) {
	  /**
	   * Token#type -> String
	   *
	   * Type of the token (string, e.g. "paragraph_open")
	   **/
	  this.type = type;

	  /**
	   * Token#tag -> String
	   *
	   * html tag name, e.g. "p"
	   **/
	  this.tag = tag;

	  /**
	   * Token#attrs -> Array
	   *
	   * Html attributes. Format: `[ [ name1, value1 ], [ name2, value2 ] ]`
	   **/
	  this.attrs = null;

	  /**
	   * Token#map -> Array
	   *
	   * Source map info. Format: `[ line_begin, line_end ]`
	   **/
	  this.map = null;

	  /**
	   * Token#nesting -> Number
	   *
	   * Level change (number in {-1, 0, 1} set), where:
	   *
	   * -  `1` means the tag is opening
	   * -  `0` means the tag is self-closing
	   * - `-1` means the tag is closing
	   **/
	  this.nesting = nesting;

	  /**
	   * Token#level -> Number
	   *
	   * nesting level, the same as `state.level`
	   **/
	  this.level = 0;

	  /**
	   * Token#children -> Array
	   *
	   * An array of child nodes (inline and img tokens)
	   **/
	  this.children = null;

	  /**
	   * Token#content -> String
	   *
	   * In a case of self-closing tag (code, html, fence, etc.),
	   * it has contents of this tag.
	   **/
	  this.content = '';

	  /**
	   * Token#markup -> String
	   *
	   * '*' or '_' for emphasis, fence string for fence, etc.
	   **/
	  this.markup = '';

	  /**
	   * Token#info -> String
	   *
	   * fence infostring
	   **/
	  this.info = '';

	  /**
	   * Token#meta -> Object
	   *
	   * A place for plugins to store an arbitrary data
	   **/
	  this.meta = null;

	  /**
	   * Token#block -> Boolean
	   *
	   * True for block-level tokens, false for inline tokens.
	   * Used in renderer to calculate line breaks
	   **/
	  this.block = false;

	  /**
	   * Token#hidden -> Boolean
	   *
	   * If it's true, ignore this element when rendering. Used for tight lists
	   * to hide paragraphs.
	   **/
	  this.hidden = false;
	}

	/**
	 * Token.attrIndex(name) -> Number
	 *
	 * Search attribute index by name.
	 **/
	Token.prototype.attrIndex = function attrIndex(name) {
	  var attrs, i, len;

	  if (!this.attrs) {
	    return -1;
	  }

	  attrs = this.attrs;

	  for (i = 0, len = attrs.length; i < len; i++) {
	    if (attrs[i][0] === name) {
	      return i;
	    }
	  }
	  return -1;
	};

	/**
	 * Token.attrPush(attrData)
	 *
	 * Add `[ name, value ]` attribute to list. Init attrs if necessary
	 **/
	Token.prototype.attrPush = function attrPush(attrData) {
	  if (this.attrs) {
	    this.attrs.push(attrData);
	  } else {
	    this.attrs = [attrData];
	  }
	};

	module.exports = Token;

/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	/** internal
	 * class ParserBlock
	 *
	 * Block-level tokenizer.
	 **/
	'use strict';

	var Ruler = __webpack_require__(78);

	var _rules = [
	// First 2 params - rule name & source. Secondary array - list of rules,
	// which can be terminated by this one.
	['table', __webpack_require__(88), ['paragraph', 'reference']], ['code', __webpack_require__(89)], ['fence', __webpack_require__(90), ['paragraph', 'reference', 'blockquote', 'list']], ['blockquote', __webpack_require__(91), ['paragraph', 'reference', 'list']], ['hr', __webpack_require__(92), ['paragraph', 'reference', 'blockquote', 'list']], ['list', __webpack_require__(93), ['paragraph', 'reference', 'blockquote']], ['reference', __webpack_require__(94)], ['heading', __webpack_require__(95), ['paragraph', 'reference', 'blockquote']], ['lheading', __webpack_require__(96)], ['html_block', __webpack_require__(97), ['paragraph', 'reference', 'blockquote']], ['paragraph', __webpack_require__(100)]];

	/**
	 * new ParserBlock()
	 **/
	function ParserBlock() {
	  /**
	   * ParserBlock#ruler -> Ruler
	   *
	   * [[Ruler]] instance. Keep configuration of block rules.
	   **/
	  this.ruler = new Ruler();

	  for (var i = 0; i < _rules.length; i++) {
	    this.ruler.push(_rules[i][0], _rules[i][1], { alt: (_rules[i][2] || []).slice() });
	  }
	}

	// Generate tokens for input range
	//
	ParserBlock.prototype.tokenize = function (state, startLine, endLine) {
	  var ok,
	      i,
	      rules = this.ruler.getRules(''),
	      len = rules.length,
	      line = startLine,
	      hasEmptyLines = false,
	      maxNesting = state.md.options.maxNesting;

	  while (line < endLine) {
	    state.line = line = state.skipEmptyLines(line);
	    if (line >= endLine) {
	      break;
	    }

	    // Termination condition for nested calls.
	    // Nested calls currently used for blockquotes & lists
	    if (state.sCount[line] < state.blkIndent) {
	      break;
	    }

	    // If nesting level exceeded - skip tail to the end. That's not ordinary
	    // situation and we should not care about content.
	    if (state.level >= maxNesting) {
	      state.line = endLine;
	      break;
	    }

	    // Try all possible rules.
	    // On success, rule should:
	    //
	    // - update `state.line`
	    // - update `state.tokens`
	    // - return true

	    for (i = 0; i < len; i++) {
	      ok = rules[i](state, line, endLine, false);
	      if (ok) {
	        break;
	      }
	    }

	    // set state.tight iff we had an empty line before current tag
	    // i.e. latest empty line should not count
	    state.tight = !hasEmptyLines;

	    // paragraph might "eat" one newline after it in nested lists
	    if (state.isEmpty(state.line - 1)) {
	      hasEmptyLines = true;
	    }

	    line = state.line;

	    if (line < endLine && state.isEmpty(line)) {
	      hasEmptyLines = true;
	      line++;

	      // two empty lines should stop the parser in list mode
	      if (line < endLine && state.parentType === 'list' && state.isEmpty(line)) {
	        break;
	      }
	      state.line = line;
	    }
	  }
	};

	/**
	 * ParserBlock.parse(str, md, env, outTokens)
	 *
	 * Process input string and push block tokens into `outTokens`
	 **/
	ParserBlock.prototype.parse = function (src, md, env, outTokens) {
	  var state;

	  if (!src) {
	    return [];
	  }

	  state = new this.State(src, md, env, outTokens);

	  this.tokenize(state, state.line, state.lineMax);
	};

	ParserBlock.prototype.State = __webpack_require__(101);

	module.exports = ParserBlock;

/***/ },
/* 88 */
/***/ function(module, exports) {

	// GFM table, non-standard

	'use strict';

	function getLine(state, line) {
	  var pos = state.bMarks[line] + state.blkIndent,
	      max = state.eMarks[line];

	  return state.src.substr(pos, max - pos);
	}

	function escapedSplit(str) {
	  var result = [],
	      pos = 0,
	      max = str.length,
	      ch,
	      escapes = 0,
	      lastPos = 0,
	      backTicked = false,
	      lastBackTick = 0;

	  ch = str.charCodeAt(pos);

	  while (pos < max) {
	    if (ch === 0x60 /* ` */ && escapes % 2 === 0) {
	      backTicked = !backTicked;
	      lastBackTick = pos;
	    } else if (ch === 0x7c /* | */ && escapes % 2 === 0 && !backTicked) {
	      result.push(str.substring(lastPos, pos));
	      lastPos = pos + 1;
	    } else if (ch === 0x5c /* \ */) {
	        escapes++;
	      } else {
	      escapes = 0;
	    }

	    pos++;

	    // If there was an un-closed backtick, go back to just after
	    // the last backtick, but as if it was a normal character
	    if (pos === max && backTicked) {
	      backTicked = false;
	      pos = lastBackTick + 1;
	    }

	    ch = str.charCodeAt(pos);
	  }

	  result.push(str.substring(lastPos));

	  return result;
	}

	module.exports = function table(state, startLine, endLine, silent) {
	  var ch, lineText, pos, i, nextLine, rows, token, aligns, t, tableLines, tbodyLines;

	  // should have at least three lines
	  if (startLine + 2 > endLine) {
	    return false;
	  }

	  nextLine = startLine + 1;

	  if (state.sCount[nextLine] < state.blkIndent) {
	    return false;
	  }

	  // first character of the second line should be '|' or '-'

	  pos = state.bMarks[nextLine] + state.tShift[nextLine];
	  if (pos >= state.eMarks[nextLine]) {
	    return false;
	  }

	  ch = state.src.charCodeAt(pos);
	  if (ch !== 0x7C /* | */ && ch !== 0x2D /* - */ && ch !== 0x3A /* : */) {
	      return false;
	    }

	  lineText = getLine(state, startLine + 1);
	  if (!/^[-:| ]+$/.test(lineText)) {
	    return false;
	  }

	  rows = lineText.split('|');
	  if (rows.length < 2) {
	    return false;
	  }
	  aligns = [];
	  for (i = 0; i < rows.length; i++) {
	    t = rows[i].trim();
	    if (!t) {
	      // allow empty columns before and after table, but not in between columns;
	      // e.g. allow ` |---| `, disallow ` ---||--- `
	      if (i === 0 || i === rows.length - 1) {
	        continue;
	      } else {
	        return false;
	      }
	    }

	    if (!/^:?-+:?$/.test(t)) {
	      return false;
	    }
	    if (t.charCodeAt(t.length - 1) === 0x3A /* : */) {
	        aligns.push(t.charCodeAt(0) === 0x3A /* : */ ? 'center' : 'right');
	      } else if (t.charCodeAt(0) === 0x3A /* : */) {
	        aligns.push('left');
	      } else {
	      aligns.push('');
	    }
	  }

	  lineText = getLine(state, startLine).trim();
	  if (lineText.indexOf('|') === -1) {
	    return false;
	  }
	  rows = escapedSplit(lineText.replace(/^\||\|$/g, ''));
	  if (aligns.length !== rows.length) {
	    return false;
	  }
	  if (silent) {
	    return true;
	  }

	  token = state.push('table_open', 'table', 1);
	  token.map = tableLines = [startLine, 0];

	  token = state.push('thead_open', 'thead', 1);
	  token.map = [startLine, startLine + 1];

	  token = state.push('tr_open', 'tr', 1);
	  token.map = [startLine, startLine + 1];

	  for (i = 0; i < rows.length; i++) {
	    token = state.push('th_open', 'th', 1);
	    token.map = [startLine, startLine + 1];
	    if (aligns[i]) {
	      token.attrs = [['style', 'text-align:' + aligns[i]]];
	    }

	    token = state.push('inline', '', 0);
	    token.content = rows[i].trim();
	    token.map = [startLine, startLine + 1];
	    token.children = [];

	    token = state.push('th_close', 'th', -1);
	  }

	  token = state.push('tr_close', 'tr', -1);
	  token = state.push('thead_close', 'thead', -1);

	  token = state.push('tbody_open', 'tbody', 1);
	  token.map = tbodyLines = [startLine + 2, 0];

	  for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {
	    if (state.sCount[nextLine] < state.blkIndent) {
	      break;
	    }

	    lineText = getLine(state, nextLine).trim();
	    if (lineText.indexOf('|') === -1) {
	      break;
	    }
	    rows = escapedSplit(lineText.replace(/^\||\|$/g, ''));

	    // set number of columns to number of columns in header row
	    rows.length = aligns.length;

	    token = state.push('tr_open', 'tr', 1);
	    for (i = 0; i < rows.length; i++) {
	      token = state.push('td_open', 'td', 1);
	      if (aligns[i]) {
	        token.attrs = [['style', 'text-align:' + aligns[i]]];
	      }

	      token = state.push('inline', '', 0);
	      token.content = rows[i] ? rows[i].trim() : '';
	      token.children = [];

	      token = state.push('td_close', 'td', -1);
	    }
	    token = state.push('tr_close', 'tr', -1);
	  }
	  token = state.push('tbody_close', 'tbody', -1);
	  token = state.push('table_close', 'table', -1);

	  tableLines[1] = tbodyLines[1] = nextLine;
	  state.line = nextLine;
	  return true;
	};

/***/ },
/* 89 */
/***/ function(module, exports) {

	// Code block (4 spaces padded)

	'use strict';

	module.exports = function code(state, startLine, endLine /*, silent*/) {
	  var nextLine, last, token;

	  if (state.sCount[startLine] - state.blkIndent < 4) {
	    return false;
	  }

	  last = nextLine = startLine + 1;

	  while (nextLine < endLine) {
	    if (state.isEmpty(nextLine)) {
	      nextLine++;
	      continue;
	    }
	    if (state.sCount[nextLine] - state.blkIndent >= 4) {
	      nextLine++;
	      last = nextLine;
	      continue;
	    }
	    break;
	  }

	  state.line = nextLine;

	  token = state.push('code_block', 'code', 0);
	  token.content = state.getLines(startLine, last, 4 + state.blkIndent, true);
	  token.map = [startLine, state.line];

	  return true;
	};

/***/ },
/* 90 */
/***/ function(module, exports) {

	// fences (``` lang, ~~~ lang)

	'use strict';

	module.exports = function fence(state, startLine, endLine, silent) {
	  var marker,
	      len,
	      params,
	      nextLine,
	      mem,
	      token,
	      markup,
	      haveEndMarker = false,
	      pos = state.bMarks[startLine] + state.tShift[startLine],
	      max = state.eMarks[startLine];

	  if (pos + 3 > max) {
	    return false;
	  }

	  marker = state.src.charCodeAt(pos);

	  if (marker !== 0x7E /* ~ */ && marker !== 0x60 /* ` */) {
	      return false;
	    }

	  // scan marker length
	  mem = pos;
	  pos = state.skipChars(pos, marker);

	  len = pos - mem;

	  if (len < 3) {
	    return false;
	  }

	  markup = state.src.slice(mem, pos);
	  params = state.src.slice(pos, max);

	  if (params.indexOf('`') >= 0) {
	    return false;
	  }

	  // Since start is found, we can report success here in validation mode
	  if (silent) {
	    return true;
	  }

	  // search end of block
	  nextLine = startLine;

	  for (;;) {
	    nextLine++;
	    if (nextLine >= endLine) {
	      // unclosed block should be autoclosed by end of document.
	      // also block seems to be autoclosed by end of parent
	      break;
	    }

	    pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];
	    max = state.eMarks[nextLine];

	    if (pos < max && state.sCount[nextLine] < state.blkIndent) {
	      // non-empty line with negative indent should stop the list:
	      // - ```
	      //  test
	      break;
	    }

	    if (state.src.charCodeAt(pos) !== marker) {
	      continue;
	    }

	    if (state.sCount[nextLine] - state.blkIndent >= 4) {
	      // closing fence should be indented less than 4 spaces
	      continue;
	    }

	    pos = state.skipChars(pos, marker);

	    // closing code fence must be at least as long as the opening one
	    if (pos - mem < len) {
	      continue;
	    }

	    // make sure tail has spaces only
	    pos = state.skipSpaces(pos);

	    if (pos < max) {
	      continue;
	    }

	    haveEndMarker = true;
	    // found!
	    break;
	  }

	  // If a fence has heading spaces, they should be removed from its inner block
	  len = state.sCount[startLine];

	  state.line = nextLine + (haveEndMarker ? 1 : 0);

	  token = state.push('fence', 'code', 0);
	  token.info = params;
	  token.content = state.getLines(startLine + 1, nextLine, len, true);
	  token.markup = markup;
	  token.map = [startLine, state.line];

	  return true;
	};

/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	// Block quotes

	'use strict';

	var isSpace = __webpack_require__(58).isSpace;

	module.exports = function blockquote(state, startLine, endLine, silent) {
	  var nextLine,
	      lastLineEmpty,
	      oldTShift,
	      oldSCount,
	      oldBMarks,
	      oldIndent,
	      oldParentType,
	      lines,
	      initial,
	      offset,
	      ch,
	      terminatorRules,
	      token,
	      i,
	      l,
	      terminate,
	      pos = state.bMarks[startLine] + state.tShift[startLine],
	      max = state.eMarks[startLine];

	  // check the block quote marker
	  if (state.src.charCodeAt(pos++) !== 0x3E /* > */) {
	      return false;
	    }

	  // we know that it's going to be a valid blockquote,
	  // so no point trying to find the end of it in silent mode
	  if (silent) {
	    return true;
	  }

	  // skip one optional space (but not tab, check cmark impl) after '>'
	  if (state.src.charCodeAt(pos) === 0x20) {
	    pos++;
	  }

	  oldIndent = state.blkIndent;
	  state.blkIndent = 0;

	  // skip spaces after ">" and re-calculate offset
	  initial = offset = state.sCount[startLine] + pos - (state.bMarks[startLine] + state.tShift[startLine]);

	  oldBMarks = [state.bMarks[startLine]];
	  state.bMarks[startLine] = pos;

	  while (pos < max) {
	    ch = state.src.charCodeAt(pos);

	    if (isSpace(ch)) {
	      if (ch === 0x09) {
	        offset += 4 - offset % 4;
	      } else {
	        offset++;
	      }
	    } else {
	      break;
	    }

	    pos++;
	  }

	  lastLineEmpty = pos >= max;

	  oldSCount = [state.sCount[startLine]];
	  state.sCount[startLine] = offset - initial;

	  oldTShift = [state.tShift[startLine]];
	  state.tShift[startLine] = pos - state.bMarks[startLine];

	  terminatorRules = state.md.block.ruler.getRules('blockquote');

	  // Search the end of the block
	  //
	  // Block ends with either:
	  //  1. an empty line outside:
	  //     ```
	  //     > test
	  //
	  //     ```
	  //  2. an empty line inside:
	  //     ```
	  //     >
	  //     test
	  //     ```
	  //  3. another tag
	  //     ```
	  //     > test
	  //      - - -
	  //     ```
	  for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {
	    if (state.sCount[nextLine] < oldIndent) {
	      break;
	    }

	    pos = state.bMarks[nextLine] + state.tShift[nextLine];
	    max = state.eMarks[nextLine];

	    if (pos >= max) {
	      // Case 1: line is not inside the blockquote, and this line is empty.
	      break;
	    }

	    if (state.src.charCodeAt(pos++) === 0x3E /* > */) {
	        // This line is inside the blockquote.

	        // skip one optional space (but not tab, check cmark impl) after '>'
	        if (state.src.charCodeAt(pos) === 0x20) {
	          pos++;
	        }

	        // skip spaces after ">" and re-calculate offset
	        initial = offset = state.sCount[nextLine] + pos - (state.bMarks[nextLine] + state.tShift[nextLine]);

	        oldBMarks.push(state.bMarks[nextLine]);
	        state.bMarks[nextLine] = pos;

	        while (pos < max) {
	          ch = state.src.charCodeAt(pos);

	          if (isSpace(ch)) {
	            if (ch === 0x09) {
	              offset += 4 - offset % 4;
	            } else {
	              offset++;
	            }
	          } else {
	            break;
	          }

	          pos++;
	        }

	        lastLineEmpty = pos >= max;

	        oldSCount.push(state.sCount[nextLine]);
	        state.sCount[nextLine] = offset - initial;

	        oldTShift.push(state.tShift[nextLine]);
	        state.tShift[nextLine] = pos - state.bMarks[nextLine];
	        continue;
	      }

	    // Case 2: line is not inside the blockquote, and the last line was empty.
	    if (lastLineEmpty) {
	      break;
	    }

	    // Case 3: another tag found.
	    terminate = false;
	    for (i = 0, l = terminatorRules.length; i < l; i++) {
	      if (terminatorRules[i](state, nextLine, endLine, true)) {
	        terminate = true;
	        break;
	      }
	    }
	    if (terminate) {
	      break;
	    }

	    oldBMarks.push(state.bMarks[nextLine]);
	    oldTShift.push(state.tShift[nextLine]);
	    oldSCount.push(state.sCount[nextLine]);

	    // A negative indentation means that this is a paragraph continuation
	    //
	    state.sCount[nextLine] = -1;
	  }

	  oldParentType = state.parentType;
	  state.parentType = 'blockquote';

	  token = state.push('blockquote_open', 'blockquote', 1);
	  token.markup = '>';
	  token.map = lines = [startLine, 0];

	  state.md.block.tokenize(state, startLine, nextLine);

	  token = state.push('blockquote_close', 'blockquote', -1);
	  token.markup = '>';

	  state.parentType = oldParentType;
	  lines[1] = state.line;

	  // Restore original tShift; this might not be necessary since the parser
	  // has already been here, but just to make sure we can do that.
	  for (i = 0; i < oldTShift.length; i++) {
	    state.bMarks[i + startLine] = oldBMarks[i];
	    state.tShift[i + startLine] = oldTShift[i];
	    state.sCount[i + startLine] = oldSCount[i];
	  }
	  state.blkIndent = oldIndent;

	  return true;
	};

/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	// Horizontal rule

	'use strict';

	var isSpace = __webpack_require__(58).isSpace;

	module.exports = function hr(state, startLine, endLine, silent) {
	  var marker,
	      cnt,
	      ch,
	      token,
	      pos = state.bMarks[startLine] + state.tShift[startLine],
	      max = state.eMarks[startLine];

	  marker = state.src.charCodeAt(pos++);

	  // Check hr marker
	  if (marker !== 0x2A /* * */ && marker !== 0x2D /* - */ && marker !== 0x5F /* _ */) {
	      return false;
	    }

	  // markers can be mixed with spaces, but there should be at least 3 of them

	  cnt = 1;
	  while (pos < max) {
	    ch = state.src.charCodeAt(pos++);
	    if (ch !== marker && !isSpace(ch)) {
	      return false;
	    }
	    if (ch === marker) {
	      cnt++;
	    }
	  }

	  if (cnt < 3) {
	    return false;
	  }

	  if (silent) {
	    return true;
	  }

	  state.line = startLine + 1;

	  token = state.push('hr', 'hr', 0);
	  token.map = [startLine, state.line];
	  token.markup = Array(cnt + 1).join(String.fromCharCode(marker));

	  return true;
	};

/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	// Lists

	'use strict';

	var isSpace = __webpack_require__(58).isSpace;

	// Search `[-+*][\n ]`, returns next pos arter marker on success
	// or -1 on fail.
	function skipBulletListMarker(state, startLine) {
	  var marker, pos, max, ch;

	  pos = state.bMarks[startLine] + state.tShift[startLine];
	  max = state.eMarks[startLine];

	  marker = state.src.charCodeAt(pos++);
	  // Check bullet
	  if (marker !== 0x2A /* * */ && marker !== 0x2D /* - */ && marker !== 0x2B /* + */) {
	      return -1;
	    }

	  if (pos < max) {
	    ch = state.src.charCodeAt(pos);

	    if (!isSpace(ch)) {
	      // " -test " - is not a list item
	      return -1;
	    }
	  }

	  return pos;
	}

	// Search `\d+[.)][\n ]`, returns next pos arter marker on success
	// or -1 on fail.
	function skipOrderedListMarker(state, startLine) {
	  var ch,
	      start = state.bMarks[startLine] + state.tShift[startLine],
	      pos = start,
	      max = state.eMarks[startLine];

	  // List marker should have at least 2 chars (digit + dot)
	  if (pos + 1 >= max) {
	    return -1;
	  }

	  ch = state.src.charCodeAt(pos++);

	  if (ch < 0x30 /* 0 */ || ch > 0x39 /* 9 */) {
	      return -1;
	    }

	  for (;;) {
	    // EOL -> fail
	    if (pos >= max) {
	      return -1;
	    }

	    ch = state.src.charCodeAt(pos++);

	    if (ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */) {

	        // List marker should have no more than 9 digits
	        // (prevents integer overflow in browsers)
	        if (pos - start >= 10) {
	          return -1;
	        }

	        continue;
	      }

	    // found valid marker
	    if (ch === 0x29 /* ) */ || ch === 0x2e /* . */) {
	        break;
	      }

	    return -1;
	  }

	  if (pos < max) {
	    ch = state.src.charCodeAt(pos);

	    if (!isSpace(ch)) {
	      // " 1.test " - is not a list item
	      return -1;
	    }
	  }
	  return pos;
	}

	function markTightParagraphs(state, idx) {
	  var i,
	      l,
	      level = state.level + 2;

	  for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {
	    if (state.tokens[i].level === level && state.tokens[i].type === 'paragraph_open') {
	      state.tokens[i + 2].hidden = true;
	      state.tokens[i].hidden = true;
	      i += 2;
	    }
	  }
	}

	module.exports = function list(state, startLine, endLine, silent) {
	  var nextLine,
	      initial,
	      offset,
	      indent,
	      oldTShift,
	      oldIndent,
	      oldLIndent,
	      oldTight,
	      oldParentType,
	      start,
	      posAfterMarker,
	      ch,
	      pos,
	      max,
	      indentAfterMarker,
	      markerValue,
	      markerCharCode,
	      isOrdered,
	      contentStart,
	      listTokIdx,
	      prevEmptyEnd,
	      listLines,
	      itemLines,
	      tight = true,
	      terminatorRules,
	      token,
	      i,
	      l,
	      terminate;

	  // Detect list type and position after marker
	  if ((posAfterMarker = skipOrderedListMarker(state, startLine)) >= 0) {
	    isOrdered = true;
	  } else if ((posAfterMarker = skipBulletListMarker(state, startLine)) >= 0) {
	    isOrdered = false;
	  } else {
	    return false;
	  }

	  // We should terminate list on style change. Remember first one to compare.
	  markerCharCode = state.src.charCodeAt(posAfterMarker - 1);

	  // For validation mode we can terminate immediately
	  if (silent) {
	    return true;
	  }

	  // Start list
	  listTokIdx = state.tokens.length;

	  if (isOrdered) {
	    start = state.bMarks[startLine] + state.tShift[startLine];
	    markerValue = Number(state.src.substr(start, posAfterMarker - start - 1));

	    token = state.push('ordered_list_open', 'ol', 1);
	    if (markerValue !== 1) {
	      token.attrs = [['start', markerValue]];
	    }
	  } else {
	    token = state.push('bullet_list_open', 'ul', 1);
	  }

	  token.map = listLines = [startLine, 0];
	  token.markup = String.fromCharCode(markerCharCode);

	  //
	  // Iterate list items
	  //

	  nextLine = startLine;
	  prevEmptyEnd = false;
	  terminatorRules = state.md.block.ruler.getRules('list');

	  while (nextLine < endLine) {
	    pos = posAfterMarker;
	    max = state.eMarks[nextLine];

	    initial = offset = state.sCount[nextLine] + posAfterMarker - (state.bMarks[startLine] + state.tShift[startLine]);

	    while (pos < max) {
	      ch = state.src.charCodeAt(pos);

	      if (isSpace(ch)) {
	        if (ch === 0x09) {
	          offset += 4 - offset % 4;
	        } else {
	          offset++;
	        }
	      } else {
	        break;
	      }

	      pos++;
	    }

	    contentStart = pos;

	    if (contentStart >= max) {
	      // trimming space in "-    \n  3" case, indent is 1 here
	      indentAfterMarker = 1;
	    } else {
	      indentAfterMarker = offset - initial;
	    }

	    // If we have more than 4 spaces, the indent is 1
	    // (the rest is just indented code block)
	    if (indentAfterMarker > 4) {
	      indentAfterMarker = 1;
	    }

	    // "  -  test"
	    //  ^^^^^ - calculating total length of this thing
	    indent = initial + indentAfterMarker;

	    // Run subparser & write tokens
	    token = state.push('list_item_open', 'li', 1);
	    token.markup = String.fromCharCode(markerCharCode);
	    token.map = itemLines = [startLine, 0];

	    oldIndent = state.blkIndent;
	    oldTight = state.tight;
	    oldTShift = state.tShift[startLine];
	    oldLIndent = state.sCount[startLine];
	    oldParentType = state.parentType;
	    state.blkIndent = indent;
	    state.tight = true;
	    state.parentType = 'list';
	    state.tShift[startLine] = contentStart - state.bMarks[startLine];
	    state.sCount[startLine] = offset;

	    state.md.block.tokenize(state, startLine, endLine, true);

	    // If any of list item is tight, mark list as tight
	    if (!state.tight || prevEmptyEnd) {
	      tight = false;
	    }
	    // Item become loose if finish with empty line,
	    // but we should filter last element, because it means list finish
	    prevEmptyEnd = state.line - startLine > 1 && state.isEmpty(state.line - 1);

	    state.blkIndent = oldIndent;
	    state.tShift[startLine] = oldTShift;
	    state.sCount[startLine] = oldLIndent;
	    state.tight = oldTight;
	    state.parentType = oldParentType;

	    token = state.push('list_item_close', 'li', -1);
	    token.markup = String.fromCharCode(markerCharCode);

	    nextLine = startLine = state.line;
	    itemLines[1] = nextLine;
	    contentStart = state.bMarks[startLine];

	    if (nextLine >= endLine) {
	      break;
	    }

	    if (state.isEmpty(nextLine)) {
	      break;
	    }

	    //
	    // Try to check if list is terminated or continued.
	    //
	    if (state.sCount[nextLine] < state.blkIndent) {
	      break;
	    }

	    // fail if terminating block found
	    terminate = false;
	    for (i = 0, l = terminatorRules.length; i < l; i++) {
	      if (terminatorRules[i](state, nextLine, endLine, true)) {
	        terminate = true;
	        break;
	      }
	    }
	    if (terminate) {
	      break;
	    }

	    // fail if list has another type
	    if (isOrdered) {
	      posAfterMarker = skipOrderedListMarker(state, nextLine);
	      if (posAfterMarker < 0) {
	        break;
	      }
	    } else {
	      posAfterMarker = skipBulletListMarker(state, nextLine);
	      if (posAfterMarker < 0) {
	        break;
	      }
	    }

	    if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) {
	      break;
	    }
	  }

	  // Finilize list
	  if (isOrdered) {
	    token = state.push('ordered_list_close', 'ol', -1);
	  } else {
	    token = state.push('bullet_list_close', 'ul', -1);
	  }
	  token.markup = String.fromCharCode(markerCharCode);

	  listLines[1] = nextLine;
	  state.line = nextLine;

	  // mark paragraphs tight if needed
	  if (tight) {
	    markTightParagraphs(state, listTokIdx);
	  }

	  return true;
	};

/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var parseLinkDestination = __webpack_require__(74);
	var parseLinkTitle = __webpack_require__(75);
	var normalizeReference = __webpack_require__(58).normalizeReference;
	var isSpace = __webpack_require__(58).isSpace;

	module.exports = function reference(state, startLine, _endLine, silent) {
	  var ch,
	      destEndPos,
	      destEndLineNo,
	      endLine,
	      href,
	      i,
	      l,
	      label,
	      labelEnd,
	      res,
	      start,
	      str,
	      terminate,
	      terminatorRules,
	      title,
	      lines = 0,
	      pos = state.bMarks[startLine] + state.tShift[startLine],
	      max = state.eMarks[startLine],
	      nextLine = startLine + 1;

	  if (state.src.charCodeAt(pos) !== 0x5B /* [ */) {
	      return false;
	    }

	  // Simple check to quickly interrupt scan on [link](url) at the start of line.
	  // Can be useful on practice: https://github.com/markdown-it/markdown-it/issues/54
	  while (++pos < max) {
	    if (state.src.charCodeAt(pos) === 0x5D /* ] */ && state.src.charCodeAt(pos - 1) !== 0x5C /* \ */) {
	        if (pos + 1 === max) {
	          return false;
	        }
	        if (state.src.charCodeAt(pos + 1) !== 0x3A /* : */) {
	            return false;
	          }
	        break;
	      }
	  }

	  endLine = state.lineMax;

	  // jump line-by-line until empty one or EOF
	  terminatorRules = state.md.block.ruler.getRules('reference');

	  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
	    // this would be a code block normally, but after paragraph
	    // it's considered a lazy continuation regardless of what's there
	    if (state.sCount[nextLine] - state.blkIndent > 3) {
	      continue;
	    }

	    // quirk for blockquotes, this line should already be checked by that rule
	    if (state.sCount[nextLine] < 0) {
	      continue;
	    }

	    // Some tags can terminate paragraph without empty line.
	    terminate = false;
	    for (i = 0, l = terminatorRules.length; i < l; i++) {
	      if (terminatorRules[i](state, nextLine, endLine, true)) {
	        terminate = true;
	        break;
	      }
	    }
	    if (terminate) {
	      break;
	    }
	  }

	  str = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
	  max = str.length;

	  for (pos = 1; pos < max; pos++) {
	    ch = str.charCodeAt(pos);
	    if (ch === 0x5B /* [ */) {
	        return false;
	      } else if (ch === 0x5D /* ] */) {
	        labelEnd = pos;
	        break;
	      } else if (ch === 0x0A /* \n */) {
	        lines++;
	      } else if (ch === 0x5C /* \ */) {
	        pos++;
	        if (pos < max && str.charCodeAt(pos) === 0x0A) {
	          lines++;
	        }
	      }
	  }

	  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 0x3A /* : */) {
	      return false;
	    }

	  // [label]:   destination   'title'
	  //         ^^^ skip optional whitespace here
	  for (pos = labelEnd + 2; pos < max; pos++) {
	    ch = str.charCodeAt(pos);
	    if (ch === 0x0A) {
	      lines++;
	    } else if (isSpace(ch)) {
	      /*eslint no-empty:0*/
	    } else {
	        break;
	      }
	  }

	  // [label]:   destination   'title'
	  //            ^^^^^^^^^^^ parse this
	  res = parseLinkDestination(str, pos, max);
	  if (!res.ok) {
	    return false;
	  }

	  href = state.md.normalizeLink(res.str);
	  if (!state.md.validateLink(href)) {
	    return false;
	  }

	  pos = res.pos;
	  lines += res.lines;

	  // save cursor state, we could require to rollback later
	  destEndPos = pos;
	  destEndLineNo = lines;

	  // [label]:   destination   'title'
	  //                       ^^^ skipping those spaces
	  start = pos;
	  for (; pos < max; pos++) {
	    ch = str.charCodeAt(pos);
	    if (ch === 0x0A) {
	      lines++;
	    } else if (isSpace(ch)) {
	      /*eslint no-empty:0*/
	    } else {
	        break;
	      }
	  }

	  // [label]:   destination   'title'
	  //                          ^^^^^^^ parse this
	  res = parseLinkTitle(str, pos, max);
	  if (pos < max && start !== pos && res.ok) {
	    title = res.str;
	    pos = res.pos;
	    lines += res.lines;
	  } else {
	    title = '';
	    pos = destEndPos;
	    lines = destEndLineNo;
	  }

	  // skip trailing spaces until the rest of the line
	  while (pos < max) {
	    ch = str.charCodeAt(pos);
	    if (!isSpace(ch)) {
	      break;
	    }
	    pos++;
	  }

	  if (pos < max && str.charCodeAt(pos) !== 0x0A) {
	    if (title) {
	      // garbage at the end of the line after title,
	      // but it could still be a valid reference if we roll back
	      title = '';
	      pos = destEndPos;
	      lines = destEndLineNo;
	      while (pos < max) {
	        ch = str.charCodeAt(pos);
	        if (!isSpace(ch)) {
	          break;
	        }
	        pos++;
	      }
	    }
	  }

	  if (pos < max && str.charCodeAt(pos) !== 0x0A) {
	    // garbage at the end of the line
	    return false;
	  }

	  label = normalizeReference(str.slice(1, labelEnd));
	  if (!label) {
	    // CommonMark 0.20 disallows empty labels
	    return false;
	  }

	  // Reference can not terminate anything. This check is for safety only.
	  /*istanbul ignore if*/
	  if (silent) {
	    return true;
	  }

	  if (typeof state.env.references === 'undefined') {
	    state.env.references = {};
	  }
	  if (typeof state.env.references[label] === 'undefined') {
	    state.env.references[label] = { title: title, href: href };
	  }

	  state.line = startLine + lines + 1;
	  return true;
	};

/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	// heading (#, ##, ...)

	'use strict';

	var isSpace = __webpack_require__(58).isSpace;

	module.exports = function heading(state, startLine, endLine, silent) {
	  var ch,
	      level,
	      tmp,
	      token,
	      pos = state.bMarks[startLine] + state.tShift[startLine],
	      max = state.eMarks[startLine];

	  ch = state.src.charCodeAt(pos);

	  if (ch !== 0x23 /* # */ || pos >= max) {
	    return false;
	  }

	  // count heading level
	  level = 1;
	  ch = state.src.charCodeAt(++pos);
	  while (ch === 0x23 /* # */ && pos < max && level <= 6) {
	    level++;
	    ch = state.src.charCodeAt(++pos);
	  }

	  if (level > 6 || pos < max && ch !== 0x20 /* space */) {
	      return false;
	    }

	  if (silent) {
	    return true;
	  }

	  // Let's cut tails like '    ###  ' from the end of string

	  max = state.skipSpacesBack(max, pos);
	  tmp = state.skipCharsBack(max, 0x23, pos); // #
	  if (tmp > pos && isSpace(state.src.charCodeAt(tmp - 1))) {
	    max = tmp;
	  }

	  state.line = startLine + 1;

	  token = state.push('heading_open', 'h' + String(level), 1);
	  token.markup = '########'.slice(0, level);
	  token.map = [startLine, state.line];

	  token = state.push('inline', '', 0);
	  token.content = state.src.slice(pos, max).trim();
	  token.map = [startLine, state.line];
	  token.children = [];

	  token = state.push('heading_close', 'h' + String(level), -1);
	  token.markup = '########'.slice(0, level);

	  return true;
	};

/***/ },
/* 96 */
/***/ function(module, exports) {

	// lheading (---, ===)

	'use strict';

	module.exports = function lheading(state, startLine, endLine /*, silent*/) {
	  var marker,
	      pos,
	      max,
	      token,
	      level,
	      next = startLine + 1;

	  if (next >= endLine) {
	    return false;
	  }
	  if (state.sCount[next] < state.blkIndent) {
	    return false;
	  }

	  // Scan next line

	  if (state.sCount[next] - state.blkIndent > 3) {
	    return false;
	  }

	  pos = state.bMarks[next] + state.tShift[next];
	  max = state.eMarks[next];

	  if (pos >= max) {
	    return false;
	  }

	  marker = state.src.charCodeAt(pos);

	  if (marker !== 0x2D /* - */ && marker !== 0x3D /* = */) {
	      return false;
	    }

	  pos = state.skipChars(pos, marker);

	  pos = state.skipSpaces(pos);

	  if (pos < max) {
	    return false;
	  }

	  pos = state.bMarks[startLine] + state.tShift[startLine];

	  state.line = next + 1;
	  level = marker === 0x3D /* = */ ? 1 : 2;

	  token = state.push('heading_open', 'h' + String(level), 1);
	  token.markup = String.fromCharCode(marker);
	  token.map = [startLine, state.line];

	  token = state.push('inline', '', 0);
	  token.content = state.src.slice(pos, state.eMarks[startLine]).trim();
	  token.map = [startLine, state.line - 1];
	  token.children = [];

	  token = state.push('heading_close', 'h' + String(level), -1);
	  token.markup = String.fromCharCode(marker);

	  return true;
	};

/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	// HTML block

	'use strict';

	var block_names = __webpack_require__(98);
	var HTML_OPEN_CLOSE_TAG_RE = __webpack_require__(99).HTML_OPEN_CLOSE_TAG_RE;

	// An array of opening and corresponding closing sequences for html tags,
	// last argument defines whether it can terminate a paragraph or not
	//
	var HTML_SEQUENCES = [[/^<(script|pre|style)(?=(\s|>|$))/i, /<\/(script|pre|style)>/i, true], [/^<!--/, /-->/, true], [/^<\?/, /\?>/, true], [/^<![A-Z]/, />/, true], [/^<!\[CDATA\[/, /\]\]>/, true], [new RegExp('^</?(' + block_names.join('|') + ')(?=(\\s|/?>|$))', 'i'), /^$/, true], [new RegExp(HTML_OPEN_CLOSE_TAG_RE.source + '\\s*$'), /^$/, false]];

	module.exports = function html_block(state, startLine, endLine, silent) {
	  var i,
	      nextLine,
	      token,
	      lineText,
	      pos = state.bMarks[startLine] + state.tShift[startLine],
	      max = state.eMarks[startLine];

	  if (!state.md.options.html) {
	    return false;
	  }

	  if (state.src.charCodeAt(pos) !== 0x3C /* < */) {
	      return false;
	    }

	  lineText = state.src.slice(pos, max);

	  for (i = 0; i < HTML_SEQUENCES.length; i++) {
	    if (HTML_SEQUENCES[i][0].test(lineText)) {
	      break;
	    }
	  }

	  if (i === HTML_SEQUENCES.length) {
	    return false;
	  }

	  if (silent) {
	    // true if this sequence can be a terminator, false otherwise
	    return HTML_SEQUENCES[i][2];
	  }

	  nextLine = startLine + 1;

	  // If we are here - we detected HTML block.
	  // Let's roll down till block end.
	  if (!HTML_SEQUENCES[i][1].test(lineText)) {
	    for (; nextLine < endLine; nextLine++) {
	      if (state.sCount[nextLine] < state.blkIndent) {
	        break;
	      }

	      pos = state.bMarks[nextLine] + state.tShift[nextLine];
	      max = state.eMarks[nextLine];
	      lineText = state.src.slice(pos, max);

	      if (HTML_SEQUENCES[i][1].test(lineText)) {
	        if (lineText.length !== 0) {
	          nextLine++;
	        }
	        break;
	      }
	    }
	  }

	  state.line = nextLine;

	  token = state.push('html_block', '', 0);
	  token.map = [startLine, nextLine];
	  token.content = state.getLines(startLine, nextLine, state.blkIndent, true);

	  return true;
	};

/***/ },
/* 98 */
/***/ function(module, exports) {

	// List of valid html blocks names, accorting to commonmark spec
	// http://jgm.github.io/CommonMark/spec.html#html-blocks

	'use strict';

	module.exports = ['address', 'article', 'aside', 'base', 'basefont', 'blockquote', 'body', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dialog', 'dir', 'div', 'dl', 'dt', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'head', 'header', 'hr', 'html', 'iframe', 'legend', 'li', 'link', 'main', 'menu', 'menuitem', 'meta', 'nav', 'noframes', 'ol', 'optgroup', 'option', 'p', 'param', 'pre', 'section', 'source', 'title', 'summary', 'table', 'tbody', 'td', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul'];

/***/ },
/* 99 */
/***/ function(module, exports) {

	// Regexps to match html elements

	'use strict';

	var attr_name = '[a-zA-Z_:][a-zA-Z0-9:._-]*';

	var unquoted = '[^"\'=<>`\\x00-\\x20]+';
	var single_quoted = "'[^']*'";
	var double_quoted = '"[^"]*"';

	var attr_value = '(?:' + unquoted + '|' + single_quoted + '|' + double_quoted + ')';

	var attribute = '(?:\\s+' + attr_name + '(?:\\s*=\\s*' + attr_value + ')?)';

	var open_tag = '<[A-Za-z][A-Za-z0-9\\-]*' + attribute + '*\\s*\\/?>';

	var close_tag = '<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>';
	var comment = '<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->';
	var processing = '<[?].*?[?]>';
	var declaration = '<![A-Z]+\\s+[^>]*>';
	var cdata = '<!\\[CDATA\\[[\\s\\S]*?\\]\\]>';

	var HTML_TAG_RE = new RegExp('^(?:' + open_tag + '|' + close_tag + '|' + comment + '|' + processing + '|' + declaration + '|' + cdata + ')');
	var HTML_OPEN_CLOSE_TAG_RE = new RegExp('^(?:' + open_tag + '|' + close_tag + ')');

	module.exports.HTML_TAG_RE = HTML_TAG_RE;
	module.exports.HTML_OPEN_CLOSE_TAG_RE = HTML_OPEN_CLOSE_TAG_RE;

/***/ },
/* 100 */
/***/ function(module, exports) {

	// Paragraph

	'use strict';

	module.exports = function paragraph(state, startLine /*, endLine*/) {
	  var content,
	      terminate,
	      i,
	      l,
	      token,
	      nextLine = startLine + 1,
	      terminatorRules = state.md.block.ruler.getRules('paragraph'),
	      endLine = state.lineMax;

	  // jump line-by-line until empty one or EOF
	  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
	    // this would be a code block normally, but after paragraph
	    // it's considered a lazy continuation regardless of what's there
	    if (state.sCount[nextLine] - state.blkIndent > 3) {
	      continue;
	    }

	    // quirk for blockquotes, this line should already be checked by that rule
	    if (state.sCount[nextLine] < 0) {
	      continue;
	    }

	    // Some tags can terminate paragraph without empty line.
	    terminate = false;
	    for (i = 0, l = terminatorRules.length; i < l; i++) {
	      if (terminatorRules[i](state, nextLine, endLine, true)) {
	        terminate = true;
	        break;
	      }
	    }
	    if (terminate) {
	      break;
	    }
	  }

	  content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();

	  state.line = nextLine;

	  token = state.push('paragraph_open', 'p', 1);
	  token.map = [startLine, state.line];

	  token = state.push('inline', '', 0);
	  token.content = content;
	  token.map = [startLine, state.line];
	  token.children = [];

	  token = state.push('paragraph_close', 'p', -1);

	  return true;
	};

/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	// Parser state class

	'use strict';

	var Token = __webpack_require__(86);
	var isSpace = __webpack_require__(58).isSpace;

	function StateBlock(src, md, env, tokens) {
	  var ch, s, start, pos, len, indent, offset, indent_found;

	  this.src = src;

	  // link to parser instance
	  this.md = md;

	  this.env = env;

	  //
	  // Internal state vartiables
	  //

	  this.tokens = tokens;

	  this.bMarks = []; // line begin offsets for fast jumps
	  this.eMarks = []; // line end offsets for fast jumps
	  this.tShift = []; // offsets of the first non-space characters (tabs not expanded)
	  this.sCount = []; // indents for each line (tabs expanded)

	  // block parser variables
	  this.blkIndent = 0; // required block content indent
	  // (for example, if we are in list)
	  this.line = 0; // line index in src
	  this.lineMax = 0; // lines count
	  this.tight = false; // loose/tight mode for lists
	  this.parentType = 'root'; // if `list`, block parser stops on two newlines
	  this.ddIndent = -1; // indent of the current dd block (-1 if there isn't any)

	  this.level = 0;

	  // renderer
	  this.result = '';

	  // Create caches
	  // Generate markers.
	  s = this.src;
	  indent_found = false;

	  for (start = pos = indent = offset = 0, len = s.length; pos < len; pos++) {
	    ch = s.charCodeAt(pos);

	    if (!indent_found) {
	      if (isSpace(ch)) {
	        indent++;

	        if (ch === 0x09) {
	          offset += 4 - offset % 4;
	        } else {
	          offset++;
	        }
	        continue;
	      } else {
	        indent_found = true;
	      }
	    }

	    if (ch === 0x0A || pos === len - 1) {
	      if (ch !== 0x0A) {
	        pos++;
	      }
	      this.bMarks.push(start);
	      this.eMarks.push(pos);
	      this.tShift.push(indent);
	      this.sCount.push(offset);

	      indent_found = false;
	      indent = 0;
	      offset = 0;
	      start = pos + 1;
	    }
	  }

	  // Push fake entry to simplify cache bounds checks
	  this.bMarks.push(s.length);
	  this.eMarks.push(s.length);
	  this.tShift.push(0);
	  this.sCount.push(0);

	  this.lineMax = this.bMarks.length - 1; // don't count last fake line
	}

	// Push new token to "stream".
	//
	StateBlock.prototype.push = function (type, tag, nesting) {
	  var token = new Token(type, tag, nesting);
	  token.block = true;

	  if (nesting < 0) {
	    this.level--;
	  }
	  token.level = this.level;
	  if (nesting > 0) {
	    this.level++;
	  }

	  this.tokens.push(token);
	  return token;
	};

	StateBlock.prototype.isEmpty = function isEmpty(line) {
	  return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];
	};

	StateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {
	  for (var max = this.lineMax; from < max; from++) {
	    if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {
	      break;
	    }
	  }
	  return from;
	};

	// Skip spaces from given position.
	StateBlock.prototype.skipSpaces = function skipSpaces(pos) {
	  var ch;

	  for (var max = this.src.length; pos < max; pos++) {
	    ch = this.src.charCodeAt(pos);
	    if (!isSpace(ch)) {
	      break;
	    }
	  }
	  return pos;
	};

	// Skip spaces from given position in reverse.
	StateBlock.prototype.skipSpacesBack = function skipSpacesBack(pos, min) {
	  if (pos <= min) {
	    return pos;
	  }

	  while (pos > min) {
	    if (!isSpace(this.src.charCodeAt(--pos))) {
	      return pos + 1;
	    }
	  }
	  return pos;
	};

	// Skip char codes from given position
	StateBlock.prototype.skipChars = function skipChars(pos, code) {
	  for (var max = this.src.length; pos < max; pos++) {
	    if (this.src.charCodeAt(pos) !== code) {
	      break;
	    }
	  }
	  return pos;
	};

	// Skip char codes reverse from given position - 1
	StateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code, min) {
	  if (pos <= min) {
	    return pos;
	  }

	  while (pos > min) {
	    if (code !== this.src.charCodeAt(--pos)) {
	      return pos + 1;
	    }
	  }
	  return pos;
	};

	// cut lines range from source.
	StateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {
	  var i,
	      lineIndent,
	      ch,
	      first,
	      last,
	      queue,
	      lineStart,
	      line = begin;

	  if (begin >= end) {
	    return '';
	  }

	  queue = new Array(end - begin);

	  for (i = 0; line < end; line++, i++) {
	    lineIndent = 0;
	    lineStart = first = this.bMarks[line];

	    if (line + 1 < end || keepLastLF) {
	      // No need for bounds check because we have fake entry on tail.
	      last = this.eMarks[line] + 1;
	    } else {
	      last = this.eMarks[line];
	    }

	    while (first < last && lineIndent < indent) {
	      ch = this.src.charCodeAt(first);

	      if (isSpace(ch)) {
	        if (ch === 0x09) {
	          lineIndent += 4 - lineIndent % 4;
	        } else {
	          lineIndent++;
	        }
	      } else if (first - lineStart < this.tShift[line]) {
	        // patched tShift masked characters to look like spaces (blockquotes, list markers)
	        lineIndent++;
	      } else {
	        break;
	      }

	      first++;
	    }

	    queue[i] = this.src.slice(first, last);
	  }

	  return queue.join('');
	};

	// re-export Token class to use in block rules
	StateBlock.prototype.Token = Token;

	module.exports = StateBlock;

/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	/** internal
	 * class ParserInline
	 *
	 * Tokenizes paragraph content.
	 **/
	'use strict';

	var Ruler = __webpack_require__(78);

	////////////////////////////////////////////////////////////////////////////////
	// Parser rules

	var _rules = [['text', __webpack_require__(103)], ['newline', __webpack_require__(104)], ['escape', __webpack_require__(105)], ['backticks', __webpack_require__(106)], ['strikethrough', __webpack_require__(107).tokenize], ['emphasis', __webpack_require__(108).tokenize], ['link', __webpack_require__(109)], ['image', __webpack_require__(110)], ['autolink', __webpack_require__(111)], ['html_inline', __webpack_require__(113)], ['entity', __webpack_require__(114)]];

	var _rules2 = [['balance_pairs', __webpack_require__(115)], ['strikethrough', __webpack_require__(107).postProcess], ['emphasis', __webpack_require__(108).postProcess], ['text_collapse', __webpack_require__(116)]];

	/**
	 * new ParserInline()
	 **/
	function ParserInline() {
	  var i;

	  /**
	   * ParserInline#ruler -> Ruler
	   *
	   * [[Ruler]] instance. Keep configuration of inline rules.
	   **/
	  this.ruler = new Ruler();

	  for (i = 0; i < _rules.length; i++) {
	    this.ruler.push(_rules[i][0], _rules[i][1]);
	  }

	  /**
	   * ParserInline#ruler2 -> Ruler
	   *
	   * [[Ruler]] instance. Second ruler used for post-processing
	   * (e.g. in emphasis-like rules).
	   **/
	  this.ruler2 = new Ruler();

	  for (i = 0; i < _rules2.length; i++) {
	    this.ruler2.push(_rules2[i][0], _rules2[i][1]);
	  }
	}

	// Skip single token by running all rules in validation mode;
	// returns `true` if any rule reported success
	//
	ParserInline.prototype.skipToken = function (state) {
	  var i,
	      pos = state.pos,
	      rules = this.ruler.getRules(''),
	      len = rules.length,
	      maxNesting = state.md.options.maxNesting,
	      cache = state.cache;

	  if (typeof cache[pos] !== 'undefined') {
	    state.pos = cache[pos];
	    return;
	  }

	  /*istanbul ignore else*/
	  if (state.level < maxNesting) {
	    for (i = 0; i < len; i++) {
	      if (rules[i](state, true)) {
	        cache[pos] = state.pos;
	        return;
	      }
	    }
	  }

	  state.pos++;
	  cache[pos] = state.pos;
	};

	// Generate tokens for input range
	//
	ParserInline.prototype.tokenize = function (state) {
	  var ok,
	      i,
	      rules = this.ruler.getRules(''),
	      len = rules.length,
	      end = state.posMax,
	      maxNesting = state.md.options.maxNesting;

	  while (state.pos < end) {
	    // Try all possible rules.
	    // On success, rule should:
	    //
	    // - update `state.pos`
	    // - update `state.tokens`
	    // - return true

	    if (state.level < maxNesting) {
	      for (i = 0; i < len; i++) {
	        ok = rules[i](state, false);
	        if (ok) {
	          break;
	        }
	      }
	    }

	    if (ok) {
	      if (state.pos >= end) {
	        break;
	      }
	      continue;
	    }

	    state.pending += state.src[state.pos++];
	  }

	  if (state.pending) {
	    state.pushPending();
	  }
	};

	/**
	 * ParserInline.parse(str, md, env, outTokens)
	 *
	 * Process input string and push inline tokens into `outTokens`
	 **/
	ParserInline.prototype.parse = function (str, md, env, outTokens) {
	  var i, rules, len;
	  var state = new this.State(str, md, env, outTokens);

	  this.tokenize(state);

	  rules = this.ruler2.getRules('');
	  len = rules.length;

	  for (i = 0; i < len; i++) {
	    rules[i](state);
	  }
	};

	ParserInline.prototype.State = __webpack_require__(117);

	module.exports = ParserInline;

/***/ },
/* 103 */
/***/ function(module, exports) {

	// Skip text characters for text token, place those to pending buffer
	// and increment current pos

	'use strict'

	// Rule to skip pure text
	// '{}$%@~+=:' reserved for extentions

	// !, ", #, $, %, &, ', (, ), *, +, ,, -, ., /, :, ;, <, =, >, ?, @, [, \, ], ^, _, `, {, |, }, or ~

	// !!!! Don't confuse with "Markdown ASCII Punctuation" chars
	// http://spec.commonmark.org/0.15/#ascii-punctuation-character
	;
	function isTerminatorChar(ch) {
	  switch (ch) {
	    case 0x0A /* \n */:
	    case 0x21 /* ! */:
	    case 0x23 /* # */:
	    case 0x24 /* $ */:
	    case 0x25 /* % */:
	    case 0x26 /* & */:
	    case 0x2A /* * */:
	    case 0x2B /* + */:
	    case 0x2D /* - */:
	    case 0x3A /* : */:
	    case 0x3C /* < */:
	    case 0x3D /* = */:
	    case 0x3E /* > */:
	    case 0x40 /* @ */:
	    case 0x5B /* [ */:
	    case 0x5C /* \ */:
	    case 0x5D /* ] */:
	    case 0x5E /* ^ */:
	    case 0x5F /* _ */:
	    case 0x60 /* ` */:
	    case 0x7B /* { */:
	    case 0x7D /* } */:
	    case 0x7E /* ~ */:
	      return true;
	    default:
	      return false;
	  }
	}

	module.exports = function text(state, silent) {
	  var pos = state.pos;

	  while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {
	    pos++;
	  }

	  if (pos === state.pos) {
	    return false;
	  }

	  if (!silent) {
	    state.pending += state.src.slice(state.pos, pos);
	  }

	  state.pos = pos;

	  return true;
	};

	// Alternative implementation, for memory.
	//
	// It costs 10% of performance, but allows extend terminators list, if place it
	// to `ParcerInline` property. Probably, will switch to it sometime, such
	// flexibility required.

	/*
	var TERMINATOR_RE = /[\n!#$%&*+\-:<=>@[\\\]^_`{}~]/;

	module.exports = function text(state, silent) {
	  var pos = state.pos,
	      idx = state.src.slice(pos).search(TERMINATOR_RE);

	  // first char is terminator -> empty text
	  if (idx === 0) { return false; }

	  // no terminator -> text till end of string
	  if (idx < 0) {
	    if (!silent) { state.pending += state.src.slice(pos); }
	    state.pos = state.src.length;
	    return true;
	  }

	  if (!silent) { state.pending += state.src.slice(pos, pos + idx); }

	  state.pos += idx;

	  return true;
	};*/

/***/ },
/* 104 */
/***/ function(module, exports) {

	// Proceess '\n'

	'use strict';

	module.exports = function newline(state, silent) {
	  var pmax,
	      max,
	      pos = state.pos;

	  if (state.src.charCodeAt(pos) !== 0x0A /* \n */) {
	      return false;
	    }

	  pmax = state.pending.length - 1;
	  max = state.posMax;

	  // '  \n' -> hardbreak
	  // Lookup in pending chars is bad practice! Don't copy to other rules!
	  // Pending string is stored in concat mode, indexed lookups will cause
	  // convertion to flat mode.
	  if (!silent) {
	    if (pmax >= 0 && state.pending.charCodeAt(pmax) === 0x20) {
	      if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 0x20) {
	        state.pending = state.pending.replace(/ +$/, '');
	        state.push('hardbreak', 'br', 0);
	      } else {
	        state.pending = state.pending.slice(0, -1);
	        state.push('softbreak', 'br', 0);
	      }
	    } else {
	      state.push('softbreak', 'br', 0);
	    }
	  }

	  pos++;

	  // skip heading spaces for next line
	  while (pos < max && state.src.charCodeAt(pos) === 0x20) {
	    pos++;
	  }

	  state.pos = pos;
	  return true;
	};

/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	// Proceess escaped chars and hardbreaks

	'use strict';

	var isSpace = __webpack_require__(58).isSpace;

	var ESCAPED = [];

	for (var i = 0; i < 256; i++) {
	  ESCAPED.push(0);
	}

	'\\!"#$%&\'()*+,./:;<=>?@[]^_`{|}~-'.split('').forEach(function (ch) {
	  ESCAPED[ch.charCodeAt(0)] = 1;
	});

	module.exports = function escape(state, silent) {
	  var ch,
	      pos = state.pos,
	      max = state.posMax;

	  if (state.src.charCodeAt(pos) !== 0x5C /* \ */) {
	      return false;
	    }

	  pos++;

	  if (pos < max) {
	    ch = state.src.charCodeAt(pos);

	    if (ch < 256 && ESCAPED[ch] !== 0) {
	      if (!silent) {
	        state.pending += state.src[pos];
	      }
	      state.pos += 2;
	      return true;
	    }

	    if (ch === 0x0A) {
	      if (!silent) {
	        state.push('hardbreak', 'br', 0);
	      }

	      pos++;
	      // skip leading whitespaces from next line
	      while (pos < max) {
	        ch = state.src.charCodeAt(pos);
	        if (!isSpace(ch)) {
	          break;
	        }
	        pos++;
	      }

	      state.pos = pos;
	      return true;
	    }
	  }

	  if (!silent) {
	    state.pending += '\\';
	  }
	  state.pos++;
	  return true;
	};

/***/ },
/* 106 */
/***/ function(module, exports) {

	// Parse backticks

	'use strict';

	module.exports = function backtick(state, silent) {
	  var start,
	      max,
	      marker,
	      matchStart,
	      matchEnd,
	      token,
	      pos = state.pos,
	      ch = state.src.charCodeAt(pos);

	  if (ch !== 0x60 /* ` */) {
	      return false;
	    }

	  start = pos;
	  pos++;
	  max = state.posMax;

	  while (pos < max && state.src.charCodeAt(pos) === 0x60 /* ` */) {
	    pos++;
	  }

	  marker = state.src.slice(start, pos);

	  matchStart = matchEnd = pos;

	  while ((matchStart = state.src.indexOf('`', matchEnd)) !== -1) {
	    matchEnd = matchStart + 1;

	    while (matchEnd < max && state.src.charCodeAt(matchEnd) === 0x60 /* ` */) {
	      matchEnd++;
	    }

	    if (matchEnd - matchStart === marker.length) {
	      if (!silent) {
	        token = state.push('code_inline', 'code', 0);
	        token.markup = marker;
	        token.content = state.src.slice(pos, matchStart).replace(/[ \n]+/g, ' ').trim();
	      }
	      state.pos = matchEnd;
	      return true;
	    }
	  }

	  if (!silent) {
	    state.pending += marker;
	  }
	  state.pos += marker.length;
	  return true;
	};

/***/ },
/* 107 */
/***/ function(module, exports) {

	// ~~strike through~~
	//
	'use strict'

	// Insert each marker as a separate text token, and add it to delimiter list
	//
	;
	module.exports.tokenize = function strikethrough(state, silent) {
	  var i,
	      scanned,
	      token,
	      len,
	      ch,
	      start = state.pos,
	      marker = state.src.charCodeAt(start);

	  if (silent) {
	    return false;
	  }

	  if (marker !== 0x7E /* ~ */) {
	      return false;
	    }

	  scanned = state.scanDelims(state.pos, true);
	  len = scanned.length;
	  ch = String.fromCharCode(marker);

	  if (len < 2) {
	    return false;
	  }

	  if (len % 2) {
	    token = state.push('text', '', 0);
	    token.content = ch;
	    len--;
	  }

	  for (i = 0; i < len; i += 2) {
	    token = state.push('text', '', 0);
	    token.content = ch + ch;

	    state.delimiters.push({
	      marker: marker,
	      jump: i,
	      token: state.tokens.length - 1,
	      level: state.level,
	      end: -1,
	      open: scanned.can_open,
	      close: scanned.can_close
	    });
	  }

	  state.pos += scanned.length;

	  return true;
	};

	// Walk through delimiter list and replace text tokens with tags
	//
	module.exports.postProcess = function strikethrough(state) {
	  var i,
	      j,
	      startDelim,
	      endDelim,
	      token,
	      loneMarkers = [],
	      delimiters = state.delimiters,
	      max = state.delimiters.length;

	  for (i = 0; i < max; i++) {
	    startDelim = delimiters[i];

	    if (startDelim.marker !== 0x7E /* ~ */) {
	        continue;
	      }

	    if (startDelim.end === -1) {
	      continue;
	    }

	    endDelim = delimiters[startDelim.end];

	    token = state.tokens[startDelim.token];
	    token.type = 's_open';
	    token.tag = 's';
	    token.nesting = 1;
	    token.markup = '~~';
	    token.content = '';

	    token = state.tokens[endDelim.token];
	    token.type = 's_close';
	    token.tag = 's';
	    token.nesting = -1;
	    token.markup = '~~';
	    token.content = '';

	    if (state.tokens[endDelim.token - 1].type === 'text' && state.tokens[endDelim.token - 1].content === '~') {

	      loneMarkers.push(endDelim.token - 1);
	    }
	  }

	  // If a marker sequence has an odd number of characters, it's splitted
	  // like this: `~~~~~` -> `~` + `~~` + `~~`, leaving one marker at the
	  // start of the sequence.
	  //
	  // So, we have to move all those markers after subsequent s_close tags.
	  //
	  while (loneMarkers.length) {
	    i = loneMarkers.pop();
	    j = i + 1;

	    while (j < state.tokens.length && state.tokens[j].type === 's_close') {
	      j++;
	    }

	    j--;

	    if (i !== j) {
	      token = state.tokens[j];
	      state.tokens[j] = state.tokens[i];
	      state.tokens[i] = token;
	    }
	  }
	};

/***/ },
/* 108 */
/***/ function(module, exports) {

	// Process *this* and _that_
	//
	'use strict'

	// Insert each marker as a separate text token, and add it to delimiter list
	//
	;
	module.exports.tokenize = function emphasis(state, silent) {
	  var i,
	      scanned,
	      token,
	      start = state.pos,
	      marker = state.src.charCodeAt(start);

	  if (silent) {
	    return false;
	  }

	  if (marker !== 0x5F /* _ */ && marker !== 0x2A /* * */) {
	      return false;
	    }

	  scanned = state.scanDelims(state.pos, marker === 0x2A);

	  for (i = 0; i < scanned.length; i++) {
	    token = state.push('text', '', 0);
	    token.content = String.fromCharCode(marker);

	    state.delimiters.push({
	      // Char code of the starting marker (number).
	      //
	      marker: marker,

	      // An amount of characters before this one that's equivalent to
	      // current one. In plain English: if this delimiter does not open
	      // an emphasis, neither do previous `jump` characters.
	      //
	      // Used to skip sequences like "*****" in one step, for 1st asterisk
	      // value will be 0, for 2nd it's 1 and so on.
	      //
	      jump: i,

	      // A position of the token this delimiter corresponds to.
	      //
	      token: state.tokens.length - 1,

	      // Token level.
	      //
	      level: state.level,

	      // If this delimiter is matched as a valid opener, `end` will be
	      // equal to its position, otherwise it's `-1`.
	      //
	      end: -1,

	      // Boolean flags that determine if this delimiter could open or close
	      // an emphasis.
	      //
	      open: scanned.can_open,
	      close: scanned.can_close
	    });
	  }

	  state.pos += scanned.length;

	  return true;
	};

	// Walk through delimiter list and replace text tokens with tags
	//
	module.exports.postProcess = function emphasis(state) {
	  var i,
	      startDelim,
	      endDelim,
	      token,
	      ch,
	      isStrong,
	      delimiters = state.delimiters,
	      max = state.delimiters.length;

	  for (i = 0; i < max; i++) {
	    startDelim = delimiters[i];

	    if (startDelim.marker !== 0x5F /* _ */ && startDelim.marker !== 0x2A /* * */) {
	        continue;
	      }

	    // Process only opening markers
	    if (startDelim.end === -1) {
	      continue;
	    }

	    endDelim = delimiters[startDelim.end];

	    // If the next delimiter has the same marker and is adjacent to this one,
	    // merge those into one strong delimiter.
	    //
	    // `<em><em>whatever</em></em>` -> `<strong>whatever</strong>`
	    //
	    isStrong = i + 1 < max && delimiters[i + 1].end === startDelim.end - 1 && delimiters[i + 1].token === startDelim.token + 1 && delimiters[startDelim.end - 1].token === endDelim.token - 1 && delimiters[i + 1].marker === startDelim.marker;

	    ch = String.fromCharCode(startDelim.marker);

	    token = state.tokens[startDelim.token];
	    token.type = isStrong ? 'strong_open' : 'em_open';
	    token.tag = isStrong ? 'strong' : 'em';
	    token.nesting = 1;
	    token.markup = isStrong ? ch + ch : ch;
	    token.content = '';

	    token = state.tokens[endDelim.token];
	    token.type = isStrong ? 'strong_close' : 'em_close';
	    token.tag = isStrong ? 'strong' : 'em';
	    token.nesting = -1;
	    token.markup = isStrong ? ch + ch : ch;
	    token.content = '';

	    if (isStrong) {
	      state.tokens[delimiters[i + 1].token].content = '';
	      state.tokens[delimiters[startDelim.end - 1].token].content = '';
	      i++;
	    }
	  }
	};

/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	// Process [link](<to> "stuff")

	'use strict';

	var parseLinkLabel = __webpack_require__(73);
	var parseLinkDestination = __webpack_require__(74);
	var parseLinkTitle = __webpack_require__(75);
	var normalizeReference = __webpack_require__(58).normalizeReference;
	var isSpace = __webpack_require__(58).isSpace;

	module.exports = function link(state, silent) {
	  var attrs,
	      code,
	      label,
	      labelEnd,
	      labelStart,
	      pos,
	      res,
	      ref,
	      title,
	      token,
	      href = '',
	      oldPos = state.pos,
	      max = state.posMax,
	      start = state.pos;

	  if (state.src.charCodeAt(state.pos) !== 0x5B /* [ */) {
	      return false;
	    }

	  labelStart = state.pos + 1;
	  labelEnd = parseLinkLabel(state, state.pos, true);

	  // parser failed to find ']', so it's not a valid link
	  if (labelEnd < 0) {
	    return false;
	  }

	  pos = labelEnd + 1;
	  if (pos < max && state.src.charCodeAt(pos) === 0x28 /* ( */) {
	      //
	      // Inline link
	      //

	      // [link](  <href>  "title"  )
	      //        ^^ skipping these spaces
	      pos++;
	      for (; pos < max; pos++) {
	        code = state.src.charCodeAt(pos);
	        if (!isSpace(code) && code !== 0x0A) {
	          break;
	        }
	      }
	      if (pos >= max) {
	        return false;
	      }

	      // [link](  <href>  "title"  )
	      //          ^^^^^^ parsing link destination
	      start = pos;
	      res = parseLinkDestination(state.src, pos, state.posMax);
	      if (res.ok) {
	        href = state.md.normalizeLink(res.str);
	        if (state.md.validateLink(href)) {
	          pos = res.pos;
	        } else {
	          href = '';
	        }
	      }

	      // [link](  <href>  "title"  )
	      //                ^^ skipping these spaces
	      start = pos;
	      for (; pos < max; pos++) {
	        code = state.src.charCodeAt(pos);
	        if (!isSpace(code) && code !== 0x0A) {
	          break;
	        }
	      }

	      // [link](  <href>  "title"  )
	      //                  ^^^^^^^ parsing link title
	      res = parseLinkTitle(state.src, pos, state.posMax);
	      if (pos < max && start !== pos && res.ok) {
	        title = res.str;
	        pos = res.pos;

	        // [link](  <href>  "title"  )
	        //                         ^^ skipping these spaces
	        for (; pos < max; pos++) {
	          code = state.src.charCodeAt(pos);
	          if (!isSpace(code) && code !== 0x0A) {
	            break;
	          }
	        }
	      } else {
	        title = '';
	      }

	      if (pos >= max || state.src.charCodeAt(pos) !== 0x29 /* ) */) {
	          state.pos = oldPos;
	          return false;
	        }
	      pos++;
	    } else {
	    //
	    // Link reference
	    //
	    if (typeof state.env.references === 'undefined') {
	      return false;
	    }

	    // [foo]  [bar]
	    //      ^^ optional whitespace (can include newlines)
	    for (; pos < max; pos++) {
	      code = state.src.charCodeAt(pos);
	      if (!isSpace(code) && code !== 0x0A) {
	        break;
	      }
	    }

	    if (pos < max && state.src.charCodeAt(pos) === 0x5B /* [ */) {
	        start = pos + 1;
	        pos = parseLinkLabel(state, pos);
	        if (pos >= 0) {
	          label = state.src.slice(start, pos++);
	        } else {
	          pos = labelEnd + 1;
	        }
	      } else {
	      pos = labelEnd + 1;
	    }

	    // covers label === '' and label === undefined
	    // (collapsed reference link and shortcut reference link respectively)
	    if (!label) {
	      label = state.src.slice(labelStart, labelEnd);
	    }

	    ref = state.env.references[normalizeReference(label)];
	    if (!ref) {
	      state.pos = oldPos;
	      return false;
	    }
	    href = ref.href;
	    title = ref.title;
	  }

	  //
	  // We found the end of the link, and know for a fact it's a valid link;
	  // so all that's left to do is to call tokenizer.
	  //
	  if (!silent) {
	    state.pos = labelStart;
	    state.posMax = labelEnd;

	    token = state.push('link_open', 'a', 1);
	    token.attrs = attrs = [['href', href]];
	    if (title) {
	      attrs.push(['title', title]);
	    }

	    state.md.inline.tokenize(state);

	    token = state.push('link_close', 'a', -1);
	  }

	  state.pos = pos;
	  state.posMax = max;
	  return true;
	};

/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	// Process ![image](<src> "title")

	'use strict';

	var parseLinkLabel = __webpack_require__(73);
	var parseLinkDestination = __webpack_require__(74);
	var parseLinkTitle = __webpack_require__(75);
	var normalizeReference = __webpack_require__(58).normalizeReference;
	var isSpace = __webpack_require__(58).isSpace;

	module.exports = function image(state, silent) {
	  var attrs,
	      code,
	      label,
	      labelEnd,
	      labelStart,
	      pos,
	      ref,
	      res,
	      title,
	      token,
	      tokens,
	      start,
	      href = '',
	      oldPos = state.pos,
	      max = state.posMax;

	  if (state.src.charCodeAt(state.pos) !== 0x21 /* ! */) {
	      return false;
	    }
	  if (state.src.charCodeAt(state.pos + 1) !== 0x5B /* [ */) {
	      return false;
	    }

	  labelStart = state.pos + 2;
	  labelEnd = parseLinkLabel(state, state.pos + 1, false);

	  // parser failed to find ']', so it's not a valid link
	  if (labelEnd < 0) {
	    return false;
	  }

	  pos = labelEnd + 1;
	  if (pos < max && state.src.charCodeAt(pos) === 0x28 /* ( */) {
	      //
	      // Inline link
	      //

	      // [link](  <href>  "title"  )
	      //        ^^ skipping these spaces
	      pos++;
	      for (; pos < max; pos++) {
	        code = state.src.charCodeAt(pos);
	        if (!isSpace(code) && code !== 0x0A) {
	          break;
	        }
	      }
	      if (pos >= max) {
	        return false;
	      }

	      // [link](  <href>  "title"  )
	      //          ^^^^^^ parsing link destination
	      start = pos;
	      res = parseLinkDestination(state.src, pos, state.posMax);
	      if (res.ok) {
	        href = state.md.normalizeLink(res.str);
	        if (state.md.validateLink(href)) {
	          pos = res.pos;
	        } else {
	          href = '';
	        }
	      }

	      // [link](  <href>  "title"  )
	      //                ^^ skipping these spaces
	      start = pos;
	      for (; pos < max; pos++) {
	        code = state.src.charCodeAt(pos);
	        if (!isSpace(code) && code !== 0x0A) {
	          break;
	        }
	      }

	      // [link](  <href>  "title"  )
	      //                  ^^^^^^^ parsing link title
	      res = parseLinkTitle(state.src, pos, state.posMax);
	      if (pos < max && start !== pos && res.ok) {
	        title = res.str;
	        pos = res.pos;

	        // [link](  <href>  "title"  )
	        //                         ^^ skipping these spaces
	        for (; pos < max; pos++) {
	          code = state.src.charCodeAt(pos);
	          if (!isSpace(code) && code !== 0x0A) {
	            break;
	          }
	        }
	      } else {
	        title = '';
	      }

	      if (pos >= max || state.src.charCodeAt(pos) !== 0x29 /* ) */) {
	          state.pos = oldPos;
	          return false;
	        }
	      pos++;
	    } else {
	    //
	    // Link reference
	    //
	    if (typeof state.env.references === 'undefined') {
	      return false;
	    }

	    // [foo]  [bar]
	    //      ^^ optional whitespace (can include newlines)
	    for (; pos < max; pos++) {
	      code = state.src.charCodeAt(pos);
	      if (!isSpace(code) && code !== 0x0A) {
	        break;
	      }
	    }

	    if (pos < max && state.src.charCodeAt(pos) === 0x5B /* [ */) {
	        start = pos + 1;
	        pos = parseLinkLabel(state, pos);
	        if (pos >= 0) {
	          label = state.src.slice(start, pos++);
	        } else {
	          pos = labelEnd + 1;
	        }
	      } else {
	      pos = labelEnd + 1;
	    }

	    // covers label === '' and label === undefined
	    // (collapsed reference link and shortcut reference link respectively)
	    if (!label) {
	      label = state.src.slice(labelStart, labelEnd);
	    }

	    ref = state.env.references[normalizeReference(label)];
	    if (!ref) {
	      state.pos = oldPos;
	      return false;
	    }
	    href = ref.href;
	    title = ref.title;
	  }

	  //
	  // We found the end of the link, and know for a fact it's a valid link;
	  // so all that's left to do is to call tokenizer.
	  //
	  if (!silent) {
	    state.md.inline.parse(state.src.slice(labelStart, labelEnd), state.md, state.env, tokens = []);

	    token = state.push('image', 'img', 0);
	    token.attrs = attrs = [['src', href], ['alt', '']];
	    token.children = tokens;
	    if (title) {
	      attrs.push(['title', title]);
	    }
	  }

	  state.pos = pos;
	  state.posMax = max;
	  return true;
	};

/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	// Process autolinks '<protocol:...>'

	'use strict';

	var url_schemas = __webpack_require__(112);

	/*eslint max-len:0*/
	var EMAIL_RE = /^<([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)>/;
	var AUTOLINK_RE = /^<([a-zA-Z.\-]{1,25}):([^<>\x00-\x20]*)>/;

	module.exports = function autolink(state, silent) {
	  var tail,
	      linkMatch,
	      emailMatch,
	      url,
	      fullUrl,
	      token,
	      pos = state.pos;

	  if (state.src.charCodeAt(pos) !== 0x3C /* < */) {
	      return false;
	    }

	  tail = state.src.slice(pos);

	  if (tail.indexOf('>') < 0) {
	    return false;
	  }

	  if (AUTOLINK_RE.test(tail)) {
	    linkMatch = tail.match(AUTOLINK_RE);

	    if (url_schemas.indexOf(linkMatch[1].toLowerCase()) < 0) {
	      return false;
	    }

	    url = linkMatch[0].slice(1, -1);
	    fullUrl = state.md.normalizeLink(url);
	    if (!state.md.validateLink(fullUrl)) {
	      return false;
	    }

	    if (!silent) {
	      token = state.push('link_open', 'a', 1);
	      token.attrs = [['href', fullUrl]];
	      token.markup = 'autolink';
	      token.info = 'auto';

	      token = state.push('text', '', 0);
	      token.content = state.md.normalizeLinkText(url);

	      token = state.push('link_close', 'a', -1);
	      token.markup = 'autolink';
	      token.info = 'auto';
	    }

	    state.pos += linkMatch[0].length;
	    return true;
	  }

	  if (EMAIL_RE.test(tail)) {
	    emailMatch = tail.match(EMAIL_RE);

	    url = emailMatch[0].slice(1, -1);
	    fullUrl = state.md.normalizeLink('mailto:' + url);
	    if (!state.md.validateLink(fullUrl)) {
	      return false;
	    }

	    if (!silent) {
	      token = state.push('link_open', 'a', 1);
	      token.attrs = [['href', fullUrl]];
	      token.markup = 'autolink';
	      token.info = 'auto';

	      token = state.push('text', '', 0);
	      token.content = state.md.normalizeLinkText(url);

	      token = state.push('link_close', 'a', -1);
	      token.markup = 'autolink';
	      token.info = 'auto';
	    }

	    state.pos += emailMatch[0].length;
	    return true;
	  }

	  return false;
	};

/***/ },
/* 112 */
/***/ function(module, exports) {

	// List of valid url schemas, accorting to commonmark spec
	// http://jgm.github.io/CommonMark/spec.html#autolinks

	'use strict';

	module.exports = ['coap', 'doi', 'javascript', 'aaa', 'aaas', 'about', 'acap', 'cap', 'cid', 'crid', 'data', 'dav', 'dict', 'dns', 'file', 'ftp', 'geo', 'go', 'gopher', 'h323', 'http', 'https', 'iax', 'icap', 'im', 'imap', 'info', 'ipp', 'iris', 'iris.beep', 'iris.xpc', 'iris.xpcs', 'iris.lwz', 'ldap', 'mailto', 'mid', 'msrp', 'msrps', 'mtqp', 'mupdate', 'news', 'nfs', 'ni', 'nih', 'nntp', 'opaquelocktoken', 'pop', 'pres', 'rtsp', 'service', 'session', 'shttp', 'sieve', 'sip', 'sips', 'sms', 'snmp', 'soap.beep', 'soap.beeps', 'tag', 'tel', 'telnet', 'tftp', 'thismessage', 'tn3270', 'tip', 'tv', 'urn', 'vemmi', 'ws', 'wss', 'xcon', 'xcon-userid', 'xmlrpc.beep', 'xmlrpc.beeps', 'xmpp', 'z39.50r', 'z39.50s', 'adiumxtra', 'afp', 'afs', 'aim', 'apt', 'attachment', 'aw', 'beshare', 'bitcoin', 'bolo', 'callto', 'chrome', 'chrome-extension', 'com-eventbrite-attendee', 'content', 'cvs', 'dlna-playsingle', 'dlna-playcontainer', 'dtn', 'dvb', 'ed2k', 'facetime', 'feed', 'finger', 'fish', 'gg', 'git', 'gizmoproject', 'gtalk', 'hcp', 'icon', 'ipn', 'irc', 'irc6', 'ircs', 'itms', 'jar', 'jms', 'keyparc', 'lastfm', 'ldaps', 'magnet', 'maps', 'market', 'message', 'mms', 'ms-help', 'msnim', 'mumble', 'mvn', 'notes', 'oid', 'palm', 'paparazzi', 'platform', 'proxy', 'psyc', 'query', 'res', 'resource', 'rmi', 'rsync', 'rtmp', 'secondlife', 'sftp', 'sgn', 'skype', 'smb', 'soldat', 'spotify', 'ssh', 'steam', 'svn', 'teamspeak', 'things', 'udp', 'unreal', 'ut2004', 'ventrilo', 'view-source', 'webcal', 'wtai', 'wyciwyg', 'xfire', 'xri', 'ymsgr'];

/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	// Process html tags

	'use strict';

	var HTML_TAG_RE = __webpack_require__(99).HTML_TAG_RE;

	function isLetter(ch) {
	  /*eslint no-bitwise:0*/
	  var lc = ch | 0x20; // to lower case
	  return lc >= 0x61 /* a */ && lc <= 0x7a /* z */;
	}

	module.exports = function html_inline(state, silent) {
	  var ch,
	      match,
	      max,
	      token,
	      pos = state.pos;

	  if (!state.md.options.html) {
	    return false;
	  }

	  // Check start
	  max = state.posMax;
	  if (state.src.charCodeAt(pos) !== 0x3C /* < */ || pos + 2 >= max) {
	    return false;
	  }

	  // Quick fail on second char
	  ch = state.src.charCodeAt(pos + 1);
	  if (ch !== 0x21 /* ! */ && ch !== 0x3F /* ? */ && ch !== 0x2F /* / */ && !isLetter(ch)) {
	    return false;
	  }

	  match = state.src.slice(pos).match(HTML_TAG_RE);
	  if (!match) {
	    return false;
	  }

	  if (!silent) {
	    token = state.push('html_inline', '', 0);
	    token.content = state.src.slice(pos, pos + match[0].length);
	  }
	  state.pos += match[0].length;
	  return true;
	};

/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	// Process html entity - &#123;, &#xAF;, &quot;, ...

	'use strict';

	var entities = __webpack_require__(59);
	var has = __webpack_require__(58).has;
	var isValidEntityCode = __webpack_require__(58).isValidEntityCode;
	var fromCodePoint = __webpack_require__(58).fromCodePoint;

	var DIGITAL_RE = /^&#((?:x[a-f0-9]{1,8}|[0-9]{1,8}));/i;
	var NAMED_RE = /^&([a-z][a-z0-9]{1,31});/i;

	module.exports = function entity(state, silent) {
	  var ch,
	      code,
	      match,
	      pos = state.pos,
	      max = state.posMax;

	  if (state.src.charCodeAt(pos) !== 0x26 /* & */) {
	      return false;
	    }

	  if (pos + 1 < max) {
	    ch = state.src.charCodeAt(pos + 1);

	    if (ch === 0x23 /* # */) {
	        match = state.src.slice(pos).match(DIGITAL_RE);
	        if (match) {
	          if (!silent) {
	            code = match[1][0].toLowerCase() === 'x' ? parseInt(match[1].slice(1), 16) : parseInt(match[1], 10);
	            state.pending += isValidEntityCode(code) ? fromCodePoint(code) : fromCodePoint(0xFFFD);
	          }
	          state.pos += match[0].length;
	          return true;
	        }
	      } else {
	      match = state.src.slice(pos).match(NAMED_RE);
	      if (match) {
	        if (has(entities, match[1])) {
	          if (!silent) {
	            state.pending += entities[match[1]];
	          }
	          state.pos += match[0].length;
	          return true;
	        }
	      }
	    }
	  }

	  if (!silent) {
	    state.pending += '&';
	  }
	  state.pos++;
	  return true;
	};

/***/ },
/* 115 */
/***/ function(module, exports) {

	// For each opening emphasis-like marker find a matching closing one
	//
	'use strict';

	module.exports = function link_pairs(state) {
	  var i,
	      j,
	      lastDelim,
	      currDelim,
	      delimiters = state.delimiters,
	      max = state.delimiters.length;

	  for (i = 0; i < max; i++) {
	    lastDelim = delimiters[i];

	    if (!lastDelim.close) {
	      continue;
	    }

	    j = i - lastDelim.jump - 1;

	    while (j >= 0) {
	      currDelim = delimiters[j];

	      if (currDelim.open && currDelim.marker === lastDelim.marker && currDelim.end < 0 && currDelim.level === lastDelim.level) {

	        lastDelim.jump = i - j;
	        lastDelim.open = false;
	        currDelim.end = i;
	        currDelim.jump = 0;
	        break;
	      }

	      j -= currDelim.jump + 1;
	    }
	  }
	};

/***/ },
/* 116 */
/***/ function(module, exports) {

	// Merge adjacent text nodes into one, and re-calculate all token levels
	//
	'use strict';

	module.exports = function text_collapse(state) {
	  var curr,
	      last,
	      level = 0,
	      tokens = state.tokens,
	      max = state.tokens.length;

	  for (curr = last = 0; curr < max; curr++) {
	    // re-calculate levels
	    level += tokens[curr].nesting;
	    tokens[curr].level = level;

	    if (tokens[curr].type === 'text' && curr + 1 < max && tokens[curr + 1].type === 'text') {

	      // collapse two adjacent text nodes
	      tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
	    } else {
	      if (curr !== last) {
	        tokens[last] = tokens[curr];
	      }

	      last++;
	    }
	  }

	  if (curr !== last) {
	    tokens.length = last;
	  }
	};

/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	// Inline parser state

	'use strict';

	var Token = __webpack_require__(86);
	var isWhiteSpace = __webpack_require__(58).isWhiteSpace;
	var isPunctChar = __webpack_require__(58).isPunctChar;
	var isMdAsciiPunct = __webpack_require__(58).isMdAsciiPunct;

	function StateInline(src, md, env, outTokens) {
	  this.src = src;
	  this.env = env;
	  this.md = md;
	  this.tokens = outTokens;

	  this.pos = 0;
	  this.posMax = this.src.length;
	  this.level = 0;
	  this.pending = '';
	  this.pendingLevel = 0;

	  this.cache = {}; // Stores { start: end } pairs. Useful for backtrack
	  // optimization of pairs parse (emphasis, strikes).

	  this.delimiters = []; // Emphasis-like delimiters
	}

	// Flush pending text
	//
	StateInline.prototype.pushPending = function () {
	  var token = new Token('text', '', 0);
	  token.content = this.pending;
	  token.level = this.pendingLevel;
	  this.tokens.push(token);
	  this.pending = '';
	  return token;
	};

	// Push new token to "stream".
	// If pending text exists - flush it as text token
	//
	StateInline.prototype.push = function (type, tag, nesting) {
	  if (this.pending) {
	    this.pushPending();
	  }

	  var token = new Token(type, tag, nesting);

	  if (nesting < 0) {
	    this.level--;
	  }
	  token.level = this.level;
	  if (nesting > 0) {
	    this.level++;
	  }

	  this.pendingLevel = this.level;
	  this.tokens.push(token);
	  return token;
	};

	// Scan a sequence of emphasis-like markers, and determine whether
	// it can start an emphasis sequence or end an emphasis sequence.
	//
	//  - start - position to scan from (it should point at a valid marker);
	//  - canSplitWord - determine if these markers can be found inside a word
	//
	StateInline.prototype.scanDelims = function (start, canSplitWord) {
	  var pos = start,
	      lastChar,
	      nextChar,
	      count,
	      can_open,
	      can_close,
	      isLastWhiteSpace,
	      isLastPunctChar,
	      isNextWhiteSpace,
	      isNextPunctChar,
	      left_flanking = true,
	      right_flanking = true,
	      max = this.posMax,
	      marker = this.src.charCodeAt(start);

	  // treat beginning of the line as a whitespace
	  lastChar = start > 0 ? this.src.charCodeAt(start - 1) : 0x20;

	  while (pos < max && this.src.charCodeAt(pos) === marker) {
	    pos++;
	  }

	  count = pos - start;

	  // treat end of the line as a whitespace
	  nextChar = pos < max ? this.src.charCodeAt(pos) : 0x20;

	  isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
	  isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));

	  isLastWhiteSpace = isWhiteSpace(lastChar);
	  isNextWhiteSpace = isWhiteSpace(nextChar);

	  if (isNextWhiteSpace) {
	    left_flanking = false;
	  } else if (isNextPunctChar) {
	    if (!(isLastWhiteSpace || isLastPunctChar)) {
	      left_flanking = false;
	    }
	  }

	  if (isLastWhiteSpace) {
	    right_flanking = false;
	  } else if (isLastPunctChar) {
	    if (!(isNextWhiteSpace || isNextPunctChar)) {
	      right_flanking = false;
	    }
	  }

	  if (!canSplitWord) {
	    can_open = left_flanking && (!right_flanking || isLastPunctChar);
	    can_close = right_flanking && (!left_flanking || isNextPunctChar);
	  } else {
	    can_open = left_flanking;
	    can_close = right_flanking;
	  }

	  return {
	    can_open: can_open,
	    can_close: can_close,
	    length: count
	  };
	};

	// re-export Token class to use in block rules
	StateInline.prototype.Token = Token;

	module.exports = StateInline;

/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'

	////////////////////////////////////////////////////////////////////////////////
	// Helpers

	// Merge objects
	//
	;
	function assign(obj /*from1, from2, from3, ...*/) {
	  var sources = Array.prototype.slice.call(arguments, 1);

	  sources.forEach(function (source) {
	    if (!source) {
	      return;
	    }

	    Object.keys(source).forEach(function (key) {
	      obj[key] = source[key];
	    });
	  });

	  return obj;
	}

	function _class(obj) {
	  return Object.prototype.toString.call(obj);
	}
	function isString(obj) {
	  return _class(obj) === '[object String]';
	}
	function isObject(obj) {
	  return _class(obj) === '[object Object]';
	}
	function isRegExp(obj) {
	  return _class(obj) === '[object RegExp]';
	}
	function isFunction(obj) {
	  return _class(obj) === '[object Function]';
	}

	function escapeRE(str) {
	  return str.replace(/[.?*+^$[\]\\(){}|-]/g, '\\$&');
	}

	////////////////////////////////////////////////////////////////////////////////

	var defaultOptions = {
	  fuzzyLink: true,
	  fuzzyEmail: true,
	  fuzzyIP: false
	};

	function isOptionsObj(obj) {
	  return Object.keys(obj || {}).reduce(function (acc, k) {
	    return acc || defaultOptions.hasOwnProperty(k);
	  }, false);
	}

	var defaultSchemas = {
	  'http:': {
	    validate: function (text, pos, self) {
	      var tail = text.slice(pos);

	      if (!self.re.http) {
	        // compile lazily, because "host"-containing variables can change on tlds update.
	        self.re.http = new RegExp('^\\/\\/' + self.re.src_auth + self.re.src_host_port_strict + self.re.src_path, 'i');
	      }
	      if (self.re.http.test(tail)) {
	        return tail.match(self.re.http)[0].length;
	      }
	      return 0;
	    }
	  },
	  'https:': 'http:',
	  'ftp:': 'http:',
	  '//': {
	    validate: function (text, pos, self) {
	      var tail = text.slice(pos);

	      if (!self.re.no_http) {
	        // compile lazily, becayse "host"-containing variables can change on tlds update.
	        self.re.no_http = new RegExp('^' + self.re.src_auth + self.re.src_host_port_strict + self.re.src_path, 'i');
	      }

	      if (self.re.no_http.test(tail)) {
	        // should not be `://`, that protects from errors in protocol name
	        if (pos >= 3 && text[pos - 3] === ':') {
	          return 0;
	        }
	        return tail.match(self.re.no_http)[0].length;
	      }
	      return 0;
	    }
	  },
	  'mailto:': {
	    validate: function (text, pos, self) {
	      var tail = text.slice(pos);

	      if (!self.re.mailto) {
	        self.re.mailto = new RegExp('^' + self.re.src_email_name + '@' + self.re.src_host_strict, 'i');
	      }
	      if (self.re.mailto.test(tail)) {
	        return tail.match(self.re.mailto)[0].length;
	      }
	      return 0;
	    }
	  }
	};

	/*eslint-disable max-len*/

	// RE pattern for 2-character tlds (autogenerated by ./support/tlds_2char_gen.js)
	var tlds_2ch_src_re = 'a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]';

	// DON'T try to make PRs with changes. Extend TLDs with LinkifyIt.tlds() instead
	var tlds_default = 'biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|'.split('|');

	/*eslint-enable max-len*/

	////////////////////////////////////////////////////////////////////////////////

	function resetScanCache(self) {
	  self.__index__ = -1;
	  self.__text_cache__ = '';
	}

	function createValidator(re) {
	  return function (text, pos) {
	    var tail = text.slice(pos);

	    if (re.test(tail)) {
	      return tail.match(re)[0].length;
	    }
	    return 0;
	  };
	}

	function createNormalizer() {
	  return function (match, self) {
	    self.normalize(match);
	  };
	}

	// Schemas compiler. Build regexps.
	//
	function compile(self) {

	  // Load & clone RE patterns.
	  var re = self.re = assign({}, __webpack_require__(119));

	  // Define dynamic patterns
	  var tlds = self.__tlds__.slice();

	  if (!self.__tlds_replaced__) {
	    tlds.push(tlds_2ch_src_re);
	  }
	  tlds.push(re.src_xn);

	  re.src_tlds = tlds.join('|');

	  function untpl(tpl) {
	    return tpl.replace('%TLDS%', re.src_tlds);
	  }

	  re.email_fuzzy = RegExp(untpl(re.tpl_email_fuzzy), 'i');
	  re.link_fuzzy = RegExp(untpl(re.tpl_link_fuzzy), 'i');
	  re.link_no_ip_fuzzy = RegExp(untpl(re.tpl_link_no_ip_fuzzy), 'i');
	  re.host_fuzzy_test = RegExp(untpl(re.tpl_host_fuzzy_test), 'i');

	  //
	  // Compile each schema
	  //

	  var aliases = [];

	  self.__compiled__ = {}; // Reset compiled data

	  function schemaError(name, val) {
	    throw new Error('(LinkifyIt) Invalid schema "' + name + '": ' + val);
	  }

	  Object.keys(self.__schemas__).forEach(function (name) {
	    var val = self.__schemas__[name];

	    // skip disabled methods
	    if (val === null) {
	      return;
	    }

	    var compiled = { validate: null, link: null };

	    self.__compiled__[name] = compiled;

	    if (isObject(val)) {
	      if (isRegExp(val.validate)) {
	        compiled.validate = createValidator(val.validate);
	      } else if (isFunction(val.validate)) {
	        compiled.validate = val.validate;
	      } else {
	        schemaError(name, val);
	      }

	      if (isFunction(val.normalize)) {
	        compiled.normalize = val.normalize;
	      } else if (!val.normalize) {
	        compiled.normalize = createNormalizer();
	      } else {
	        schemaError(name, val);
	      }

	      return;
	    }

	    if (isString(val)) {
	      aliases.push(name);
	      return;
	    }

	    schemaError(name, val);
	  });

	  //
	  // Compile postponed aliases
	  //

	  aliases.forEach(function (alias) {
	    if (!self.__compiled__[self.__schemas__[alias]]) {
	      // Silently fail on missed schemas to avoid errons on disable.
	      // schemaError(alias, self.__schemas__[alias]);
	      return;
	    }

	    self.__compiled__[alias].validate = self.__compiled__[self.__schemas__[alias]].validate;
	    self.__compiled__[alias].normalize = self.__compiled__[self.__schemas__[alias]].normalize;
	  });

	  //
	  // Fake record for guessed links
	  //
	  self.__compiled__[''] = { validate: null, normalize: createNormalizer() };

	  //
	  // Build schema condition
	  //
	  var slist = Object.keys(self.__compiled__).filter(function (name) {
	    // Filter disabled & fake schemas
	    return name.length > 0 && self.__compiled__[name];
	  }).map(escapeRE).join('|');
	  // (?!_) cause 1.5x slowdown
	  self.re.schema_test = RegExp('(^|(?!_)(?:>|' + re.src_ZPCc + '))(' + slist + ')', 'i');
	  self.re.schema_search = RegExp('(^|(?!_)(?:>|' + re.src_ZPCc + '))(' + slist + ')', 'ig');

	  self.re.pretest = RegExp('(' + self.re.schema_test.source + ')|' + '(' + self.re.host_fuzzy_test.source + ')|' + '@', 'i');

	  //
	  // Cleanup
	  //

	  resetScanCache(self);
	}

	/**
	 * class Match
	 *
	 * Match result. Single element of array, returned by [[LinkifyIt#match]]
	 **/
	function Match(self, shift) {
	  var start = self.__index__,
	      end = self.__last_index__,
	      text = self.__text_cache__.slice(start, end);

	  /**
	   * Match#schema -> String
	   *
	   * Prefix (protocol) for matched string.
	   **/
	  this.schema = self.__schema__.toLowerCase();
	  /**
	   * Match#index -> Number
	   *
	   * First position of matched string.
	   **/
	  this.index = start + shift;
	  /**
	   * Match#lastIndex -> Number
	   *
	   * Next position after matched string.
	   **/
	  this.lastIndex = end + shift;
	  /**
	   * Match#raw -> String
	   *
	   * Matched string.
	   **/
	  this.raw = text;
	  /**
	   * Match#text -> String
	   *
	   * Notmalized text of matched string.
	   **/
	  this.text = text;
	  /**
	   * Match#url -> String
	   *
	   * Normalized url of matched string.
	   **/
	  this.url = text;
	}

	function createMatch(self, shift) {
	  var match = new Match(self, shift);

	  self.__compiled__[match.schema].normalize(match, self);

	  return match;
	}

	/**
	 * class LinkifyIt
	 **/

	/**
	 * new LinkifyIt(schemas, options)
	 * - schemas (Object): Optional. Additional schemas to validate (prefix/validator)
	 * - options (Object): { fuzzyLink|fuzzyEmail|fuzzyIP: true|false }
	 *
	 * Creates new linkifier instance with optional additional schemas.
	 * Can be called without `new` keyword for convenience.
	 *
	 * By default understands:
	 *
	 * - `http(s)://...` , `ftp://...`, `mailto:...` & `//...` links
	 * - "fuzzy" links and emails (example.com, foo@bar.com).
	 *
	 * `schemas` is an object, where each key/value describes protocol/rule:
	 *
	 * - __key__ - link prefix (usually, protocol name with `:` at the end, `skype:`
	 *   for example). `linkify-it` makes shure that prefix is not preceeded with
	 *   alphanumeric char and symbols. Only whitespaces and punctuation allowed.
	 * - __value__ - rule to check tail after link prefix
	 *   - _String_ - just alias to existing rule
	 *   - _Object_
	 *     - _validate_ - validator function (should return matched length on success),
	 *       or `RegExp`.
	 *     - _normalize_ - optional function to normalize text & url of matched result
	 *       (for example, for @twitter mentions).
	 *
	 * `options`:
	 *
	 * - __fuzzyLink__ - recognige URL-s without `http(s):` prefix. Default `true`.
	 * - __fuzzyIP__ - allow IPs in fuzzy links above. Can conflict with some texts
	 *   like version numbers. Default `false`.
	 * - __fuzzyEmail__ - recognize emails without `mailto:` prefix.
	 *
	 **/
	function LinkifyIt(schemas, options) {
	  if (!(this instanceof LinkifyIt)) {
	    return new LinkifyIt(schemas, options);
	  }

	  if (!options) {
	    if (isOptionsObj(schemas)) {
	      options = schemas;
	      schemas = {};
	    }
	  }

	  this.__opts__ = assign({}, defaultOptions, options);

	  // Cache last tested result. Used to skip repeating steps on next `match` call.
	  this.__index__ = -1;
	  this.__last_index__ = -1; // Next scan position
	  this.__schema__ = '';
	  this.__text_cache__ = '';

	  this.__schemas__ = assign({}, defaultSchemas, schemas);
	  this.__compiled__ = {};

	  this.__tlds__ = tlds_default;
	  this.__tlds_replaced__ = false;

	  this.re = {};

	  compile(this);
	}

	/** chainable
	 * LinkifyIt#add(schema, definition)
	 * - schema (String): rule name (fixed pattern prefix)
	 * - definition (String|RegExp|Object): schema definition
	 *
	 * Add new rule definition. See constructor description for details.
	 **/
	LinkifyIt.prototype.add = function add(schema, definition) {
	  this.__schemas__[schema] = definition;
	  compile(this);
	  return this;
	};

	/** chainable
	 * LinkifyIt#set(options)
	 * - options (Object): { fuzzyLink|fuzzyEmail|fuzzyIP: true|false }
	 *
	 * Set recognition options for links without schema.
	 **/
	LinkifyIt.prototype.set = function set(options) {
	  this.__opts__ = assign(this.__opts__, options);
	  return this;
	};

	/**
	 * LinkifyIt#test(text) -> Boolean
	 *
	 * Searches linkifiable pattern and returns `true` on success or `false` on fail.
	 **/
	LinkifyIt.prototype.test = function test(text) {
	  // Reset scan cache
	  this.__text_cache__ = text;
	  this.__index__ = -1;

	  if (!text.length) {
	    return false;
	  }

	  var m, ml, me, len, shift, next, re, tld_pos, at_pos;

	  // try to scan for link with schema - that's the most simple rule
	  if (this.re.schema_test.test(text)) {
	    re = this.re.schema_search;
	    re.lastIndex = 0;
	    while ((m = re.exec(text)) !== null) {
	      len = this.testSchemaAt(text, m[2], re.lastIndex);
	      if (len) {
	        this.__schema__ = m[2];
	        this.__index__ = m.index + m[1].length;
	        this.__last_index__ = m.index + m[0].length + len;
	        break;
	      }
	    }
	  }

	  if (this.__opts__.fuzzyLink && this.__compiled__['http:']) {
	    // guess schemaless links
	    tld_pos = text.search(this.re.host_fuzzy_test);
	    if (tld_pos >= 0) {
	      // if tld is located after found link - no need to check fuzzy pattern
	      if (this.__index__ < 0 || tld_pos < this.__index__) {
	        if ((ml = text.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null) {

	          shift = ml.index + ml[1].length;

	          if (this.__index__ < 0 || shift < this.__index__) {
	            this.__schema__ = '';
	            this.__index__ = shift;
	            this.__last_index__ = ml.index + ml[0].length;
	          }
	        }
	      }
	    }
	  }

	  if (this.__opts__.fuzzyEmail && this.__compiled__['mailto:']) {
	    // guess schemaless emails
	    at_pos = text.indexOf('@');
	    if (at_pos >= 0) {
	      // We can't skip this check, because this cases are possible:
	      // 192.168.1.1@gmail.com, my.in@example.com
	      if ((me = text.match(this.re.email_fuzzy)) !== null) {

	        shift = me.index + me[1].length;
	        next = me.index + me[0].length;

	        if (this.__index__ < 0 || shift < this.__index__ || shift === this.__index__ && next > this.__last_index__) {
	          this.__schema__ = 'mailto:';
	          this.__index__ = shift;
	          this.__last_index__ = next;
	        }
	      }
	    }
	  }

	  return this.__index__ >= 0;
	};

	/**
	 * LinkifyIt#pretest(text) -> Boolean
	 *
	 * Very quick check, that can give false positives. Returns true if link MAY BE
	 * can exists. Can be used for speed optimization, when you need to check that
	 * link NOT exists.
	 **/
	LinkifyIt.prototype.pretest = function pretest(text) {
	  return this.re.pretest.test(text);
	};

	/**
	 * LinkifyIt#testSchemaAt(text, name, position) -> Number
	 * - text (String): text to scan
	 * - name (String): rule (schema) name
	 * - position (Number): text offset to check from
	 *
	 * Similar to [[LinkifyIt#test]] but checks only specific protocol tail exactly
	 * at given position. Returns length of found pattern (0 on fail).
	 **/
	LinkifyIt.prototype.testSchemaAt = function testSchemaAt(text, schema, pos) {
	  // If not supported schema check requested - terminate
	  if (!this.__compiled__[schema.toLowerCase()]) {
	    return 0;
	  }
	  return this.__compiled__[schema.toLowerCase()].validate(text, pos, this);
	};

	/**
	 * LinkifyIt#match(text) -> Array|null
	 *
	 * Returns array of found link descriptions or `null` on fail. We strongly
	 * to use [[LinkifyIt#test]] first, for best speed.
	 *
	 * ##### Result match description
	 *
	 * - __schema__ - link schema, can be empty for fuzzy links, or `//` for
	 *   protocol-neutral  links.
	 * - __index__ - offset of matched text
	 * - __lastIndex__ - index of next char after mathch end
	 * - __raw__ - matched text
	 * - __text__ - normalized text
	 * - __url__ - link, generated from matched text
	 **/
	LinkifyIt.prototype.match = function match(text) {
	  var shift = 0,
	      result = [];

	  // Try to take previous element from cache, if .test() called before
	  if (this.__index__ >= 0 && this.__text_cache__ === text) {
	    result.push(createMatch(this, shift));
	    shift = this.__last_index__;
	  }

	  // Cut head if cache was used
	  var tail = shift ? text.slice(shift) : text;

	  // Scan string until end reached
	  while (this.test(tail)) {
	    result.push(createMatch(this, shift));

	    tail = tail.slice(this.__last_index__);
	    shift += this.__last_index__;
	  }

	  if (result.length) {
	    return result;
	  }

	  return null;
	};

	/** chainable
	 * LinkifyIt#tlds(list [, keepOld]) -> this
	 * - list (Array): list of tlds
	 * - keepOld (Boolean): merge with current list if `true` (`false` by default)
	 *
	 * Load (or merge) new tlds list. Those are user for fuzzy links (without prefix)
	 * to avoid false positives. By default this algorythm used:
	 *
	 * - hostname with any 2-letter root zones are ok.
	 * - biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|
	 *   are ok.
	 * - encoded (`xn--...`) root zones are ok.
	 *
	 * If list is replaced, then exact match for 2-chars root zones will be checked.
	 **/
	LinkifyIt.prototype.tlds = function tlds(list, keepOld) {
	  list = Array.isArray(list) ? list : [list];

	  if (!keepOld) {
	    this.__tlds__ = list.slice();
	    this.__tlds_replaced__ = true;
	    compile(this);
	    return this;
	  }

	  this.__tlds__ = this.__tlds__.concat(list).sort().filter(function (el, idx, arr) {
	    return el !== arr[idx - 1];
	  }).reverse();

	  compile(this);
	  return this;
	};

	/**
	 * LinkifyIt#normalize(match)
	 *
	 * Default normalizer (if schema does not define it's own).
	 **/
	LinkifyIt.prototype.normalize = function normalize(match) {

	  // Do minimal possible changes by default. Need to collect feedback prior
	  // to move forward https://github.com/markdown-it/linkify-it/issues/1

	  if (!match.schema) {
	    match.url = 'http://' + match.url;
	  }

	  if (match.schema === 'mailto:' && !/^mailto:/i.test(match.url)) {
	    match.url = 'mailto:' + match.url;
	  }
	};

	module.exports = LinkifyIt;

/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'

	// Use direct extract instead of `regenerate` to reduse browserified size
	;
	var src_Any = exports.src_Any = __webpack_require__(68).source;
	var src_Cc = exports.src_Cc = __webpack_require__(69).source;
	var src_Z = exports.src_Z = __webpack_require__(71).source;
	var src_P = exports.src_P = __webpack_require__(61).source;

	// \p{\Z\P\Cc\CF} (white spaces + control + format + punctuation)
	var src_ZPCc = exports.src_ZPCc = [src_Z, src_P, src_Cc].join('|');

	// \p{\Z\Cc} (white spaces + control)
	var src_ZCc = exports.src_ZCc = [src_Z, src_Cc].join('|');

	// All possible word characters (everything without punctuation, spaces & controls)
	// Defined via punctuation & spaces to save space
	// Should be something like \p{\L\N\S\M} (\w but without `_`)
	var src_pseudo_letter = '(?:(?!' + src_ZPCc + ')' + src_Any + ')';
	// The same as abothe but without [0-9]
	var src_pseudo_letter_non_d = '(?:(?![0-9]|' + src_ZPCc + ')' + src_Any + ')';

	////////////////////////////////////////////////////////////////////////////////

	var src_ip4 = exports.src_ip4 = '(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)';

	exports.src_auth = '(?:(?:(?!' + src_ZCc + ').)+@)?';

	var src_port = exports.src_port = '(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?';

	var src_host_terminator = exports.src_host_terminator = '(?=$|' + src_ZPCc + ')(?!-|_|:\\d|\\.-|\\.(?!$|' + src_ZPCc + '))';

	var src_path = exports.src_path = '(?:' + '[/?#]' + '(?:' + '(?!' + src_ZCc + '|[()[\\]{}.,"\'?!\\-]).|' + '\\[(?:(?!' + src_ZCc + '|\\]).)*\\]|' + '\\((?:(?!' + src_ZCc + '|[)]).)*\\)|' + '\\{(?:(?!' + src_ZCc + '|[}]).)*\\}|' + '\\"(?:(?!' + src_ZCc + '|["]).)+\\"|' + "\\'(?:(?!" + src_ZCc + "|[']).)+\\'|" + "\\'(?=" + src_pseudo_letter + ').|' + // allow `I'm_king` if no pair found
	'\\.{2,3}[a-zA-Z0-9%/]|' + // github has ... in commit range links. Restrict to
	// - english
	// - percent-encoded
	// - parts of file path
	// until more examples found.
	'\\.(?!' + src_ZCc + '|[.]).|' + '\\-(?!--(?:[^-]|$))(?:-*)|' + // `---` => long dash, terminate
	'\\,(?!' + src_ZCc + ').|' + // allow `,,,` in paths
	'\\!(?!' + src_ZCc + '|[!]).|' + '\\?(?!' + src_ZCc + '|[?]).' + ')+' + '|\\/' + ')?';

	var src_email_name = exports.src_email_name = '[\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]+';

	var src_xn = exports.src_xn = 'xn--[a-z0-9\\-]{1,59}';

	// More to read about domain names
	// http://serverfault.com/questions/638260/

	var src_domain_root = exports.src_domain_root =

	// Can't have digits and dashes
	'(?:' + src_xn + '|' + src_pseudo_letter_non_d + '{1,63}' + ')';

	var src_domain = exports.src_domain = '(?:' + src_xn + '|' + '(?:' + src_pseudo_letter + ')' + '|' +
	// don't allow `--` in domain names, because:
	// - that can conflict with markdown &mdash; / &ndash;
	// - nobody use those anyway
	'(?:' + src_pseudo_letter + '(?:-(?!-)|' + src_pseudo_letter + '){0,61}' + src_pseudo_letter + ')' + ')';

	var src_host = exports.src_host = '(?:' + src_ip4 + '|' + '(?:(?:(?:' + src_domain + ')\\.)*' + src_domain_root + ')' + ')';

	var tpl_host_fuzzy = exports.tpl_host_fuzzy = '(?:' + src_ip4 + '|' + '(?:(?:(?:' + src_domain + ')\\.)+(?:%TLDS%))' + ')';

	var tpl_host_no_ip_fuzzy = exports.tpl_host_no_ip_fuzzy = '(?:(?:(?:' + src_domain + ')\\.)+(?:%TLDS%))';

	exports.src_host_strict = src_host + src_host_terminator;

	var tpl_host_fuzzy_strict = exports.tpl_host_fuzzy_strict = tpl_host_fuzzy + src_host_terminator;

	exports.src_host_port_strict = src_host + src_port + src_host_terminator;

	var tpl_host_port_fuzzy_strict = exports.tpl_host_port_fuzzy_strict = tpl_host_fuzzy + src_port + src_host_terminator;

	var tpl_host_port_no_ip_fuzzy_strict = exports.tpl_host_port_no_ip_fuzzy_strict = tpl_host_no_ip_fuzzy + src_port + src_host_terminator;

	////////////////////////////////////////////////////////////////////////////////
	// Main rules

	// Rude test fuzzy links by host, for quick deny
	exports.tpl_host_fuzzy_test = 'localhost|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:' + src_ZPCc + '|$))';

	exports.tpl_email_fuzzy = '(^|>|' + src_ZCc + ')(' + src_email_name + '@' + tpl_host_fuzzy_strict + ')';

	exports.tpl_link_fuzzy =
	// Fuzzy link can't be prepended with .:/\- and non punctuation.
	// but can start with > (markdown blockquote)
	'(^|(?![.:/\\-_@])(?:[$+<=>^`|]|' + src_ZPCc + '))' + '((?![$+<=>^`|])' + tpl_host_port_fuzzy_strict + src_path + ')';

	exports.tpl_link_no_ip_fuzzy =
	// Fuzzy link can't be prepended with .:/\- and non punctuation.
	// but can start with > (markdown blockquote)
	'(^|(?![.:/\\-_@])(?:[$+<=>^`|]|' + src_ZPCc + '))' + '((?![$+<=>^`|])' + tpl_host_port_no_ip_fuzzy_strict + src_path + ')';

/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/*! https://mths.be/punycode v1.3.2 by @mathias */
	;(function (root) {

		/** Detect free variables */
		var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
		var freeModule = typeof module == 'object' && module && !module.nodeType && module;
		var freeGlobal = typeof global == 'object' && global;
		if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
			root = freeGlobal;
		}

		/**
	  * The `punycode` object.
	  * @name punycode
	  * @type Object
	  */
		var punycode,
		   

		/** Highest positive signed 32-bit float value */
		maxInt = 2147483647,
		    // aka. 0x7FFFFFFF or 2^31-1

		/** Bootstring parameters */
		base = 36,
		    tMin = 1,
		    tMax = 26,
		    skew = 38,
		    damp = 700,
		    initialBias = 72,
		    initialN = 128,
		    // 0x80
		delimiter = '-',
		    // '\x2D'

		/** Regular expressions */
		regexPunycode = /^xn--/,
		    regexNonASCII = /[^\x20-\x7E]/,
		    // unprintable ASCII chars + non-ASCII chars
		regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g,
		    // RFC 3490 separators

		/** Error messages */
		errors = {
			'overflow': 'Overflow: input needs wider integers to process',
			'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
			'invalid-input': 'Invalid input'
		},
		   

		/** Convenience shortcuts */
		baseMinusTMin = base - tMin,
		    floor = Math.floor,
		    stringFromCharCode = String.fromCharCode,
		   

		/** Temporary variable */
		key;

		/*--------------------------------------------------------------------------*/

		/**
	  * A generic error utility function.
	  * @private
	  * @param {String} type The error type.
	  * @returns {Error} Throws a `RangeError` with the applicable error message.
	  */
		function error(type) {
			throw RangeError(errors[type]);
		}

		/**
	  * A generic `Array#map` utility function.
	  * @private
	  * @param {Array} array The array to iterate over.
	  * @param {Function} callback The function that gets called for every array
	  * item.
	  * @returns {Array} A new array of values returned by the callback function.
	  */
		function map(array, fn) {
			var length = array.length;
			var result = [];
			while (length--) {
				result[length] = fn(array[length]);
			}
			return result;
		}

		/**
	  * A simple `Array#map`-like wrapper to work with domain name strings or email
	  * addresses.
	  * @private
	  * @param {String} domain The domain name or email address.
	  * @param {Function} callback The function that gets called for every
	  * character.
	  * @returns {Array} A new string of characters returned by the callback
	  * function.
	  */
		function mapDomain(string, fn) {
			var parts = string.split('@');
			var result = '';
			if (parts.length > 1) {
				// In email addresses, only the domain name should be punycoded. Leave
				// the local part (i.e. everything up to `@`) intact.
				result = parts[0] + '@';
				string = parts[1];
			}
			// Avoid `split(regex)` for IE8 compatibility. See #17.
			string = string.replace(regexSeparators, '\x2E');
			var labels = string.split('.');
			var encoded = map(labels, fn).join('.');
			return result + encoded;
		}

		/**
	  * Creates an array containing the numeric code points of each Unicode
	  * character in the string. While JavaScript uses UCS-2 internally,
	  * this function will convert a pair of surrogate halves (each of which
	  * UCS-2 exposes as separate characters) into a single code point,
	  * matching UTF-16.
	  * @see `punycode.ucs2.encode`
	  * @see <https://mathiasbynens.be/notes/javascript-encoding>
	  * @memberOf punycode.ucs2
	  * @name decode
	  * @param {String} string The Unicode input string (UCS-2).
	  * @returns {Array} The new array of code points.
	  */
		function ucs2decode(string) {
			var output = [],
			    counter = 0,
			    length = string.length,
			    value,
			    extra;
			while (counter < length) {
				value = string.charCodeAt(counter++);
				if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
					// high surrogate, and there is a next character
					extra = string.charCodeAt(counter++);
					if ((extra & 0xFC00) == 0xDC00) {
						// low surrogate
						output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
					} else {
						// unmatched surrogate; only append this code unit, in case the next
						// code unit is the high surrogate of a surrogate pair
						output.push(value);
						counter--;
					}
				} else {
					output.push(value);
				}
			}
			return output;
		}

		/**
	  * Creates a string based on an array of numeric code points.
	  * @see `punycode.ucs2.decode`
	  * @memberOf punycode.ucs2
	  * @name encode
	  * @param {Array} codePoints The array of numeric code points.
	  * @returns {String} The new Unicode string (UCS-2).
	  */
		function ucs2encode(array) {
			return map(array, function (value) {
				var output = '';
				if (value > 0xFFFF) {
					value -= 0x10000;
					output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
					value = 0xDC00 | value & 0x3FF;
				}
				output += stringFromCharCode(value);
				return output;
			}).join('');
		}

		/**
	  * Converts a basic code point into a digit/integer.
	  * @see `digitToBasic()`
	  * @private
	  * @param {Number} codePoint The basic numeric code point value.
	  * @returns {Number} The numeric value of a basic code point (for use in
	  * representing integers) in the range `0` to `base - 1`, or `base` if
	  * the code point does not represent a value.
	  */
		function basicToDigit(codePoint) {
			if (codePoint - 48 < 10) {
				return codePoint - 22;
			}
			if (codePoint - 65 < 26) {
				return codePoint - 65;
			}
			if (codePoint - 97 < 26) {
				return codePoint - 97;
			}
			return base;
		}

		/**
	  * Converts a digit/integer into a basic code point.
	  * @see `basicToDigit()`
	  * @private
	  * @param {Number} digit The numeric value of a basic code point.
	  * @returns {Number} The basic code point whose value (when used for
	  * representing integers) is `digit`, which needs to be in the range
	  * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	  * used; else, the lowercase form is used. The behavior is undefined
	  * if `flag` is non-zero and `digit` has no uppercase form.
	  */
		function digitToBasic(digit, flag) {
			//  0..25 map to ASCII a..z or A..Z
			// 26..35 map to ASCII 0..9
			return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
		}

		/**
	  * Bias adaptation function as per section 3.4 of RFC 3492.
	  * http://tools.ietf.org/html/rfc3492#section-3.4
	  * @private
	  */
		function adapt(delta, numPoints, firstTime) {
			var k = 0;
			delta = firstTime ? floor(delta / damp) : delta >> 1;
			delta += floor(delta / numPoints);
			for (; /* no initialization */delta > baseMinusTMin * tMax >> 1; k += base) {
				delta = floor(delta / baseMinusTMin);
			}
			return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
		}

		/**
	  * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	  * symbols.
	  * @memberOf punycode
	  * @param {String} input The Punycode string of ASCII-only symbols.
	  * @returns {String} The resulting string of Unicode symbols.
	  */
		function decode(input) {
			// Don't use UCS-2
			var output = [],
			    inputLength = input.length,
			    out,
			    i = 0,
			    n = initialN,
			    bias = initialBias,
			    basic,
			    j,
			    index,
			    oldi,
			    w,
			    k,
			    digit,
			    t,
			   
			/** Cached calculation results */
			baseMinusT;

			// Handle the basic code points: let `basic` be the number of input code
			// points before the last delimiter, or `0` if there is none, then copy
			// the first basic code points to the output.

			basic = input.lastIndexOf(delimiter);
			if (basic < 0) {
				basic = 0;
			}

			for (j = 0; j < basic; ++j) {
				// if it's not a basic code point
				if (input.charCodeAt(j) >= 0x80) {
					error('not-basic');
				}
				output.push(input.charCodeAt(j));
			}

			// Main decoding loop: start just after the last delimiter if any basic code
			// points were copied; start at the beginning otherwise.

			for (index = basic > 0 ? basic + 1 : 0; index < inputLength;) /* no final expression */{

				// `index` is the index of the next character to be consumed.
				// Decode a generalized variable-length integer into `delta`,
				// which gets added to `i`. The overflow checking is easier
				// if we increase `i` as we go, then subtract off its starting
				// value at the end to obtain `delta`.
				for (oldi = i, w = 1, k = base;; /* no condition */k += base) {

					if (index >= inputLength) {
						error('invalid-input');
					}

					digit = basicToDigit(input.charCodeAt(index++));

					if (digit >= base || digit > floor((maxInt - i) / w)) {
						error('overflow');
					}

					i += digit * w;
					t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

					if (digit < t) {
						break;
					}

					baseMinusT = base - t;
					if (w > floor(maxInt / baseMinusT)) {
						error('overflow');
					}

					w *= baseMinusT;
				}

				out = output.length + 1;
				bias = adapt(i - oldi, out, oldi == 0);

				// `i` was supposed to wrap around from `out` to `0`,
				// incrementing `n` each time, so we'll fix that now:
				if (floor(i / out) > maxInt - n) {
					error('overflow');
				}

				n += floor(i / out);
				i %= out;

				// Insert `n` at position `i` of the output
				output.splice(i++, 0, n);
			}

			return ucs2encode(output);
		}

		/**
	  * Converts a string of Unicode symbols (e.g. a domain name label) to a
	  * Punycode string of ASCII-only symbols.
	  * @memberOf punycode
	  * @param {String} input The string of Unicode symbols.
	  * @returns {String} The resulting Punycode string of ASCII-only symbols.
	  */
		function encode(input) {
			var n,
			    delta,
			    handledCPCount,
			    basicLength,
			    bias,
			    j,
			    m,
			    q,
			    k,
			    t,
			    currentValue,
			    output = [],
			   
			/** `inputLength` will hold the number of code points in `input`. */
			inputLength,
			   
			/** Cached calculation results */
			handledCPCountPlusOne,
			    baseMinusT,
			    qMinusT;

			// Convert the input in UCS-2 to Unicode
			input = ucs2decode(input);

			// Cache the length
			inputLength = input.length;

			// Initialize the state
			n = initialN;
			delta = 0;
			bias = initialBias;

			// Handle the basic code points
			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue < 0x80) {
					output.push(stringFromCharCode(currentValue));
				}
			}

			handledCPCount = basicLength = output.length;

			// `handledCPCount` is the number of code points that have been handled;
			// `basicLength` is the number of basic code points.

			// Finish the basic string - if it is not empty - with a delimiter
			if (basicLength) {
				output.push(delimiter);
			}

			// Main encoding loop:
			while (handledCPCount < inputLength) {

				// All non-basic code points < n have been handled already. Find the next
				// larger one:
				for (m = maxInt, j = 0; j < inputLength; ++j) {
					currentValue = input[j];
					if (currentValue >= n && currentValue < m) {
						m = currentValue;
					}
				}

				// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
				// but guard against overflow
				handledCPCountPlusOne = handledCPCount + 1;
				if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
					error('overflow');
				}

				delta += (m - n) * handledCPCountPlusOne;
				n = m;

				for (j = 0; j < inputLength; ++j) {
					currentValue = input[j];

					if (currentValue < n && ++delta > maxInt) {
						error('overflow');
					}

					if (currentValue == n) {
						// Represent delta as a generalized variable-length integer
						for (q = delta, k = base;; /* no condition */k += base) {
							t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
							if (q < t) {
								break;
							}
							qMinusT = q - t;
							baseMinusT = base - t;
							output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
							q = floor(qMinusT / baseMinusT);
						}

						output.push(stringFromCharCode(digitToBasic(q, 0)));
						bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
						delta = 0;
						++handledCPCount;
					}
				}

				++delta;
				++n;
			}
			return output.join('');
		}

		/**
	  * Converts a Punycode string representing a domain name or an email address
	  * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	  * it doesn't matter if you call it on a string that has already been
	  * converted to Unicode.
	  * @memberOf punycode
	  * @param {String} input The Punycoded domain name or email address to
	  * convert to Unicode.
	  * @returns {String} The Unicode representation of the given Punycode
	  * string.
	  */
		function toUnicode(input) {
			return mapDomain(input, function (string) {
				return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
			});
		}

		/**
	  * Converts a Unicode string representing a domain name or an email address to
	  * Punycode. Only the non-ASCII parts of the domain name will be converted,
	  * i.e. it doesn't matter if you call it with a domain that's already in
	  * ASCII.
	  * @memberOf punycode
	  * @param {String} input The domain name or email address to convert, as a
	  * Unicode string.
	  * @returns {String} The Punycode representation of the given domain name or
	  * email address.
	  */
		function toASCII(input) {
			return mapDomain(input, function (string) {
				return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
			});
		}

		/*--------------------------------------------------------------------------*/

		/** Define the public API */
		punycode = {
			/**
	   * A string representing the current Punycode.js version number.
	   * @memberOf punycode
	   * @type String
	   */
			'version': '1.3.2',
			/**
	   * An object of methods to convert from JavaScript's internal character
	   * representation (UCS-2) to Unicode code points, and back.
	   * @see <https://mathiasbynens.be/notes/javascript-encoding>
	   * @memberOf punycode
	   * @type Object
	   */
			'ucs2': {
				'decode': ucs2decode,
				'encode': ucs2encode
			},
			'decode': decode,
			'encode': encode,
			'toASCII': toASCII,
			'toUnicode': toUnicode
		};

		/** Expose `punycode` */
		// Some AMD build optimizers, like r.js, check for specific condition patterns
		// like the following:
		if (true) {
			!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
				return punycode;
			}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else if (freeExports && freeModule) {
			if (module.exports == freeExports) {
				// in Node.js or RingoJS v0.8.0+
				freeModule.exports = punycode;
			} else {
				// in Narwhal or RingoJS v0.7.0-
				for (key in punycode) {
					punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
				}
			}
		} else {
			// in Rhino or a web browser
			root.punycode = punycode;
		}
	})(this);
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(121)(module), (function() { return this; }())))

/***/ },
/* 121 */
/***/ function(module, exports) {

	module.exports = function (module) {
		if (!module.webpackPolyfill) {
			module.deprecate = function () {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	};

/***/ },
/* 122 */
/***/ function(module, exports) {

	// markdown-it default options

	'use strict';

	module.exports = {
	  options: {
	    html: false, // Enable HTML tags in source
	    xhtmlOut: false, // Use '/' to close single tags (<br />)
	    breaks: false, // Convert '\n' in paragraphs into <br>
	    langPrefix: 'language-', // CSS language prefix for fenced blocks
	    linkify: false, // autoconvert URL-like texts to links

	    // Enable some language-neutral replacements + quotes beautification
	    typographer: false,

	    // Double + single quotes replacement pairs, when typographer enabled,
	    // and smartquotes on. Could be either a String or an Array.
	    //
	    // For example, you can use '' for Russian, '' for German,
	    // and ['\xA0', '\xA0', '\xA0', '\xA0'] for French (including nbsp).
	    quotes: '\u201c\u201d\u2018\u2019', /*  */

	    // Highlighter function. Should return escaped HTML,
	    // or '' if input not changed
	    //
	    // function (/*str, lang*/) { return ''; }
	    //
	    highlight: null,

	    maxNesting: 20 // Internal protection, recursion limit
	  },

	  components: {

	    core: {},
	    block: {},
	    inline: {}
	  }
	};

/***/ },
/* 123 */
/***/ function(module, exports) {

	// "Zero" preset, with nothing enabled. Useful for manual configuring of simple
	// modes. For example, to parse bold/italic only.

	'use strict';

	module.exports = {
	  options: {
	    html: false, // Enable HTML tags in source
	    xhtmlOut: false, // Use '/' to close single tags (<br />)
	    breaks: false, // Convert '\n' in paragraphs into <br>
	    langPrefix: 'language-', // CSS language prefix for fenced blocks
	    linkify: false, // autoconvert URL-like texts to links

	    // Enable some language-neutral replacements + quotes beautification
	    typographer: false,

	    // Double + single quotes replacement pairs, when typographer enabled,
	    // and smartquotes on. Could be either a String or an Array.
	    //
	    // For example, you can use '' for Russian, '' for German,
	    // and ['\xA0', '\xA0', '\xA0', '\xA0'] for French (including nbsp).
	    quotes: '\u201c\u201d\u2018\u2019', /*  */

	    // Highlighter function. Should return escaped HTML,
	    // or '' if input not changed
	    //
	    // function (/*str, lang*/) { return ''; }
	    //
	    highlight: null,

	    maxNesting: 20 // Internal protection, recursion limit
	  },

	  components: {

	    core: {
	      rules: ['normalize', 'block', 'inline']
	    },

	    block: {
	      rules: ['paragraph']
	    },

	    inline: {
	      rules: ['text'],
	      rules2: ['balance_pairs', 'text_collapse']
	    }
	  }
	};

/***/ },
/* 124 */
/***/ function(module, exports) {

	// Commonmark default options

	'use strict';

	module.exports = {
	  options: {
	    html: true, // Enable HTML tags in source
	    xhtmlOut: true, // Use '/' to close single tags (<br />)
	    breaks: false, // Convert '\n' in paragraphs into <br>
	    langPrefix: 'language-', // CSS language prefix for fenced blocks
	    linkify: false, // autoconvert URL-like texts to links

	    // Enable some language-neutral replacements + quotes beautification
	    typographer: false,

	    // Double + single quotes replacement pairs, when typographer enabled,
	    // and smartquotes on. Could be either a String or an Array.
	    //
	    // For example, you can use '' for Russian, '' for German,
	    // and ['\xA0', '\xA0', '\xA0', '\xA0'] for French (including nbsp).
	    quotes: '\u201c\u201d\u2018\u2019', /*  */

	    // Highlighter function. Should return escaped HTML,
	    // or '' if input not changed
	    //
	    // function (/*str, lang*/) { return ''; }
	    //
	    highlight: null,

	    maxNesting: 20 // Internal protection, recursion limit
	  },

	  components: {

	    core: {
	      rules: ['normalize', 'block', 'inline']
	    },

	    block: {
	      rules: ['blockquote', 'code', 'fence', 'heading', 'hr', 'html_block', 'lheading', 'list', 'reference', 'paragraph']
	    },

	    inline: {
	      rules: ['autolink', 'backticks', 'emphasis', 'entity', 'escape', 'html_inline', 'image', 'link', 'newline', 'text'],
	      rules2: ['balance_pairs', 'emphasis', 'text_collapse']
	    }
	  }
	};

/***/ },
/* 125 */
/***/ function(module, exports) {

	'use strict'
	/*jshint node:true*/

	;
	module.exports = function wikilink_plugin(md, scheme) {
	  var oldLinkOpenOverride = md.renderer.rules.link_open;

	  scheme = scheme || 'http://';

	  md.renderer.rules.link_open = function (tokens, idx, options, env, self) {
	    var hrefIndex = tokens[idx].attrIndex('href');

	    if (hrefIndex >= 0 && tokens[idx].attrs[hrefIndex][1] == "") {
	      tokens[idx].attrs[hrefIndex][1] = encodeURI(tokens[idx + 1].content);
	    }

	    if (oldLinkOpenOverride) {
	      return oldLinkOpenOverride.apply(self, arguments);
	    } else {
	      // There was no previous renderer override. Just call the default.
	      return self.renderToken.apply(self, arguments);
	    }
	  };
	};

/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * jQuery JavaScript Library v2.1.4
	 * http://jquery.com/
	 *
	 * Includes Sizzle.js
	 * http://sizzlejs.com/
	 *
	 * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors
	 * Released under the MIT license
	 * http://jquery.org/license
	 *
	 * Date: 2015-04-28T16:01Z
	 */(function(global,factory){if(typeof module==="object"&&typeof module.exports==="object"){ // For CommonJS and CommonJS-like environments where a proper `window`
	// is present, execute the factory and get jQuery.
	// For environments that do not have a `window` with a `document`
	// (such as Node.js), expose a factory as module.exports.
	// This accentuates the need for the creation of a real `window`.
	// e.g. var jQuery = require("jquery")(window);
	// See ticket #14549 for more info.
	module.exports=global.document?factory(global,true):function(w){if(!w.document){throw new Error("jQuery requires a window with a document")}return factory(w)}}else {factory(global)} // Pass this if window is not defined yet
	})(typeof window!=="undefined"?window:this,function(window,noGlobal){ // Support: Firefox 18+
	// Can't be in strict mode, several libs including ASP.NET trace
	// the stack via arguments.caller.callee and Firefox dies if
	// you try to trace through "use strict" call chains. (#13335)
	//
	var arr=[];var slice=arr.slice;var concat=arr.concat;var push=arr.push;var indexOf=arr.indexOf;var class2type={};var toString=class2type.toString;var hasOwn=class2type.hasOwnProperty;var support={};var  // Use the correct document accordingly with window argument (sandbox)
	document=window.document,version="2.1.4", // Define a local copy of jQuery
	jQuery=function(selector,context){ // The jQuery object is actually just the init constructor 'enhanced'
	// Need init if jQuery is called (just allow error to be thrown if not included)
	return new jQuery.fn.init(selector,context)}, // Support: Android<4.1
	// Make sure we trim BOM and NBSP
	rtrim=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, // Matches dashed string for camelizing
	rmsPrefix=/^-ms-/,rdashAlpha=/-([\da-z])/gi, // Used by jQuery.camelCase as callback to replace()
	fcamelCase=function(all,letter){return letter.toUpperCase()};jQuery.fn=jQuery.prototype={ // The current version of jQuery being used
	jquery:version,constructor:jQuery, // Start with an empty selector
	selector:"", // The default length of a jQuery object is 0
	length:0,toArray:function(){return slice.call(this)}, // Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get:function(num){return num!=null? // Return just the one element from the set
	num<0?this[num+this.length]:this[num]: // Return all the elements in a clean array
	slice.call(this)}, // Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack:function(elems){ // Build a new jQuery matched element set
	var ret=jQuery.merge(this.constructor(),elems); // Add the old object onto the stack (as a reference)
	ret.prevObject=this;ret.context=this.context; // Return the newly-formed element set
	return ret}, // Execute a callback for every element in the matched set.
	// (You can seed the arguments with an array of args, but this is
	// only used internally.)
	each:function(callback,args){return jQuery.each(this,callback,args)},map:function(callback){return this.pushStack(jQuery.map(this,function(elem,i){return callback.call(elem,i,elem)}))},slice:function(){return this.pushStack(slice.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(i){var len=this.length,j=+i+(i<0?len:0);return this.pushStack(j>=0&&j<len?[this[j]]:[])},end:function(){return this.prevObject||this.constructor(null)}, // For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push:push,sort:arr.sort,splice:arr.splice};jQuery.extend=jQuery.fn.extend=function(){var options,name,src,copy,copyIsArray,clone,target=arguments[0]||{},i=1,length=arguments.length,deep=false; // Handle a deep copy situation
	if(typeof target==="boolean"){deep=target; // Skip the boolean and the target
	target=arguments[i]||{};i++} // Handle case when target is a string or something (possible in deep copy)
	if(typeof target!=="object"&&!jQuery.isFunction(target)){target={}} // Extend jQuery itself if only one argument is passed
	if(i===length){target=this;i--}for(;i<length;i++){ // Only deal with non-null/undefined values
	if((options=arguments[i])!=null){ // Extend the base object
	for(name in options){src=target[name];copy=options[name]; // Prevent never-ending loop
	if(target===copy){continue} // Recurse if we're merging plain objects or arrays
	if(deep&&copy&&(jQuery.isPlainObject(copy)||(copyIsArray=jQuery.isArray(copy)))){if(copyIsArray){copyIsArray=false;clone=src&&jQuery.isArray(src)?src:[]}else {clone=src&&jQuery.isPlainObject(src)?src:{}} // Never move original objects, clone them
	target[name]=jQuery.extend(deep,clone,copy); // Don't bring in undefined values
	}else if(copy!==undefined){target[name]=copy}}}} // Return the modified object
	return target};jQuery.extend({ // Unique for each copy of jQuery on the page
	expando:"jQuery"+(version+Math.random()).replace(/\D/g,""), // Assume jQuery is ready without the ready module
	isReady:true,error:function(msg){throw new Error(msg)},noop:function(){},isFunction:function(obj){return jQuery.type(obj)==="function"},isArray:Array.isArray,isWindow:function(obj){return obj!=null&&obj===obj.window},isNumeric:function(obj){ // parseFloat NaNs numeric-cast false positives (null|true|false|"")
	// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
	// subtraction forces infinities to NaN
	// adding 1 corrects loss of precision from parseFloat (#15100)
	return !jQuery.isArray(obj)&&obj-parseFloat(obj)+1>=0},isPlainObject:function(obj){ // Not plain objects:
	// - Any object or value whose internal [[Class]] property is not "[object Object]"
	// - DOM nodes
	// - window
	if(jQuery.type(obj)!=="object"||obj.nodeType||jQuery.isWindow(obj)){return false}if(obj.constructor&&!hasOwn.call(obj.constructor.prototype,"isPrototypeOf")){return false} // If the function hasn't returned already, we're confident that
	// |obj| is a plain object, created by {} or constructed with new Object
	return true},isEmptyObject:function(obj){var name;for(name in obj){return false}return true},type:function(obj){if(obj==null){return obj+""} // Support: Android<4.0, iOS<6 (functionish RegExp)
	return typeof obj==="object"||typeof obj==="function"?class2type[toString.call(obj)]||"object":typeof obj}, // Evaluates a script in a global context
	globalEval:function(code){var script,indirect=eval;code=jQuery.trim(code);if(code){ // If the code includes a valid, prologue position
	// strict mode pragma, execute code by injecting a
	// script tag into the document.
	if(code.indexOf("use strict")===1){script=document.createElement("script");script.text=code;document.head.appendChild(script).parentNode.removeChild(script)}else { // Otherwise, avoid the DOM node creation, insertion
	// and removal by using an indirect global eval
	indirect(code)}}}, // Convert dashed to camelCase; used by the css and data modules
	// Support: IE9-11+
	// Microsoft forgot to hump their vendor prefix (#9572)
	camelCase:function(string){return string.replace(rmsPrefix,"ms-").replace(rdashAlpha,fcamelCase)},nodeName:function(elem,name){return elem.nodeName&&elem.nodeName.toLowerCase()===name.toLowerCase()}, // args is for internal usage only
	each:function(obj,callback,args){var value,i=0,length=obj.length,isArray=isArraylike(obj);if(args){if(isArray){for(;i<length;i++){value=callback.apply(obj[i],args);if(value===false){break}}}else {for(i in obj){value=callback.apply(obj[i],args);if(value===false){break}}} // A special, fast, case for the most common use of each
	}else {if(isArray){for(;i<length;i++){value=callback.call(obj[i],i,obj[i]);if(value===false){break}}}else {for(i in obj){value=callback.call(obj[i],i,obj[i]);if(value===false){break}}}}return obj}, // Support: Android<4.1
	trim:function(text){return text==null?"":(text+"").replace(rtrim,"")}, // results is for internal usage only
	makeArray:function(arr,results){var ret=results||[];if(arr!=null){if(isArraylike(Object(arr))){jQuery.merge(ret,typeof arr==="string"?[arr]:arr)}else {push.call(ret,arr)}}return ret},inArray:function(elem,arr,i){return arr==null?-1:indexOf.call(arr,elem,i)},merge:function(first,second){var len=+second.length,j=0,i=first.length;for(;j<len;j++){first[i++]=second[j]}first.length=i;return first},grep:function(elems,callback,invert){var callbackInverse,matches=[],i=0,length=elems.length,callbackExpect=!invert; // Go through the array, only saving the items
	// that pass the validator function
	for(;i<length;i++){callbackInverse=!callback(elems[i],i);if(callbackInverse!==callbackExpect){matches.push(elems[i])}}return matches}, // arg is for internal usage only
	map:function(elems,callback,arg){var value,i=0,length=elems.length,isArray=isArraylike(elems),ret=[]; // Go through the array, translating each of the items to their new values
	if(isArray){for(;i<length;i++){value=callback(elems[i],i,arg);if(value!=null){ret.push(value)}} // Go through every key on the object,
	}else {for(i in elems){value=callback(elems[i],i,arg);if(value!=null){ret.push(value)}}} // Flatten any nested arrays
	return concat.apply([],ret)}, // A global GUID counter for objects
	guid:1, // Bind a function to a context, optionally partially applying any
	// arguments.
	proxy:function(fn,context){var tmp,args,proxy;if(typeof context==="string"){tmp=fn[context];context=fn;fn=tmp} // Quick check to determine if target is callable, in the spec
	// this throws a TypeError, but we will just return undefined.
	if(!jQuery.isFunction(fn)){return undefined} // Simulated bind
	args=slice.call(arguments,2);proxy=function(){return fn.apply(context||this,args.concat(slice.call(arguments)))}; // Set the guid of unique handler to the same of original handler, so it can be removed
	proxy.guid=fn.guid=fn.guid||jQuery.guid++;return proxy},now:Date.now, // jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support:support}); // Populate the class2type map
	jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "),function(i,name){class2type["[object "+name+"]"]=name.toLowerCase()});function isArraylike(obj){ // Support: iOS 8.2 (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length="length" in obj&&obj.length,type=jQuery.type(obj);if(type==="function"||jQuery.isWindow(obj)){return false}if(obj.nodeType===1&&length){return true}return type==="array"||length===0||typeof length==="number"&&length>0&&length-1 in obj}var Sizzle= /*!
	 * Sizzle CSS Selector Engine v2.2.0-pre
	 * http://sizzlejs.com/
	 *
	 * Copyright 2008, 2014 jQuery Foundation, Inc. and other contributors
	 * Released under the MIT license
	 * http://jquery.org/license
	 *
	 * Date: 2014-12-16
	 */(function(window){var i,support,Expr,getText,isXML,tokenize,compile,select,outermostContext,sortInput,hasDuplicate, // Local document vars
	setDocument,document,docElem,documentIsHTML,rbuggyQSA,rbuggyMatches,matches,contains, // Instance-specific data
	expando="sizzle"+1*new Date,preferredDoc=window.document,dirruns=0,done=0,classCache=createCache(),tokenCache=createCache(),compilerCache=createCache(),sortOrder=function(a,b){if(a===b){hasDuplicate=true}return 0}, // General-purpose constants
	MAX_NEGATIVE=1<<31, // Instance methods
	hasOwn=({}).hasOwnProperty,arr=[],pop=arr.pop,push_native=arr.push,push=arr.push,slice=arr.slice, // Use a stripped-down indexOf as it's faster than native
	// http://jsperf.com/thor-indexof-vs-for/5
	indexOf=function(list,elem){var i=0,len=list.length;for(;i<len;i++){if(list[i]===elem){return i}}return -1},booleans="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", // Regular expressions
	// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace="[\\x20\\t\\r\\n\\f]", // http://www.w3.org/TR/css3-syntax/#characters
	characterEncoding="(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+", // Loosely modeled on CSS identifier characters
	// An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors
	// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier=characterEncoding.replace("w","w#"), // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes="\\["+whitespace+"*("+characterEncoding+")(?:"+whitespace+ // Operator (capture 2)
	"*([*^$|!~]?=)"+whitespace+ // "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
	"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|("+identifier+"))|)"+whitespace+"*\\]",pseudos=":("+characterEncoding+")(?:\\(("+ // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
	// 1. quoted (capture 3; capture 4 or capture 5)
	"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|"+ // 2. simple (capture 6)
	"((?:\\\\.|[^\\\\()[\\]]|"+attributes+")*)|"+ // 3. anything else (capture 2)
	".*"+")\\)|)", // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace=new RegExp(whitespace+"+","g"),rtrim=new RegExp("^"+whitespace+"+|((?:^|[^\\\\])(?:\\\\.)*)"+whitespace+"+$","g"),rcomma=new RegExp("^"+whitespace+"*,"+whitespace+"*"),rcombinators=new RegExp("^"+whitespace+"*([>+~]|"+whitespace+")"+whitespace+"*"),rattributeQuotes=new RegExp("="+whitespace+"*([^\\]'\"]*?)"+whitespace+"*\\]","g"),rpseudo=new RegExp(pseudos),ridentifier=new RegExp("^"+identifier+"$"),matchExpr={"ID":new RegExp("^#("+characterEncoding+")"),"CLASS":new RegExp("^\\.("+characterEncoding+")"),"TAG":new RegExp("^("+characterEncoding.replace("w","w*")+")"),"ATTR":new RegExp("^"+attributes),"PSEUDO":new RegExp("^"+pseudos),"CHILD":new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+whitespace+"*(even|odd|(([+-]|)(\\d*)n|)"+whitespace+"*(?:([+-]|)"+whitespace+"*(\\d+)|))"+whitespace+"*\\)|)","i"),"bool":new RegExp("^(?:"+booleans+")$","i"), // For use in libraries implementing .is()
	// We use this for POS matching in `select`
	"needsContext":new RegExp("^"+whitespace+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+whitespace+"*((?:-\\d)?\\d*)"+whitespace+"*\\)|)(?=[^-]|$)","i")},rinputs=/^(?:input|select|textarea|button)$/i,rheader=/^h\d$/i,rnative=/^[^{]+\{\s*\[native \w/, // Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,rsibling=/[+~]/,rescape=/'|\\/g, // CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape=new RegExp("\\\\([\\da-f]{1,6}"+whitespace+"?|("+whitespace+")|.)","ig"),funescape=function(_,escaped,escapedWhitespace){var high="0x"+escaped-0x10000; // NaN means non-codepoint
	// Support: Firefox<24
	// Workaround erroneous numeric interpretation of +"0x"
	return high!==high||escapedWhitespace?escaped:high<0? // BMP codepoint
	String.fromCharCode(high+0x10000): // Supplemental Plane codepoint (surrogate pair)
	String.fromCharCode(high>>10|0xD800,high&0x3FF|0xDC00)}, // Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler=function(){setDocument()}; // Optimize for push.apply( _, NodeList )
	try{push.apply(arr=slice.call(preferredDoc.childNodes),preferredDoc.childNodes); // Support: Android<4.0
	// Detect silently failing push.apply
	arr[preferredDoc.childNodes.length].nodeType}catch(e) {push={apply:arr.length? // Leverage slice if possible
	function(target,els){push_native.apply(target,slice.call(els))}: // Support: IE<9
	// Otherwise append directly
	function(target,els){var j=target.length,i=0; // Can't trust NodeList.length
	while(target[j++]=els[i++]){}target.length=j-1}}}function Sizzle(selector,context,results,seed){var match,elem,m,nodeType, // QSA vars
	i,groups,old,nid,newContext,newSelector;if((context?context.ownerDocument||context:preferredDoc)!==document){setDocument(context)}context=context||document;results=results||[];nodeType=context.nodeType;if(typeof selector!=="string"||!selector||nodeType!==1&&nodeType!==9&&nodeType!==11){return results}if(!seed&&documentIsHTML){ // Try to shortcut find operations when possible (e.g., not under DocumentFragment)
	if(nodeType!==11&&(match=rquickExpr.exec(selector))){ // Speed-up: Sizzle("#ID")
	if(m=match[1]){if(nodeType===9){elem=context.getElementById(m); // Check parentNode to catch when Blackberry 4.6 returns
	// nodes that are no longer in the document (jQuery #6963)
	if(elem&&elem.parentNode){ // Handle the case where IE, Opera, and Webkit return items
	// by name instead of ID
	if(elem.id===m){results.push(elem);return results}}else {return results}}else { // Context is not a document
	if(context.ownerDocument&&(elem=context.ownerDocument.getElementById(m))&&contains(context,elem)&&elem.id===m){results.push(elem);return results}} // Speed-up: Sizzle("TAG")
	}else if(match[2]){push.apply(results,context.getElementsByTagName(selector));return results; // Speed-up: Sizzle(".CLASS")
	}else if((m=match[3])&&support.getElementsByClassName){push.apply(results,context.getElementsByClassName(m));return results}} // QSA path
	if(support.qsa&&(!rbuggyQSA||!rbuggyQSA.test(selector))){nid=old=expando;newContext=context;newSelector=nodeType!==1&&selector; // qSA works strangely on Element-rooted queries
	// We can work around this by specifying an extra ID on the root
	// and working up from there (Thanks to Andrew Dupont for the technique)
	// IE 8 doesn't work on object elements
	if(nodeType===1&&context.nodeName.toLowerCase()!=="object"){groups=tokenize(selector);if(old=context.getAttribute("id")){nid=old.replace(rescape,"\\$&")}else {context.setAttribute("id",nid)}nid="[id='"+nid+"'] ";i=groups.length;while(i--){groups[i]=nid+toSelector(groups[i])}newContext=rsibling.test(selector)&&testContext(context.parentNode)||context;newSelector=groups.join(",")}if(newSelector){try{push.apply(results,newContext.querySelectorAll(newSelector));return results}catch(qsaError) {}finally {if(!old){context.removeAttribute("id")}}}}} // All others
	return select(selector.replace(rtrim,"$1"),context,results,seed)} /**
	 * Create key-value caches of limited size
	 * @returns {Function(string, Object)} Returns the Object data after storing it on itself with
	 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
	 *	deleting the oldest entry
	 */function createCache(){var keys=[];function cache(key,value){ // Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
	if(keys.push(key+" ")>Expr.cacheLength){ // Only keep the most recent entries
	delete cache[keys.shift()]}return cache[key+" "]=value}return cache} /**
	 * Mark a function for special use by Sizzle
	 * @param {Function} fn The function to mark
	 */function markFunction(fn){fn[expando]=true;return fn} /**
	 * Support testing using an element
	 * @param {Function} fn Passed the created div and expects a boolean result
	 */function assert(fn){var div=document.createElement("div");try{return !!fn(div)}catch(e) {return false}finally { // Remove from its parent by default
	if(div.parentNode){div.parentNode.removeChild(div)} // release memory in IE
	div=null}} /**
	 * Adds the same handler for all of the specified attrs
	 * @param {String} attrs Pipe-separated list of attributes
	 * @param {Function} handler The method that will be applied
	 */function addHandle(attrs,handler){var arr=attrs.split("|"),i=attrs.length;while(i--){Expr.attrHandle[arr[i]]=handler}} /**
	 * Checks document order of two siblings
	 * @param {Element} a
	 * @param {Element} b
	 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
	 */function siblingCheck(a,b){var cur=b&&a,diff=cur&&a.nodeType===1&&b.nodeType===1&&(~b.sourceIndex||MAX_NEGATIVE)-(~a.sourceIndex||MAX_NEGATIVE); // Use IE sourceIndex if available on both nodes
	if(diff){return diff} // Check if b follows a
	if(cur){while(cur=cur.nextSibling){if(cur===b){return -1}}}return a?1:-1} /**
	 * Returns a function to use in pseudos for input types
	 * @param {String} type
	 */function createInputPseudo(type){return function(elem){var name=elem.nodeName.toLowerCase();return name==="input"&&elem.type===type}} /**
	 * Returns a function to use in pseudos for buttons
	 * @param {String} type
	 */function createButtonPseudo(type){return function(elem){var name=elem.nodeName.toLowerCase();return (name==="input"||name==="button")&&elem.type===type}} /**
	 * Returns a function to use in pseudos for positionals
	 * @param {Function} fn
	 */function createPositionalPseudo(fn){return markFunction(function(argument){argument=+argument;return markFunction(function(seed,matches){var j,matchIndexes=fn([],seed.length,argument),i=matchIndexes.length; // Match elements found at the specified indexes
	while(i--){if(seed[j=matchIndexes[i]]){seed[j]=!(matches[j]=seed[j])}}})})} /**
	 * Checks a node for validity as a Sizzle context
	 * @param {Element|Object=} context
	 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
	 */function testContext(context){return context&&typeof context.getElementsByTagName!=="undefined"&&context} // Expose support vars for convenience
	support=Sizzle.support={}; /**
	 * Detects XML nodes
	 * @param {Element|Object} elem An element or a document
	 * @returns {Boolean} True iff elem is a non-HTML XML node
	 */isXML=Sizzle.isXML=function(elem){ // documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement=elem&&(elem.ownerDocument||elem).documentElement;return documentElement?documentElement.nodeName!=="HTML":false}; /**
	 * Sets document-related variables once based on the current document
	 * @param {Element|Object} [doc] An element or document object to use to set the document
	 * @returns {Object} Returns the current document
	 */setDocument=Sizzle.setDocument=function(node){var hasCompare,parent,doc=node?node.ownerDocument||node:preferredDoc; // If no document and documentElement is available, return
	if(doc===document||doc.nodeType!==9||!doc.documentElement){return document} // Set our document
	document=doc;docElem=doc.documentElement;parent=doc.defaultView; // Support: IE>8
	// If iframe document is assigned to "document" variable and if iframe has been reloaded,
	// IE will throw "permission denied" error when accessing "document" variable, see jQuery #13936
	// IE6-8 do not support the defaultView property so parent will be undefined
	if(parent&&parent!==parent.top){ // IE11 does not have attachEvent, so all must suffer
	if(parent.addEventListener){parent.addEventListener("unload",unloadHandler,false)}else if(parent.attachEvent){parent.attachEvent("onunload",unloadHandler)}} /* Support tests
		---------------------------------------------------------------------- */documentIsHTML=!isXML(doc); /* Attributes
		---------------------------------------------------------------------- */ // Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes=assert(function(div){div.className="i";return !div.getAttribute("className")}); /* getElement(s)By*
		---------------------------------------------------------------------- */ // Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName=assert(function(div){div.appendChild(doc.createComment(""));return !div.getElementsByTagName("*").length}); // Support: IE<9
	support.getElementsByClassName=rnative.test(doc.getElementsByClassName); // Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programatically-set names,
	// so use a roundabout getElementsByName test
	support.getById=assert(function(div){docElem.appendChild(div).id=expando;return !doc.getElementsByName||!doc.getElementsByName(expando).length}); // ID find and filter
	if(support.getById){Expr.find["ID"]=function(id,context){if(typeof context.getElementById!=="undefined"&&documentIsHTML){var m=context.getElementById(id); // Check parentNode to catch when Blackberry 4.6 returns
	// nodes that are no longer in the document #6963
	return m&&m.parentNode?[m]:[]}};Expr.filter["ID"]=function(id){var attrId=id.replace(runescape,funescape);return function(elem){return elem.getAttribute("id")===attrId}}}else { // Support: IE6/7
	// getElementById is not reliable as a find shortcut
	delete Expr.find["ID"];Expr.filter["ID"]=function(id){var attrId=id.replace(runescape,funescape);return function(elem){var node=typeof elem.getAttributeNode!=="undefined"&&elem.getAttributeNode("id");return node&&node.value===attrId}}} // Tag
	Expr.find["TAG"]=support.getElementsByTagName?function(tag,context){if(typeof context.getElementsByTagName!=="undefined"){return context.getElementsByTagName(tag); // DocumentFragment nodes don't have gEBTN
	}else if(support.qsa){return context.querySelectorAll(tag)}}:function(tag,context){var elem,tmp=[],i=0, // By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
	results=context.getElementsByTagName(tag); // Filter out possible comments
	if(tag==="*"){while(elem=results[i++]){if(elem.nodeType===1){tmp.push(elem)}}return tmp}return results}; // Class
	Expr.find["CLASS"]=support.getElementsByClassName&&function(className,context){if(documentIsHTML){return context.getElementsByClassName(className)}}; /* QSA/matchesSelector
		---------------------------------------------------------------------- */ // QSA and matchesSelector support
	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches=[]; // qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See http://bugs.jquery.com/ticket/13378
	rbuggyQSA=[];if(support.qsa=rnative.test(doc.querySelectorAll)){ // Build QSA regex
	// Regex strategy adopted from Diego Perini
	assert(function(div){ // Select is set to empty string on purpose
	// This is to test IE's treatment of not explicitly
	// setting a boolean content attribute,
	// since its presence should be enough
	// http://bugs.jquery.com/ticket/12359
	docElem.appendChild(div).innerHTML="<a id='"+expando+"'></a>"+"<select id='"+expando+"-\f]' msallowcapture=''>"+"<option selected=''></option></select>"; // Support: IE8, Opera 11-12.16
	// Nothing should be selected when empty strings follow ^= or $= or *=
	// The test attribute must be unknown in Opera but "safe" for WinRT
	// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
	if(div.querySelectorAll("[msallowcapture^='']").length){rbuggyQSA.push("[*^$]="+whitespace+"*(?:''|\"\")")} // Support: IE8
	// Boolean attributes and "value" are not treated correctly
	if(!div.querySelectorAll("[selected]").length){rbuggyQSA.push("\\["+whitespace+"*(?:value|"+booleans+")")} // Support: Chrome<29, Android<4.2+, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.7+
	if(!div.querySelectorAll("[id~="+expando+"-]").length){rbuggyQSA.push("~=")} // Webkit/Opera - :checked should return selected option elements
	// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
	// IE8 throws error here and will not see later tests
	if(!div.querySelectorAll(":checked").length){rbuggyQSA.push(":checked")} // Support: Safari 8+, iOS 8+
	// https://bugs.webkit.org/show_bug.cgi?id=136851
	// In-page `selector#id sibing-combinator selector` fails
	if(!div.querySelectorAll("a#"+expando+"+*").length){rbuggyQSA.push(".#.+[+~]")}});assert(function(div){ // Support: Windows 8 Native Apps
	// The type and name attributes are restricted during .innerHTML assignment
	var input=doc.createElement("input");input.setAttribute("type","hidden");div.appendChild(input).setAttribute("name","D"); // Support: IE8
	// Enforce case-sensitivity of name attribute
	if(div.querySelectorAll("[name=d]").length){rbuggyQSA.push("name"+whitespace+"*[*^$|!~]?=")} // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
	// IE8 throws error here and will not see later tests
	if(!div.querySelectorAll(":enabled").length){rbuggyQSA.push(":enabled",":disabled")} // Opera 10-11 does not throw on post-comma invalid pseudos
	div.querySelectorAll("*,:x");rbuggyQSA.push(",.*:")})}if(support.matchesSelector=rnative.test(matches=docElem.matches||docElem.webkitMatchesSelector||docElem.mozMatchesSelector||docElem.oMatchesSelector||docElem.msMatchesSelector)){assert(function(div){ // Check to see if it's possible to do matchesSelector
	// on a disconnected node (IE 9)
	support.disconnectedMatch=matches.call(div,"div"); // This should fail with an exception
	// Gecko does not error, returns false instead
	matches.call(div,"[s!='']:x");rbuggyMatches.push("!=",pseudos)})}rbuggyQSA=rbuggyQSA.length&&new RegExp(rbuggyQSA.join("|"));rbuggyMatches=rbuggyMatches.length&&new RegExp(rbuggyMatches.join("|")); /* Contains
		---------------------------------------------------------------------- */hasCompare=rnative.test(docElem.compareDocumentPosition); // Element contains another
	// Purposefully does not implement inclusive descendent
	// As in, an element does not contain itself
	contains=hasCompare||rnative.test(docElem.contains)?function(a,b){var adown=a.nodeType===9?a.documentElement:a,bup=b&&b.parentNode;return a===bup||!!(bup&&bup.nodeType===1&&(adown.contains?adown.contains(bup):a.compareDocumentPosition&&a.compareDocumentPosition(bup)&16))}:function(a,b){if(b){while(b=b.parentNode){if(b===a){return true}}}return false}; /* Sorting
		---------------------------------------------------------------------- */ // Document order sorting
	sortOrder=hasCompare?function(a,b){ // Flag for duplicate removal
	if(a===b){hasDuplicate=true;return 0} // Sort on method existence if only one input has compareDocumentPosition
	var compare=!a.compareDocumentPosition-!b.compareDocumentPosition;if(compare){return compare} // Calculate position if both inputs belong to the same document
	compare=(a.ownerDocument||a)===(b.ownerDocument||b)?a.compareDocumentPosition(b): // Otherwise we know they are disconnected
	1; // Disconnected nodes
	if(compare&1||!support.sortDetached&&b.compareDocumentPosition(a)===compare){ // Choose the first element that is related to our preferred document
	if(a===doc||a.ownerDocument===preferredDoc&&contains(preferredDoc,a)){return -1}if(b===doc||b.ownerDocument===preferredDoc&&contains(preferredDoc,b)){return 1} // Maintain original order
	return sortInput?indexOf(sortInput,a)-indexOf(sortInput,b):0}return compare&4?-1:1}:function(a,b){ // Exit early if the nodes are identical
	if(a===b){hasDuplicate=true;return 0}var cur,i=0,aup=a.parentNode,bup=b.parentNode,ap=[a],bp=[b]; // Parentless nodes are either documents or disconnected
	if(!aup||!bup){return a===doc?-1:b===doc?1:aup?-1:bup?1:sortInput?indexOf(sortInput,a)-indexOf(sortInput,b):0; // If the nodes are siblings, we can do a quick check
	}else if(aup===bup){return siblingCheck(a,b)} // Otherwise we need full lists of their ancestors for comparison
	cur=a;while(cur=cur.parentNode){ap.unshift(cur)}cur=b;while(cur=cur.parentNode){bp.unshift(cur)} // Walk down the tree looking for a discrepancy
	while(ap[i]===bp[i]){i++}return i? // Do a sibling check if the nodes have a common ancestor
	siblingCheck(ap[i],bp[i]): // Otherwise nodes in our document sort first
	ap[i]===preferredDoc?-1:bp[i]===preferredDoc?1:0};return doc};Sizzle.matches=function(expr,elements){return Sizzle(expr,null,null,elements)};Sizzle.matchesSelector=function(elem,expr){ // Set document vars if needed
	if((elem.ownerDocument||elem)!==document){setDocument(elem)} // Make sure that attribute selectors are quoted
	expr=expr.replace(rattributeQuotes,"='$1']");if(support.matchesSelector&&documentIsHTML&&(!rbuggyMatches||!rbuggyMatches.test(expr))&&(!rbuggyQSA||!rbuggyQSA.test(expr))){try{var ret=matches.call(elem,expr); // IE 9's matchesSelector returns false on disconnected nodes
	if(ret||support.disconnectedMatch|| // As well, disconnected nodes are said to be in a document
	// fragment in IE 9
	elem.document&&elem.document.nodeType!==11){return ret}}catch(e) {}}return Sizzle(expr,document,null,[elem]).length>0};Sizzle.contains=function(context,elem){ // Set document vars if needed
	if((context.ownerDocument||context)!==document){setDocument(context)}return contains(context,elem)};Sizzle.attr=function(elem,name){ // Set document vars if needed
	if((elem.ownerDocument||elem)!==document){setDocument(elem)}var fn=Expr.attrHandle[name.toLowerCase()], // Don't get fooled by Object.prototype properties (jQuery #13807)
	val=fn&&hasOwn.call(Expr.attrHandle,name.toLowerCase())?fn(elem,name,!documentIsHTML):undefined;return val!==undefined?val:support.attributes||!documentIsHTML?elem.getAttribute(name):(val=elem.getAttributeNode(name))&&val.specified?val.value:null};Sizzle.error=function(msg){throw new Error("Syntax error, unrecognized expression: "+msg)}; /**
	 * Document sorting and removing duplicates
	 * @param {ArrayLike} results
	 */Sizzle.uniqueSort=function(results){var elem,duplicates=[],j=0,i=0; // Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate=!support.detectDuplicates;sortInput=!support.sortStable&&results.slice(0);results.sort(sortOrder);if(hasDuplicate){while(elem=results[i++]){if(elem===results[i]){j=duplicates.push(i)}}while(j--){results.splice(duplicates[j],1)}} // Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput=null;return results}; /**
	 * Utility function for retrieving the text value of an array of DOM nodes
	 * @param {Array|Element} elem
	 */getText=Sizzle.getText=function(elem){var node,ret="",i=0,nodeType=elem.nodeType;if(!nodeType){ // If no nodeType, this is expected to be an array
	while(node=elem[i++]){ // Do not traverse comment nodes
	ret+=getText(node)}}else if(nodeType===1||nodeType===9||nodeType===11){ // Use textContent for elements
	// innerText usage removed for consistency of new lines (jQuery #11153)
	if(typeof elem.textContent==="string"){return elem.textContent}else { // Traverse its children
	for(elem=elem.firstChild;elem;elem=elem.nextSibling){ret+=getText(elem)}}}else if(nodeType===3||nodeType===4){return elem.nodeValue} // Do not include comment or processing instruction nodes
	return ret};Expr=Sizzle.selectors={ // Can be adjusted by the user
	cacheLength:50,createPseudo:markFunction,match:matchExpr,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:true}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:true},"~":{dir:"previousSibling"}},preFilter:{"ATTR":function(match){match[1]=match[1].replace(runescape,funescape); // Move the given value to match[3] whether quoted or unquoted
	match[3]=(match[3]||match[4]||match[5]||"").replace(runescape,funescape);if(match[2]==="~="){match[3]=" "+match[3]+" "}return match.slice(0,4)},"CHILD":function(match){ /* matches from matchExpr["CHILD"]
					1 type (only|nth|...)
					2 what (child|of-type)
					3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
					4 xn-component of xn+y argument ([+-]?\d*n|)
					5 sign of xn-component
					6 x of xn-component
					7 sign of y-component
					8 y of y-component
				*/match[1]=match[1].toLowerCase();if(match[1].slice(0,3)==="nth"){ // nth-* requires argument
	if(!match[3]){Sizzle.error(match[0])} // numeric x and y parameters for Expr.filter.CHILD
	// remember that false/true cast respectively to 0/1
	match[4]=+(match[4]?match[5]+(match[6]||1):2*(match[3]==="even"||match[3]==="odd"));match[5]=+(match[7]+match[8]||match[3]==="odd"); // other types prohibit arguments
	}else if(match[3]){Sizzle.error(match[0])}return match},"PSEUDO":function(match){var excess,unquoted=!match[6]&&match[2];if(matchExpr["CHILD"].test(match[0])){return null} // Accept quoted arguments as-is
	if(match[3]){match[2]=match[4]||match[5]||""; // Strip excess characters from unquoted arguments
	}else if(unquoted&&rpseudo.test(unquoted)&&( // Get excess from tokenize (recursively)
	excess=tokenize(unquoted,true))&&( // advance to the next closing parenthesis
	excess=unquoted.indexOf(")",unquoted.length-excess)-unquoted.length)){ // excess is a negative index
	match[0]=match[0].slice(0,excess);match[2]=unquoted.slice(0,excess)} // Return only captures needed by the pseudo filter method (type and argument)
	return match.slice(0,3)}},filter:{"TAG":function(nodeNameSelector){var nodeName=nodeNameSelector.replace(runescape,funescape).toLowerCase();return nodeNameSelector==="*"?function(){return true}:function(elem){return elem.nodeName&&elem.nodeName.toLowerCase()===nodeName}},"CLASS":function(className){var pattern=classCache[className+" "];return pattern||(pattern=new RegExp("(^|"+whitespace+")"+className+"("+whitespace+"|$)"))&&classCache(className,function(elem){return pattern.test(typeof elem.className==="string"&&elem.className||typeof elem.getAttribute!=="undefined"&&elem.getAttribute("class")||"")})},"ATTR":function(name,operator,check){return function(elem){var result=Sizzle.attr(elem,name);if(result==null){return operator==="!="}if(!operator){return true}result+="";return operator==="="?result===check:operator==="!="?result!==check:operator==="^="?check&&result.indexOf(check)===0:operator==="*="?check&&result.indexOf(check)>-1:operator==="$="?check&&result.slice(-check.length)===check:operator==="~="?(" "+result.replace(rwhitespace," ")+" ").indexOf(check)>-1:operator==="|="?result===check||result.slice(0,check.length+1)===check+"-":false}},"CHILD":function(type,what,argument,first,last){var simple=type.slice(0,3)!=="nth",forward=type.slice(-4)!=="last",ofType=what==="of-type";return first===1&&last===0? // Shortcut for :nth-*(n)
	function(elem){return !!elem.parentNode}:function(elem,context,xml){var cache,outerCache,node,diff,nodeIndex,start,dir=simple!==forward?"nextSibling":"previousSibling",parent=elem.parentNode,name=ofType&&elem.nodeName.toLowerCase(),useCache=!xml&&!ofType;if(parent){ // :(first|last|only)-(child|of-type)
	if(simple){while(dir){node=elem;while(node=node[dir]){if(ofType?node.nodeName.toLowerCase()===name:node.nodeType===1){return false}} // Reverse direction for :only-* (if we haven't yet done so)
	start=dir=type==="only"&&!start&&"nextSibling"}return true}start=[forward?parent.firstChild:parent.lastChild]; // non-xml :nth-child(...) stores cache data on `parent`
	if(forward&&useCache){ // Seek `elem` from a previously-cached index
	outerCache=parent[expando]||(parent[expando]={});cache=outerCache[type]||[];nodeIndex=cache[0]===dirruns&&cache[1];diff=cache[0]===dirruns&&cache[2];node=nodeIndex&&parent.childNodes[nodeIndex];while(node=++nodeIndex&&node&&node[dir]||( // Fallback to seeking `elem` from the start
	diff=nodeIndex=0)||start.pop()){ // When found, cache indexes on `parent` and break
	if(node.nodeType===1&&++diff&&node===elem){outerCache[type]=[dirruns,nodeIndex,diff];break}} // Use previously-cached element index if available
	}else if(useCache&&(cache=(elem[expando]||(elem[expando]={}))[type])&&cache[0]===dirruns){diff=cache[1]; // xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)
	}else { // Use the same loop as above to seek `elem` from the start
	while(node=++nodeIndex&&node&&node[dir]||(diff=nodeIndex=0)||start.pop()){if((ofType?node.nodeName.toLowerCase()===name:node.nodeType===1)&&++diff){ // Cache the index of each encountered element
	if(useCache){(node[expando]||(node[expando]={}))[type]=[dirruns,diff]}if(node===elem){break}}}} // Incorporate the offset, then check against cycle size
	diff-=last;return diff===first||diff%first===0&&diff/first>=0}}},"PSEUDO":function(pseudo,argument){ // pseudo-class names are case-insensitive
	// http://www.w3.org/TR/selectors/#pseudo-classes
	// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
	// Remember that setFilters inherits from pseudos
	var args,fn=Expr.pseudos[pseudo]||Expr.setFilters[pseudo.toLowerCase()]||Sizzle.error("unsupported pseudo: "+pseudo); // The user may use createPseudo to indicate that
	// arguments are needed to create the filter function
	// just as Sizzle does
	if(fn[expando]){return fn(argument)} // But maintain support for old signatures
	if(fn.length>1){args=[pseudo,pseudo,"",argument];return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase())?markFunction(function(seed,matches){var idx,matched=fn(seed,argument),i=matched.length;while(i--){idx=indexOf(seed,matched[i]);seed[idx]=!(matches[idx]=matched[i])}}):function(elem){return fn(elem,0,args)}}return fn}},pseudos:{ // Potentially complex pseudos
	"not":markFunction(function(selector){ // Trim the selector passed to compile
	// to avoid treating leading and trailing
	// spaces as combinators
	var input=[],results=[],matcher=compile(selector.replace(rtrim,"$1"));return matcher[expando]?markFunction(function(seed,matches,context,xml){var elem,unmatched=matcher(seed,null,xml,[]),i=seed.length; // Match elements unmatched by `matcher`
	while(i--){if(elem=unmatched[i]){seed[i]=!(matches[i]=elem)}}}):function(elem,context,xml){input[0]=elem;matcher(input,null,xml,results); // Don't keep the element (issue #299)
	input[0]=null;return !results.pop()}}),"has":markFunction(function(selector){return function(elem){return Sizzle(selector,elem).length>0}}),"contains":markFunction(function(text){text=text.replace(runescape,funescape);return function(elem){return (elem.textContent||elem.innerText||getText(elem)).indexOf(text)>-1}}), // "Whether an element is represented by a :lang() selector
	// is based solely on the element's language value
	// being equal to the identifier C,
	// or beginning with the identifier C immediately followed by "-".
	// The matching of C against the element's language value is performed case-insensitively.
	// The identifier C does not have to be a valid language name."
	// http://www.w3.org/TR/selectors/#lang-pseudo
	"lang":markFunction(function(lang){ // lang value must be a valid identifier
	if(!ridentifier.test(lang||"")){Sizzle.error("unsupported lang: "+lang)}lang=lang.replace(runescape,funescape).toLowerCase();return function(elem){var elemLang;do {if(elemLang=documentIsHTML?elem.lang:elem.getAttribute("xml:lang")||elem.getAttribute("lang")){elemLang=elemLang.toLowerCase();return elemLang===lang||elemLang.indexOf(lang+"-")===0}}while((elem=elem.parentNode)&&elem.nodeType===1);return false}}), // Miscellaneous
	"target":function(elem){var hash=window.location&&window.location.hash;return hash&&hash.slice(1)===elem.id},"root":function(elem){return elem===docElem},"focus":function(elem){return elem===document.activeElement&&(!document.hasFocus||document.hasFocus())&&!!(elem.type||elem.href||~elem.tabIndex)}, // Boolean properties
	"enabled":function(elem){return elem.disabled===false},"disabled":function(elem){return elem.disabled===true},"checked":function(elem){ // In CSS3, :checked should return both checked and selected elements
	// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
	var nodeName=elem.nodeName.toLowerCase();return nodeName==="input"&&!!elem.checked||nodeName==="option"&&!!elem.selected},"selected":function(elem){ // Accessing this property makes selected-by-default
	// options in Safari work properly
	if(elem.parentNode){elem.parentNode.selectedIndex}return elem.selected===true}, // Contents
	"empty":function(elem){ // http://www.w3.org/TR/selectors/#empty-pseudo
	// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
	//   but not by others (comment: 8; processing instruction: 7; etc.)
	// nodeType < 6 works because attributes (2) do not appear as children
	for(elem=elem.firstChild;elem;elem=elem.nextSibling){if(elem.nodeType<6){return false}}return true},"parent":function(elem){return !Expr.pseudos["empty"](elem)}, // Element/input types
	"header":function(elem){return rheader.test(elem.nodeName)},"input":function(elem){return rinputs.test(elem.nodeName)},"button":function(elem){var name=elem.nodeName.toLowerCase();return name==="input"&&elem.type==="button"||name==="button"},"text":function(elem){var attr;return elem.nodeName.toLowerCase()==="input"&&elem.type==="text"&&( // Support: IE<8
	// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
	(attr=elem.getAttribute("type"))==null||attr.toLowerCase()==="text")}, // Position-in-collection
	"first":createPositionalPseudo(function(){return [0]}),"last":createPositionalPseudo(function(matchIndexes,length){return [length-1]}),"eq":createPositionalPseudo(function(matchIndexes,length,argument){return [argument<0?argument+length:argument]}),"even":createPositionalPseudo(function(matchIndexes,length){var i=0;for(;i<length;i+=2){matchIndexes.push(i)}return matchIndexes}),"odd":createPositionalPseudo(function(matchIndexes,length){var i=1;for(;i<length;i+=2){matchIndexes.push(i)}return matchIndexes}),"lt":createPositionalPseudo(function(matchIndexes,length,argument){var i=argument<0?argument+length:argument;for(;--i>=0;){matchIndexes.push(i)}return matchIndexes}),"gt":createPositionalPseudo(function(matchIndexes,length,argument){var i=argument<0?argument+length:argument;for(;++i<length;){matchIndexes.push(i)}return matchIndexes})}};Expr.pseudos["nth"]=Expr.pseudos["eq"]; // Add button/input type pseudos
	for(i in {radio:true,checkbox:true,file:true,password:true,image:true}){Expr.pseudos[i]=createInputPseudo(i)}for(i in {submit:true,reset:true}){Expr.pseudos[i]=createButtonPseudo(i)} // Easy API for creating new setFilters
	function setFilters(){}setFilters.prototype=Expr.filters=Expr.pseudos;Expr.setFilters=new setFilters;tokenize=Sizzle.tokenize=function(selector,parseOnly){var matched,match,tokens,type,soFar,groups,preFilters,cached=tokenCache[selector+" "];if(cached){return parseOnly?0:cached.slice(0)}soFar=selector;groups=[];preFilters=Expr.preFilter;while(soFar){ // Comma and first run
	if(!matched||(match=rcomma.exec(soFar))){if(match){ // Don't consume trailing commas as valid
	soFar=soFar.slice(match[0].length)||soFar}groups.push(tokens=[])}matched=false; // Combinators
	if(match=rcombinators.exec(soFar)){matched=match.shift();tokens.push({value:matched, // Cast descendant combinators to space
	type:match[0].replace(rtrim," ")});soFar=soFar.slice(matched.length)} // Filters
	for(type in Expr.filter){if((match=matchExpr[type].exec(soFar))&&(!preFilters[type]||(match=preFilters[type](match)))){matched=match.shift();tokens.push({value:matched,type:type,matches:match});soFar=soFar.slice(matched.length)}}if(!matched){break}} // Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly?soFar.length:soFar?Sizzle.error(selector): // Cache the tokens
	tokenCache(selector,groups).slice(0)};function toSelector(tokens){var i=0,len=tokens.length,selector="";for(;i<len;i++){selector+=tokens[i].value}return selector}function addCombinator(matcher,combinator,base){var dir=combinator.dir,checkNonElements=base&&dir==="parentNode",doneName=done++;return combinator.first? // Check against closest ancestor/preceding element
	function(elem,context,xml){while(elem=elem[dir]){if(elem.nodeType===1||checkNonElements){return matcher(elem,context,xml)}}}: // Check against all ancestor/preceding elements
	function(elem,context,xml){var oldCache,outerCache,newCache=[dirruns,doneName]; // We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
	if(xml){while(elem=elem[dir]){if(elem.nodeType===1||checkNonElements){if(matcher(elem,context,xml)){return true}}}}else {while(elem=elem[dir]){if(elem.nodeType===1||checkNonElements){outerCache=elem[expando]||(elem[expando]={});if((oldCache=outerCache[dir])&&oldCache[0]===dirruns&&oldCache[1]===doneName){ // Assign to newCache so results back-propagate to previous elements
	return newCache[2]=oldCache[2]}else { // Reuse newcache so results back-propagate to previous elements
	outerCache[dir]=newCache; // A match means we're done; a fail means we have to keep checking
	if(newCache[2]=matcher(elem,context,xml)){return true}}}}}}}function elementMatcher(matchers){return matchers.length>1?function(elem,context,xml){var i=matchers.length;while(i--){if(!matchers[i](elem,context,xml)){return false}}return true}:matchers[0]}function multipleContexts(selector,contexts,results){var i=0,len=contexts.length;for(;i<len;i++){Sizzle(selector,contexts[i],results)}return results}function condense(unmatched,map,filter,context,xml){var elem,newUnmatched=[],i=0,len=unmatched.length,mapped=map!=null;for(;i<len;i++){if(elem=unmatched[i]){if(!filter||filter(elem,context,xml)){newUnmatched.push(elem);if(mapped){map.push(i)}}}}return newUnmatched}function setMatcher(preFilter,selector,matcher,postFilter,postFinder,postSelector){if(postFilter&&!postFilter[expando]){postFilter=setMatcher(postFilter)}if(postFinder&&!postFinder[expando]){postFinder=setMatcher(postFinder,postSelector)}return markFunction(function(seed,results,context,xml){var temp,i,elem,preMap=[],postMap=[],preexisting=results.length, // Get initial elements from seed or context
	elems=seed||multipleContexts(selector||"*",context.nodeType?[context]:context,[]), // Prefilter to get matcher input, preserving a map for seed-results synchronization
	matcherIn=preFilter&&(seed||!selector)?condense(elems,preMap,preFilter,context,xml):elems,matcherOut=matcher? // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
	postFinder||(seed?preFilter:preexisting||postFilter)? // ...intermediate processing is necessary
	[]: // ...otherwise use results directly
	results:matcherIn; // Find primary matches
	if(matcher){matcher(matcherIn,matcherOut,context,xml)} // Apply postFilter
	if(postFilter){temp=condense(matcherOut,postMap);postFilter(temp,[],context,xml); // Un-match failing elements by moving them back to matcherIn
	i=temp.length;while(i--){if(elem=temp[i]){matcherOut[postMap[i]]=!(matcherIn[postMap[i]]=elem)}}}if(seed){if(postFinder||preFilter){if(postFinder){ // Get the final matcherOut by condensing this intermediate into postFinder contexts
	temp=[];i=matcherOut.length;while(i--){if(elem=matcherOut[i]){ // Restore matcherIn since elem is not yet a final match
	temp.push(matcherIn[i]=elem)}}postFinder(null,matcherOut=[],temp,xml)} // Move matched elements from seed to results to keep them synchronized
	i=matcherOut.length;while(i--){if((elem=matcherOut[i])&&(temp=postFinder?indexOf(seed,elem):preMap[i])>-1){seed[temp]=!(results[temp]=elem)}}} // Add elements to results, through postFinder if defined
	}else {matcherOut=condense(matcherOut===results?matcherOut.splice(preexisting,matcherOut.length):matcherOut);if(postFinder){postFinder(null,results,matcherOut,xml)}else {push.apply(results,matcherOut)}}})}function matcherFromTokens(tokens){var checkContext,matcher,j,len=tokens.length,leadingRelative=Expr.relative[tokens[0].type],implicitRelative=leadingRelative||Expr.relative[" "],i=leadingRelative?1:0, // The foundational matcher ensures that elements are reachable from top-level context(s)
	matchContext=addCombinator(function(elem){return elem===checkContext},implicitRelative,true),matchAnyContext=addCombinator(function(elem){return indexOf(checkContext,elem)>-1},implicitRelative,true),matchers=[function(elem,context,xml){var ret=!leadingRelative&&(xml||context!==outermostContext)||((checkContext=context).nodeType?matchContext(elem,context,xml):matchAnyContext(elem,context,xml)); // Avoid hanging onto element (issue #299)
	checkContext=null;return ret}];for(;i<len;i++){if(matcher=Expr.relative[tokens[i].type]){matchers=[addCombinator(elementMatcher(matchers),matcher)]}else {matcher=Expr.filter[tokens[i].type].apply(null,tokens[i].matches); // Return special upon seeing a positional matcher
	if(matcher[expando]){ // Find the next relative operator (if any) for proper handling
	j=++i;for(;j<len;j++){if(Expr.relative[tokens[j].type]){break}}return setMatcher(i>1&&elementMatcher(matchers),i>1&&toSelector( // If the preceding token was a descendant combinator, insert an implicit any-element `*`
	tokens.slice(0,i-1).concat({value:tokens[i-2].type===" "?"*":""})).replace(rtrim,"$1"),matcher,i<j&&matcherFromTokens(tokens.slice(i,j)),j<len&&matcherFromTokens(tokens=tokens.slice(j)),j<len&&toSelector(tokens))}matchers.push(matcher)}}return elementMatcher(matchers)}function matcherFromGroupMatchers(elementMatchers,setMatchers){var bySet=setMatchers.length>0,byElement=elementMatchers.length>0,superMatcher=function(seed,context,xml,results,outermost){var elem,j,matcher,matchedCount=0,i="0",unmatched=seed&&[],setMatched=[],contextBackup=outermostContext, // We must always have either seed elements or outermost context
	elems=seed||byElement&&Expr.find["TAG"]("*",outermost), // Use integer dirruns iff this is the outermost matcher
	dirrunsUnique=dirruns+=contextBackup==null?1:Math.random()||0.1,len=elems.length;if(outermost){outermostContext=context!==document&&context} // Add elements passing elementMatchers directly to results
	// Keep `i` a string if there are no elements so `matchedCount` will be "00" below
	// Support: IE<9, Safari
	// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
	for(;i!==len&&(elem=elems[i])!=null;i++){if(byElement&&elem){j=0;while(matcher=elementMatchers[j++]){if(matcher(elem,context,xml)){results.push(elem);break}}if(outermost){dirruns=dirrunsUnique}} // Track unmatched elements for set filters
	if(bySet){ // They will have gone through all possible matchers
	if(elem=!matcher&&elem){matchedCount--} // Lengthen the array for every element, matched or not
	if(seed){unmatched.push(elem)}}} // Apply set filters to unmatched elements
	matchedCount+=i;if(bySet&&i!==matchedCount){j=0;while(matcher=setMatchers[j++]){matcher(unmatched,setMatched,context,xml)}if(seed){ // Reintegrate element matches to eliminate the need for sorting
	if(matchedCount>0){while(i--){if(!(unmatched[i]||setMatched[i])){setMatched[i]=pop.call(results)}}} // Discard index placeholder values to get only actual matches
	setMatched=condense(setMatched)} // Add matches to results
	push.apply(results,setMatched); // Seedless set matches succeeding multiple successful matchers stipulate sorting
	if(outermost&&!seed&&setMatched.length>0&&matchedCount+setMatchers.length>1){Sizzle.uniqueSort(results)}} // Override manipulation of globals by nested matchers
	if(outermost){dirruns=dirrunsUnique;outermostContext=contextBackup}return unmatched};return bySet?markFunction(superMatcher):superMatcher}compile=Sizzle.compile=function(selector,match /* Internal Use Only */){var i,setMatchers=[],elementMatchers=[],cached=compilerCache[selector+" "];if(!cached){ // Generate a function of recursive functions that can be used to check each element
	if(!match){match=tokenize(selector)}i=match.length;while(i--){cached=matcherFromTokens(match[i]);if(cached[expando]){setMatchers.push(cached)}else {elementMatchers.push(cached)}} // Cache the compiled function
	cached=compilerCache(selector,matcherFromGroupMatchers(elementMatchers,setMatchers)); // Save selector and tokenization
	cached.selector=selector}return cached}; /**
	 * A low-level selection function that works with Sizzle's compiled
	 *  selector functions
	 * @param {String|Function} selector A selector or a pre-compiled
	 *  selector function built with Sizzle.compile
	 * @param {Element} context
	 * @param {Array} [results]
	 * @param {Array} [seed] A set of elements to match against
	 */select=Sizzle.select=function(selector,context,results,seed){var i,tokens,token,type,find,compiled=typeof selector==="function"&&selector,match=!seed&&tokenize(selector=compiled.selector||selector);results=results||[]; // Try to minimize operations if there is no seed and only one group
	if(match.length===1){ // Take a shortcut and set the context if the root selector is an ID
	tokens=match[0]=match[0].slice(0);if(tokens.length>2&&(token=tokens[0]).type==="ID"&&support.getById&&context.nodeType===9&&documentIsHTML&&Expr.relative[tokens[1].type]){context=(Expr.find["ID"](token.matches[0].replace(runescape,funescape),context)||[])[0];if(!context){return results; // Precompiled matchers will still verify ancestry, so step up a level
	}else if(compiled){context=context.parentNode}selector=selector.slice(tokens.shift().value.length)} // Fetch a seed set for right-to-left matching
	i=matchExpr["needsContext"].test(selector)?0:tokens.length;while(i--){token=tokens[i]; // Abort if we hit a combinator
	if(Expr.relative[type=token.type]){break}if(find=Expr.find[type]){ // Search, expanding context for leading sibling combinators
	if(seed=find(token.matches[0].replace(runescape,funescape),rsibling.test(tokens[0].type)&&testContext(context.parentNode)||context)){ // If seed is empty or no tokens remain, we can return early
	tokens.splice(i,1);selector=seed.length&&toSelector(tokens);if(!selector){push.apply(results,seed);return results}break}}}} // Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	(compiled||compile(selector,match))(seed,context,!documentIsHTML,results,rsibling.test(selector)&&testContext(context.parentNode)||context);return results}; // One-time assignments
	// Sort stability
	support.sortStable=expando.split("").sort(sortOrder).join("")===expando; // Support: Chrome 14-35+
	// Always assume duplicates if they aren't passed to the comparison function
	support.detectDuplicates=!!hasDuplicate; // Initialize against the default document
	setDocument(); // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
	// Detached nodes confoundingly follow *each other*
	support.sortDetached=assert(function(div1){ // Should return 1, but returns 4 (following)
	return div1.compareDocumentPosition(document.createElement("div"))&1}); // Support: IE<8
	// Prevent attribute/property "interpolation"
	// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
	if(!assert(function(div){div.innerHTML="<a href='#'></a>";return div.firstChild.getAttribute("href")==="#"})){addHandle("type|href|height|width",function(elem,name,isXML){if(!isXML){return elem.getAttribute(name,name.toLowerCase()==="type"?1:2)}})} // Support: IE<9
	// Use defaultValue in place of getAttribute("value")
	if(!support.attributes||!assert(function(div){div.innerHTML="<input/>";div.firstChild.setAttribute("value","");return div.firstChild.getAttribute("value")===""})){addHandle("value",function(elem,name,isXML){if(!isXML&&elem.nodeName.toLowerCase()==="input"){return elem.defaultValue}})} // Support: IE<9
	// Use getAttributeNode to fetch booleans when getAttribute lies
	if(!assert(function(div){return div.getAttribute("disabled")==null})){addHandle(booleans,function(elem,name,isXML){var val;if(!isXML){return elem[name]===true?name.toLowerCase():(val=elem.getAttributeNode(name))&&val.specified?val.value:null}})}return Sizzle})(window);jQuery.find=Sizzle;jQuery.expr=Sizzle.selectors;jQuery.expr[":"]=jQuery.expr.pseudos;jQuery.unique=Sizzle.uniqueSort;jQuery.text=Sizzle.getText;jQuery.isXMLDoc=Sizzle.isXML;jQuery.contains=Sizzle.contains;var rneedsContext=jQuery.expr.match.needsContext;var rsingleTag=/^<(\w+)\s*\/?>(?:<\/\1>|)$/;var risSimple=/^.[^:#\[\.,]*$/; // Implement the identical functionality for filter and not
	function winnow(elements,qualifier,not){if(jQuery.isFunction(qualifier)){return jQuery.grep(elements,function(elem,i){ /* jshint -W018 */return !!qualifier.call(elem,i,elem)!==not})}if(qualifier.nodeType){return jQuery.grep(elements,function(elem){return elem===qualifier!==not})}if(typeof qualifier==="string"){if(risSimple.test(qualifier)){return jQuery.filter(qualifier,elements,not)}qualifier=jQuery.filter(qualifier,elements)}return jQuery.grep(elements,function(elem){return indexOf.call(qualifier,elem)>=0!==not})}jQuery.filter=function(expr,elems,not){var elem=elems[0];if(not){expr=":not("+expr+")"}return elems.length===1&&elem.nodeType===1?jQuery.find.matchesSelector(elem,expr)?[elem]:[]:jQuery.find.matches(expr,jQuery.grep(elems,function(elem){return elem.nodeType===1}))};jQuery.fn.extend({find:function(selector){var i,len=this.length,ret=[],self=this;if(typeof selector!=="string"){return this.pushStack(jQuery(selector).filter(function(){for(i=0;i<len;i++){if(jQuery.contains(self[i],this)){return true}}}))}for(i=0;i<len;i++){jQuery.find(selector,self[i],ret)} // Needed because $( selector, context ) becomes $( context ).find( selector )
	ret=this.pushStack(len>1?jQuery.unique(ret):ret);ret.selector=this.selector?this.selector+" "+selector:selector;return ret},filter:function(selector){return this.pushStack(winnow(this,selector||[],false))},not:function(selector){return this.pushStack(winnow(this,selector||[],true))},is:function(selector){return !!winnow(this, // If this is a positional/relative selector, check membership in the returned set
	// so $("p:first").is("p:last") won't return true for a doc with two "p".
	typeof selector==="string"&&rneedsContext.test(selector)?jQuery(selector):selector||[],false).length}}); // Initialize a jQuery object
	// A central reference to the root jQuery(document)
	var rootjQuery, // A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	rquickExpr=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,init=jQuery.fn.init=function(selector,context){var match,elem; // HANDLE: $(""), $(null), $(undefined), $(false)
	if(!selector){return this} // Handle HTML strings
	if(typeof selector==="string"){if(selector[0]==="<"&&selector[selector.length-1]===">"&&selector.length>=3){ // Assume that strings that start and end with <> are HTML and skip the regex check
	match=[null,selector,null]}else {match=rquickExpr.exec(selector)} // Match html or make sure no context is specified for #id
	if(match&&(match[1]||!context)){ // HANDLE: $(html) -> $(array)
	if(match[1]){context=context instanceof jQuery?context[0]:context; // Option to run scripts is true for back-compat
	// Intentionally let the error be thrown if parseHTML is not present
	jQuery.merge(this,jQuery.parseHTML(match[1],context&&context.nodeType?context.ownerDocument||context:document,true)); // HANDLE: $(html, props)
	if(rsingleTag.test(match[1])&&jQuery.isPlainObject(context)){for(match in context){ // Properties of context are called as methods if possible
	if(jQuery.isFunction(this[match])){this[match](context[match]); // ...and otherwise set as attributes
	}else {this.attr(match,context[match])}}}return this; // HANDLE: $(#id)
	}else {elem=document.getElementById(match[2]); // Support: Blackberry 4.6
	// gEBID returns nodes no longer in the document (#6963)
	if(elem&&elem.parentNode){ // Inject the element directly into the jQuery object
	this.length=1;this[0]=elem}this.context=document;this.selector=selector;return this} // HANDLE: $(expr, $(...))
	}else if(!context||context.jquery){return (context||rootjQuery).find(selector); // HANDLE: $(expr, context)
	// (which is just equivalent to: $(context).find(expr)
	}else {return this.constructor(context).find(selector)} // HANDLE: $(DOMElement)
	}else if(selector.nodeType){this.context=this[0]=selector;this.length=1;return this; // HANDLE: $(function)
	// Shortcut for document ready
	}else if(jQuery.isFunction(selector)){return typeof rootjQuery.ready!=="undefined"?rootjQuery.ready(selector): // Execute immediately if ready is not present
	selector(jQuery)}if(selector.selector!==undefined){this.selector=selector.selector;this.context=selector.context}return jQuery.makeArray(selector,this)}; // Give the init function the jQuery prototype for later instantiation
	init.prototype=jQuery.fn; // Initialize central reference
	rootjQuery=jQuery(document);var rparentsprev=/^(?:parents|prev(?:Until|All))/, // Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique={children:true,contents:true,next:true,prev:true};jQuery.extend({dir:function(elem,dir,until){var matched=[],truncate=until!==undefined;while((elem=elem[dir])&&elem.nodeType!==9){if(elem.nodeType===1){if(truncate&&jQuery(elem).is(until)){break}matched.push(elem)}}return matched},sibling:function(n,elem){var matched=[];for(;n;n=n.nextSibling){if(n.nodeType===1&&n!==elem){matched.push(n)}}return matched}});jQuery.fn.extend({has:function(target){var targets=jQuery(target,this),l=targets.length;return this.filter(function(){var i=0;for(;i<l;i++){if(jQuery.contains(this,targets[i])){return true}}})},closest:function(selectors,context){var cur,i=0,l=this.length,matched=[],pos=rneedsContext.test(selectors)||typeof selectors!=="string"?jQuery(selectors,context||this.context):0;for(;i<l;i++){for(cur=this[i];cur&&cur!==context;cur=cur.parentNode){ // Always skip document fragments
	if(cur.nodeType<11&&(pos?pos.index(cur)>-1: // Don't pass non-elements to Sizzle
	cur.nodeType===1&&jQuery.find.matchesSelector(cur,selectors))){matched.push(cur);break}}}return this.pushStack(matched.length>1?jQuery.unique(matched):matched)}, // Determine the position of an element within the set
	index:function(elem){ // No argument, return index in parent
	if(!elem){return this[0]&&this[0].parentNode?this.first().prevAll().length:-1} // Index in selector
	if(typeof elem==="string"){return indexOf.call(jQuery(elem),this[0])} // Locate the position of the desired element
	return indexOf.call(this, // If it receives a jQuery object, the first element is used
	elem.jquery?elem[0]:elem)},add:function(selector,context){return this.pushStack(jQuery.unique(jQuery.merge(this.get(),jQuery(selector,context))))},addBack:function(selector){return this.add(selector==null?this.prevObject:this.prevObject.filter(selector))}});function sibling(cur,dir){while((cur=cur[dir])&&cur.nodeType!==1){}return cur}jQuery.each({parent:function(elem){var parent=elem.parentNode;return parent&&parent.nodeType!==11?parent:null},parents:function(elem){return jQuery.dir(elem,"parentNode")},parentsUntil:function(elem,i,until){return jQuery.dir(elem,"parentNode",until)},next:function(elem){return sibling(elem,"nextSibling")},prev:function(elem){return sibling(elem,"previousSibling")},nextAll:function(elem){return jQuery.dir(elem,"nextSibling")},prevAll:function(elem){return jQuery.dir(elem,"previousSibling")},nextUntil:function(elem,i,until){return jQuery.dir(elem,"nextSibling",until)},prevUntil:function(elem,i,until){return jQuery.dir(elem,"previousSibling",until)},siblings:function(elem){return jQuery.sibling((elem.parentNode||{}).firstChild,elem)},children:function(elem){return jQuery.sibling(elem.firstChild)},contents:function(elem){return elem.contentDocument||jQuery.merge([],elem.childNodes)}},function(name,fn){jQuery.fn[name]=function(until,selector){var matched=jQuery.map(this,fn,until);if(name.slice(-5)!=="Until"){selector=until}if(selector&&typeof selector==="string"){matched=jQuery.filter(selector,matched)}if(this.length>1){ // Remove duplicates
	if(!guaranteedUnique[name]){jQuery.unique(matched)} // Reverse order for parents* and prev-derivatives
	if(rparentsprev.test(name)){matched.reverse()}}return this.pushStack(matched)}});var rnotwhite=/\S+/g; // String to Object options format cache
	var optionsCache={}; // Convert String-formatted options into Object-formatted ones and store in cache
	function createOptions(options){var object=optionsCache[options]={};jQuery.each(options.match(rnotwhite)||[],function(_,flag){object[flag]=true});return object} /*
	 * Create a callback list using the following parameters:
	 *
	 *	options: an optional list of space-separated options that will change how
	 *			the callback list behaves or a more traditional option object
	 *
	 * By default a callback list will act like an event callback list and can be
	 * "fired" multiple times.
	 *
	 * Possible options:
	 *
	 *	once:			will ensure the callback list can only be fired once (like a Deferred)
	 *
	 *	memory:			will keep track of previous values and will call any callback added
	 *					after the list has been fired right away with the latest "memorized"
	 *					values (like a Deferred)
	 *
	 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
	 *
	 *	stopOnFalse:	interrupt callings when a callback returns false
	 *
	 */jQuery.Callbacks=function(options){ // Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options=typeof options==="string"?optionsCache[options]||createOptions(options):jQuery.extend({},options);var  // Last fire value (for non-forgettable lists)
	memory, // Flag to know if list was already fired
	fired, // Flag to know if list is currently firing
	firing, // First callback to fire (used internally by add and fireWith)
	firingStart, // End of the loop when firing
	firingLength, // Index of currently firing callback (modified by remove if needed)
	firingIndex, // Actual callback list
	list=[], // Stack of fire calls for repeatable lists
	stack=!options.once&&[], // Fire callbacks
	fire=function(data){memory=options.memory&&data;fired=true;firingIndex=firingStart||0;firingStart=0;firingLength=list.length;firing=true;for(;list&&firingIndex<firingLength;firingIndex++){if(list[firingIndex].apply(data[0],data[1])===false&&options.stopOnFalse){memory=false; // To prevent further calls using add
	break}}firing=false;if(list){if(stack){if(stack.length){fire(stack.shift())}}else if(memory){list=[]}else {self.disable()}}}, // Actual Callbacks object
	self={ // Add a callback or a collection of callbacks to the list
	add:function(){if(list){ // First, we save the current length
	var start=list.length;(function add(args){jQuery.each(args,function(_,arg){var type=jQuery.type(arg);if(type==="function"){if(!options.unique||!self.has(arg)){list.push(arg)}}else if(arg&&arg.length&&type!=="string"){ // Inspect recursively
	add(arg)}})})(arguments); // Do we need to add the callbacks to the
	// current firing batch?
	if(firing){firingLength=list.length; // With memory, if we're not firing then
	// we should call right away
	}else if(memory){firingStart=start;fire(memory)}}return this}, // Remove a callback from the list
	remove:function(){if(list){jQuery.each(arguments,function(_,arg){var index;while((index=jQuery.inArray(arg,list,index))>-1){list.splice(index,1); // Handle firing indexes
	if(firing){if(index<=firingLength){firingLength--}if(index<=firingIndex){firingIndex--}}}})}return this}, // Check if a given callback is in the list.
	// If no argument is given, return whether or not list has callbacks attached.
	has:function(fn){return fn?jQuery.inArray(fn,list)>-1:!!(list&&list.length)}, // Remove all callbacks from the list
	empty:function(){list=[];firingLength=0;return this}, // Have the list do nothing anymore
	disable:function(){list=stack=memory=undefined;return this}, // Is it disabled?
	disabled:function(){return !list}, // Lock the list in its current state
	lock:function(){stack=undefined;if(!memory){self.disable()}return this}, // Is it locked?
	locked:function(){return !stack}, // Call all callbacks with the given context and arguments
	fireWith:function(context,args){if(list&&(!fired||stack)){args=args||[];args=[context,args.slice?args.slice():args];if(firing){stack.push(args)}else {fire(args)}}return this}, // Call all the callbacks with the given arguments
	fire:function(){self.fireWith(this,arguments);return this}, // To know if the callbacks have already been called at least once
	fired:function(){return !!fired}};return self};jQuery.extend({Deferred:function(func){var tuples=[ // action, add listener, listener list, final state
	["resolve","done",jQuery.Callbacks("once memory"),"resolved"],["reject","fail",jQuery.Callbacks("once memory"),"rejected"],["notify","progress",jQuery.Callbacks("memory")]],state="pending",promise={state:function(){return state},always:function(){deferred.done(arguments).fail(arguments);return this},then:function() /* fnDone, fnFail, fnProgress */{var fns=arguments;return jQuery.Deferred(function(newDefer){jQuery.each(tuples,function(i,tuple){var fn=jQuery.isFunction(fns[i])&&fns[i]; // deferred[ done | fail | progress ] for forwarding actions to newDefer
	deferred[tuple[1]](function(){var returned=fn&&fn.apply(this,arguments);if(returned&&jQuery.isFunction(returned.promise)){returned.promise().done(newDefer.resolve).fail(newDefer.reject).progress(newDefer.notify)}else {newDefer[tuple[0]+"With"](this===promise?newDefer.promise():this,fn?[returned]:arguments)}})});fns=null}).promise()}, // Get a promise for this deferred
	// If obj is provided, the promise aspect is added to the object
	promise:function(obj){return obj!=null?jQuery.extend(obj,promise):promise}},deferred={}; // Keep pipe for back-compat
	promise.pipe=promise.then; // Add list-specific methods
	jQuery.each(tuples,function(i,tuple){var list=tuple[2],stateString=tuple[3]; // promise[ done | fail | progress ] = list.add
	promise[tuple[1]]=list.add; // Handle state
	if(stateString){list.add(function(){ // state = [ resolved | rejected ]
	state=stateString; // [ reject_list | resolve_list ].disable; progress_list.lock
	},tuples[i^1][2].disable,tuples[2][2].lock)} // deferred[ resolve | reject | notify ]
	deferred[tuple[0]]=function(){deferred[tuple[0]+"With"](this===deferred?promise:this,arguments);return this};deferred[tuple[0]+"With"]=list.fireWith}); // Make the deferred a promise
	promise.promise(deferred); // Call given func if any
	if(func){func.call(deferred,deferred)} // All done!
	return deferred}, // Deferred helper
	when:function(subordinate /* , ..., subordinateN */){var i=0,resolveValues=slice.call(arguments),length=resolveValues.length, // the count of uncompleted subordinates
	remaining=length!==1||subordinate&&jQuery.isFunction(subordinate.promise)?length:0, // the master Deferred. If resolveValues consist of only a single Deferred, just use that.
	deferred=remaining===1?subordinate:jQuery.Deferred(), // Update function for both resolve and progress values
	updateFunc=function(i,contexts,values){return function(value){contexts[i]=this;values[i]=arguments.length>1?slice.call(arguments):value;if(values===progressValues){deferred.notifyWith(contexts,values)}else if(! --remaining){deferred.resolveWith(contexts,values)}}},progressValues,progressContexts,resolveContexts; // Add listeners to Deferred subordinates; treat others as resolved
	if(length>1){progressValues=new Array(length);progressContexts=new Array(length);resolveContexts=new Array(length);for(;i<length;i++){if(resolveValues[i]&&jQuery.isFunction(resolveValues[i].promise)){resolveValues[i].promise().done(updateFunc(i,resolveContexts,resolveValues)).fail(deferred.reject).progress(updateFunc(i,progressContexts,progressValues))}else {--remaining}}} // If we're not waiting on anything, resolve the master
	if(!remaining){deferred.resolveWith(resolveContexts,resolveValues)}return deferred.promise()}}); // The deferred used on DOM ready
	var readyList;jQuery.fn.ready=function(fn){ // Add the callback
	jQuery.ready.promise().done(fn);return this};jQuery.extend({ // Is the DOM ready to be used? Set to true once it occurs.
	isReady:false, // A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait:1, // Hold (or release) the ready event
	holdReady:function(hold){if(hold){jQuery.readyWait++}else {jQuery.ready(true)}}, // Handle when the DOM is ready
	ready:function(wait){ // Abort if there are pending holds or we're already ready
	if(wait===true?--jQuery.readyWait:jQuery.isReady){return} // Remember that the DOM is ready
	jQuery.isReady=true; // If a normal DOM Ready event fired, decrement, and wait if need be
	if(wait!==true&&--jQuery.readyWait>0){return} // If there are functions bound, to execute
	readyList.resolveWith(document,[jQuery]); // Trigger any bound ready events
	if(jQuery.fn.triggerHandler){jQuery(document).triggerHandler("ready");jQuery(document).off("ready")}}}); /**
	 * The ready event handler and self cleanup method
	 */function completed(){document.removeEventListener("DOMContentLoaded",completed,false);window.removeEventListener("load",completed,false);jQuery.ready()}jQuery.ready.promise=function(obj){if(!readyList){readyList=jQuery.Deferred(); // Catch cases where $(document).ready() is called after the browser event has already occurred.
	// We once tried to use readyState "interactive" here, but it caused issues like the one
	// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
	if(document.readyState==="complete"){ // Handle it asynchronously to allow scripts the opportunity to delay ready
	setTimeout(jQuery.ready)}else { // Use the handy event callback
	document.addEventListener("DOMContentLoaded",completed,false); // A fallback to window.onload, that will always work
	window.addEventListener("load",completed,false)}}return readyList.promise(obj)}; // Kick off the DOM ready check even if the user does not
	jQuery.ready.promise(); // Multifunctional method to get and set values of a collection
	// The value/s can optionally be executed if it's a function
	var access=jQuery.access=function(elems,fn,key,value,chainable,emptyGet,raw){var i=0,len=elems.length,bulk=key==null; // Sets many values
	if(jQuery.type(key)==="object"){chainable=true;for(i in key){jQuery.access(elems,fn,i,key[i],true,emptyGet,raw)} // Sets one value
	}else if(value!==undefined){chainable=true;if(!jQuery.isFunction(value)){raw=true}if(bulk){ // Bulk operations run against the entire set
	if(raw){fn.call(elems,value);fn=null; // ...except when executing function values
	}else {bulk=fn;fn=function(elem,key,value){return bulk.call(jQuery(elem),value)}}}if(fn){for(;i<len;i++){fn(elems[i],key,raw?value:value.call(elems[i],i,fn(elems[i],key)))}}}return chainable?elems: // Gets
	bulk?fn.call(elems):len?fn(elems[0],key):emptyGet}; /**
	 * Determines whether an object can have data
	 */jQuery.acceptData=function(owner){ // Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	/* jshint -W018 */return owner.nodeType===1||owner.nodeType===9||! +owner.nodeType};function Data(){ // Support: Android<4,
	// Old WebKit does not have Object.preventExtensions/freeze method,
	// return new empty object instead with no [[set]] accessor
	Object.defineProperty(this.cache={},0,{get:function(){return {}}});this.expando=jQuery.expando+Data.uid++}Data.uid=1;Data.accepts=jQuery.acceptData;Data.prototype={key:function(owner){ // We can accept data for non-element nodes in modern browsers,
	// but we should not, see #8335.
	// Always return the key for a frozen object.
	if(!Data.accepts(owner)){return 0}var descriptor={}, // Check if the owner object already has a cache key
	unlock=owner[this.expando]; // If not, create one
	if(!unlock){unlock=Data.uid++; // Secure it in a non-enumerable, non-writable property
	try{descriptor[this.expando]={value:unlock};Object.defineProperties(owner,descriptor); // Support: Android<4
	// Fallback to a less secure definition
	}catch(e) {descriptor[this.expando]=unlock;jQuery.extend(owner,descriptor)}} // Ensure the cache object
	if(!this.cache[unlock]){this.cache[unlock]={}}return unlock},set:function(owner,data,value){var prop, // There may be an unlock assigned to this node,
	// if there is no entry for this "owner", create one inline
	// and set the unlock as though an owner entry had always existed
	unlock=this.key(owner),cache=this.cache[unlock]; // Handle: [ owner, key, value ] args
	if(typeof data==="string"){cache[data]=value; // Handle: [ owner, { properties } ] args
	}else { // Fresh assignments by object are shallow copied
	if(jQuery.isEmptyObject(cache)){jQuery.extend(this.cache[unlock],data); // Otherwise, copy the properties one-by-one to the cache object
	}else {for(prop in data){cache[prop]=data[prop]}}}return cache},get:function(owner,key){ // Either a valid cache is found, or will be created.
	// New caches will be created and the unlock returned,
	// allowing direct access to the newly created
	// empty data object. A valid owner object must be provided.
	var cache=this.cache[this.key(owner)];return key===undefined?cache:cache[key]},access:function(owner,key,value){var stored; // In cases where either:
	//
	//   1. No key was specified
	//   2. A string key was specified, but no value provided
	//
	// Take the "read" path and allow the get method to determine
	// which value to return, respectively either:
	//
	//   1. The entire cache object
	//   2. The data stored at the key
	//
	if(key===undefined||key&&typeof key==="string"&&value===undefined){stored=this.get(owner,key);return stored!==undefined?stored:this.get(owner,jQuery.camelCase(key))} // [*]When the key is not a string, or both a key and value
	// are specified, set or extend (existing objects) with either:
	//
	//   1. An object of properties
	//   2. A key and value
	//
	this.set(owner,key,value); // Since the "set" path can have two possible entry points
	// return the expected data based on which path was taken[*]
	return value!==undefined?value:key},remove:function(owner,key){var i,name,camel,unlock=this.key(owner),cache=this.cache[unlock];if(key===undefined){this.cache[unlock]={}}else { // Support array or space separated string of keys
	if(jQuery.isArray(key)){ // If "name" is an array of keys...
	// When data is initially created, via ("key", "val") signature,
	// keys will be converted to camelCase.
	// Since there is no way to tell _how_ a key was added, remove
	// both plain key and camelCase key. #12786
	// This will only penalize the array argument path.
	name=key.concat(key.map(jQuery.camelCase))}else {camel=jQuery.camelCase(key); // Try the string as a key before any manipulation
	if(key in cache){name=[key,camel]}else { // If a key with the spaces exists, use it.
	// Otherwise, create an array by matching non-whitespace
	name=camel;name=name in cache?[name]:name.match(rnotwhite)||[]}}i=name.length;while(i--){delete cache[name[i]]}}},hasData:function(owner){return !jQuery.isEmptyObject(this.cache[owner[this.expando]]||{})},discard:function(owner){if(owner[this.expando]){delete this.cache[owner[this.expando]]}}};var data_priv=new Data;var data_user=new Data; //	Implementation Summary
	//
	//	1. Enforce API surface and semantic compatibility with 1.9.x branch
	//	2. Improve the module's maintainability by reducing the storage
	//		paths to a single mechanism.
	//	3. Use the same single mechanism to support "private" and "user" data.
	//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
	//	5. Avoid exposing implementation details on user objects (eg. expando properties)
	//	6. Provide a clear path for implementation upgrade to WeakMap in 2014
	var rbrace=/^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,rmultiDash=/([A-Z])/g;function dataAttr(elem,key,data){var name; // If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if(data===undefined&&elem.nodeType===1){name="data-"+key.replace(rmultiDash,"-$1").toLowerCase();data=elem.getAttribute(name);if(typeof data==="string"){try{data=data==="true"?true:data==="false"?false:data==="null"?null: // Only convert to a number if it doesn't change the string
	+data+""===data?+data:rbrace.test(data)?jQuery.parseJSON(data):data}catch(e) {} // Make sure we set the data so it isn't changed later
	data_user.set(elem,key,data)}else {data=undefined}}return data}jQuery.extend({hasData:function(elem){return data_user.hasData(elem)||data_priv.hasData(elem)},data:function(elem,name,data){return data_user.access(elem,name,data)},removeData:function(elem,name){data_user.remove(elem,name)}, // TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to data_priv methods, these can be deprecated.
	_data:function(elem,name,data){return data_priv.access(elem,name,data)},_removeData:function(elem,name){data_priv.remove(elem,name)}});jQuery.fn.extend({data:function(key,value){var i,name,data,elem=this[0],attrs=elem&&elem.attributes; // Gets all values
	if(key===undefined){if(this.length){data=data_user.get(elem);if(elem.nodeType===1&&!data_priv.get(elem,"hasDataAttrs")){i=attrs.length;while(i--){ // Support: IE11+
	// The attrs elements can be null (#14894)
	if(attrs[i]){name=attrs[i].name;if(name.indexOf("data-")===0){name=jQuery.camelCase(name.slice(5));dataAttr(elem,name,data[name])}}}data_priv.set(elem,"hasDataAttrs",true)}}return data} // Sets multiple values
	if(typeof key==="object"){return this.each(function(){data_user.set(this,key)})}return access(this,function(value){var data,camelKey=jQuery.camelCase(key); // The calling jQuery object (element matches) is not empty
	// (and therefore has an element appears at this[ 0 ]) and the
	// `value` parameter was not undefined. An empty jQuery object
	// will result in `undefined` for elem = this[ 0 ] which will
	// throw an exception if an attempt to read a data cache is made.
	if(elem&&value===undefined){ // Attempt to get data from the cache
	// with the key as-is
	data=data_user.get(elem,key);if(data!==undefined){return data} // Attempt to get data from the cache
	// with the key camelized
	data=data_user.get(elem,camelKey);if(data!==undefined){return data} // Attempt to "discover" the data in
	// HTML5 custom data-* attrs
	data=dataAttr(elem,camelKey,undefined);if(data!==undefined){return data} // We tried really hard, but the data doesn't exist.
	return} // Set the data...
	this.each(function(){ // First, attempt to store a copy or reference of any
	// data that might've been store with a camelCased key.
	var data=data_user.get(this,camelKey); // For HTML5 data-* attribute interop, we have to
	// store property names with dashes in a camelCase form.
	// This might not apply to all properties...*
	data_user.set(this,camelKey,value); // *... In the case of properties that might _actually_
	// have dashes, we need to also store a copy of that
	// unchanged property.
	if(key.indexOf("-")!==-1&&data!==undefined){data_user.set(this,key,value)}})},null,value,arguments.length>1,null,true)},removeData:function(key){return this.each(function(){data_user.remove(this,key)})}});jQuery.extend({queue:function(elem,type,data){var queue;if(elem){type=(type||"fx")+"queue";queue=data_priv.get(elem,type); // Speed up dequeue by getting out quickly if this is just a lookup
	if(data){if(!queue||jQuery.isArray(data)){queue=data_priv.access(elem,type,jQuery.makeArray(data))}else {queue.push(data)}}return queue||[]}},dequeue:function(elem,type){type=type||"fx";var queue=jQuery.queue(elem,type),startLength=queue.length,fn=queue.shift(),hooks=jQuery._queueHooks(elem,type),next=function(){jQuery.dequeue(elem,type)}; // If the fx queue is dequeued, always remove the progress sentinel
	if(fn==="inprogress"){fn=queue.shift();startLength--}if(fn){ // Add a progress sentinel to prevent the fx queue from being
	// automatically dequeued
	if(type==="fx"){queue.unshift("inprogress")} // Clear up the last queue stop function
	delete hooks.stop;fn.call(elem,next,hooks)}if(!startLength&&hooks){hooks.empty.fire()}}, // Not public - generate a queueHooks object, or return the current one
	_queueHooks:function(elem,type){var key=type+"queueHooks";return data_priv.get(elem,key)||data_priv.access(elem,key,{empty:jQuery.Callbacks("once memory").add(function(){data_priv.remove(elem,[type+"queue",key])})})}});jQuery.fn.extend({queue:function(type,data){var setter=2;if(typeof type!=="string"){data=type;type="fx";setter--}if(arguments.length<setter){return jQuery.queue(this[0],type)}return data===undefined?this:this.each(function(){var queue=jQuery.queue(this,type,data); // Ensure a hooks for this queue
	jQuery._queueHooks(this,type);if(type==="fx"&&queue[0]!=="inprogress"){jQuery.dequeue(this,type)}})},dequeue:function(type){return this.each(function(){jQuery.dequeue(this,type)})},clearQueue:function(type){return this.queue(type||"fx",[])}, // Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise:function(type,obj){var tmp,count=1,defer=jQuery.Deferred(),elements=this,i=this.length,resolve=function(){if(! --count){defer.resolveWith(elements,[elements])}};if(typeof type!=="string"){obj=type;type=undefined}type=type||"fx";while(i--){tmp=data_priv.get(elements[i],type+"queueHooks");if(tmp&&tmp.empty){count++;tmp.empty.add(resolve)}}resolve();return defer.promise(obj)}});var pnum=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;var cssExpand=["Top","Right","Bottom","Left"];var isHidden=function(elem,el){ // isHidden might be called from jQuery#filter function;
	// in that case, element will be second argument
	elem=el||elem;return jQuery.css(elem,"display")==="none"||!jQuery.contains(elem.ownerDocument,elem)};var rcheckableType=/^(?:checkbox|radio)$/i;(function(){var fragment=document.createDocumentFragment(),div=fragment.appendChild(document.createElement("div")),input=document.createElement("input"); // Support: Safari<=5.1
	// Check state lost if the name is set (#11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (#14901)
	input.setAttribute("type","radio");input.setAttribute("checked","checked");input.setAttribute("name","t");div.appendChild(input); // Support: Safari<=5.1, Android<4.2
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone=div.cloneNode(true).cloneNode(true).lastChild.checked; // Support: IE<=11+
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML="<textarea>x</textarea>";support.noCloneChecked=!!div.cloneNode(true).lastChild.defaultValue})();var strundefined=typeof undefined;support.focusinBubbles="onfocusin" in window;var rkeyEvent=/^key/,rmouseEvent=/^(?:mouse|pointer|contextmenu)|click/,rfocusMorph=/^(?:focusinfocus|focusoutblur)$/,rtypenamespace=/^([^.]*)(?:\.(.+)|)$/;function returnTrue(){return true}function returnFalse(){return false}function safeActiveElement(){try{return document.activeElement}catch(err) {}} /*
	 * Helper functions for managing events -- not part of the public interface.
	 * Props to Dean Edwards' addEvent library for many of the ideas.
	 */jQuery.event={global:{},add:function(elem,types,handler,data,selector){var handleObjIn,eventHandle,tmp,events,t,handleObj,special,handlers,type,namespaces,origType,elemData=data_priv.get(elem); // Don't attach events to noData or text/comment nodes (but allow plain objects)
	if(!elemData){return} // Caller can pass in an object of custom data in lieu of the handler
	if(handler.handler){handleObjIn=handler;handler=handleObjIn.handler;selector=handleObjIn.selector} // Make sure that the handler has a unique ID, used to find/remove it later
	if(!handler.guid){handler.guid=jQuery.guid++} // Init the element's event structure and main handler, if this is the first
	if(!(events=elemData.events)){events=elemData.events={}}if(!(eventHandle=elemData.handle)){eventHandle=elemData.handle=function(e){ // Discard the second event of a jQuery.event.trigger() and
	// when an event is called after a page has unloaded
	return typeof jQuery!==strundefined&&jQuery.event.triggered!==e.type?jQuery.event.dispatch.apply(elem,arguments):undefined}} // Handle multiple events separated by a space
	types=(types||"").match(rnotwhite)||[""];t=types.length;while(t--){tmp=rtypenamespace.exec(types[t])||[];type=origType=tmp[1];namespaces=(tmp[2]||"").split(".").sort(); // There *must* be a type, no attaching namespace-only handlers
	if(!type){continue} // If event changes its type, use the special event handlers for the changed type
	special=jQuery.event.special[type]||{}; // If selector defined, determine special event api type, otherwise given type
	type=(selector?special.delegateType:special.bindType)||type; // Update special based on newly reset type
	special=jQuery.event.special[type]||{}; // handleObj is passed to all event handlers
	handleObj=jQuery.extend({type:type,origType:origType,data:data,handler:handler,guid:handler.guid,selector:selector,needsContext:selector&&jQuery.expr.match.needsContext.test(selector),namespace:namespaces.join(".")},handleObjIn); // Init the event handler queue if we're the first
	if(!(handlers=events[type])){handlers=events[type]=[];handlers.delegateCount=0; // Only use addEventListener if the special events handler returns false
	if(!special.setup||special.setup.call(elem,data,namespaces,eventHandle)===false){if(elem.addEventListener){elem.addEventListener(type,eventHandle,false)}}}if(special.add){special.add.call(elem,handleObj);if(!handleObj.handler.guid){handleObj.handler.guid=handler.guid}} // Add to the element's handler list, delegates in front
	if(selector){handlers.splice(handlers.delegateCount++,0,handleObj)}else {handlers.push(handleObj)} // Keep track of which events have ever been used, for event optimization
	jQuery.event.global[type]=true}}, // Detach an event or set of events from an element
	remove:function(elem,types,handler,selector,mappedTypes){var j,origCount,tmp,events,t,handleObj,special,handlers,type,namespaces,origType,elemData=data_priv.hasData(elem)&&data_priv.get(elem);if(!elemData||!(events=elemData.events)){return} // Once for each type.namespace in types; type may be omitted
	types=(types||"").match(rnotwhite)||[""];t=types.length;while(t--){tmp=rtypenamespace.exec(types[t])||[];type=origType=tmp[1];namespaces=(tmp[2]||"").split(".").sort(); // Unbind all events (on this namespace, if provided) for the element
	if(!type){for(type in events){jQuery.event.remove(elem,type+types[t],handler,selector,true)}continue}special=jQuery.event.special[type]||{};type=(selector?special.delegateType:special.bindType)||type;handlers=events[type]||[];tmp=tmp[2]&&new RegExp("(^|\\.)"+namespaces.join("\\.(?:.*\\.|)")+"(\\.|$)"); // Remove matching events
	origCount=j=handlers.length;while(j--){handleObj=handlers[j];if((mappedTypes||origType===handleObj.origType)&&(!handler||handler.guid===handleObj.guid)&&(!tmp||tmp.test(handleObj.namespace))&&(!selector||selector===handleObj.selector||selector==="**"&&handleObj.selector)){handlers.splice(j,1);if(handleObj.selector){handlers.delegateCount--}if(special.remove){special.remove.call(elem,handleObj)}}} // Remove generic event handler if we removed something and no more handlers exist
	// (avoids potential for endless recursion during removal of special event handlers)
	if(origCount&&!handlers.length){if(!special.teardown||special.teardown.call(elem,namespaces,elemData.handle)===false){jQuery.removeEvent(elem,type,elemData.handle)}delete events[type]}} // Remove the expando if it's no longer used
	if(jQuery.isEmptyObject(events)){delete elemData.handle;data_priv.remove(elem,"events")}},trigger:function(event,data,elem,onlyHandlers){var i,cur,tmp,bubbleType,ontype,handle,special,eventPath=[elem||document],type=hasOwn.call(event,"type")?event.type:event,namespaces=hasOwn.call(event,"namespace")?event.namespace.split("."):[];cur=tmp=elem=elem||document; // Don't do events on text and comment nodes
	if(elem.nodeType===3||elem.nodeType===8){return} // focus/blur morphs to focusin/out; ensure we're not firing them right now
	if(rfocusMorph.test(type+jQuery.event.triggered)){return}if(type.indexOf(".")>=0){ // Namespaced trigger; create a regexp to match event type in handle()
	namespaces=type.split(".");type=namespaces.shift();namespaces.sort()}ontype=type.indexOf(":")<0&&"on"+type; // Caller can pass in a jQuery.Event object, Object, or just an event type string
	event=event[jQuery.expando]?event:new jQuery.Event(type,typeof event==="object"&&event); // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
	event.isTrigger=onlyHandlers?2:3;event.namespace=namespaces.join(".");event.namespace_re=event.namespace?new RegExp("(^|\\.)"+namespaces.join("\\.(?:.*\\.|)")+"(\\.|$)"):null; // Clean up the event in case it is being reused
	event.result=undefined;if(!event.target){event.target=elem} // Clone any incoming data and prepend the event, creating the handler arg list
	data=data==null?[event]:jQuery.makeArray(data,[event]); // Allow special events to draw outside the lines
	special=jQuery.event.special[type]||{};if(!onlyHandlers&&special.trigger&&special.trigger.apply(elem,data)===false){return} // Determine event propagation path in advance, per W3C events spec (#9951)
	// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
	if(!onlyHandlers&&!special.noBubble&&!jQuery.isWindow(elem)){bubbleType=special.delegateType||type;if(!rfocusMorph.test(bubbleType+type)){cur=cur.parentNode}for(;cur;cur=cur.parentNode){eventPath.push(cur);tmp=cur} // Only add window if we got to document (e.g., not plain obj or detached DOM)
	if(tmp===(elem.ownerDocument||document)){eventPath.push(tmp.defaultView||tmp.parentWindow||window)}} // Fire handlers on the event path
	i=0;while((cur=eventPath[i++])&&!event.isPropagationStopped()){event.type=i>1?bubbleType:special.bindType||type; // jQuery handler
	handle=(data_priv.get(cur,"events")||{})[event.type]&&data_priv.get(cur,"handle");if(handle){handle.apply(cur,data)} // Native handler
	handle=ontype&&cur[ontype];if(handle&&handle.apply&&jQuery.acceptData(cur)){event.result=handle.apply(cur,data);if(event.result===false){event.preventDefault()}}}event.type=type; // If nobody prevented the default action, do it now
	if(!onlyHandlers&&!event.isDefaultPrevented()){if((!special._default||special._default.apply(eventPath.pop(),data)===false)&&jQuery.acceptData(elem)){ // Call a native DOM method on the target with the same name name as the event.
	// Don't do default actions on window, that's where global variables be (#6170)
	if(ontype&&jQuery.isFunction(elem[type])&&!jQuery.isWindow(elem)){ // Don't re-trigger an onFOO event when we call its FOO() method
	tmp=elem[ontype];if(tmp){elem[ontype]=null} // Prevent re-triggering of the same event, since we already bubbled it above
	jQuery.event.triggered=type;elem[type]();jQuery.event.triggered=undefined;if(tmp){elem[ontype]=tmp}}}}return event.result},dispatch:function(event){ // Make a writable jQuery.Event from the native event object
	event=jQuery.event.fix(event);var i,j,ret,matched,handleObj,handlerQueue=[],args=slice.call(arguments),handlers=(data_priv.get(this,"events")||{})[event.type]||[],special=jQuery.event.special[event.type]||{}; // Use the fix-ed jQuery.Event rather than the (read-only) native event
	args[0]=event;event.delegateTarget=this; // Call the preDispatch hook for the mapped type, and let it bail if desired
	if(special.preDispatch&&special.preDispatch.call(this,event)===false){return} // Determine handlers
	handlerQueue=jQuery.event.handlers.call(this,event,handlers); // Run delegates first; they may want to stop propagation beneath us
	i=0;while((matched=handlerQueue[i++])&&!event.isPropagationStopped()){event.currentTarget=matched.elem;j=0;while((handleObj=matched.handlers[j++])&&!event.isImmediatePropagationStopped()){ // Triggered event must either 1) have no namespace, or 2) have namespace(s)
	// a subset or equal to those in the bound event (both can have no namespace).
	if(!event.namespace_re||event.namespace_re.test(handleObj.namespace)){event.handleObj=handleObj;event.data=handleObj.data;ret=((jQuery.event.special[handleObj.origType]||{}).handle||handleObj.handler).apply(matched.elem,args);if(ret!==undefined){if((event.result=ret)===false){event.preventDefault();event.stopPropagation()}}}}} // Call the postDispatch hook for the mapped type
	if(special.postDispatch){special.postDispatch.call(this,event)}return event.result},handlers:function(event,handlers){var i,matches,sel,handleObj,handlerQueue=[],delegateCount=handlers.delegateCount,cur=event.target; // Find delegate handlers
	// Black-hole SVG <use> instance trees (#13180)
	// Avoid non-left-click bubbling in Firefox (#3861)
	if(delegateCount&&cur.nodeType&&(!event.button||event.type!=="click")){for(;cur!==this;cur=cur.parentNode||this){ // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
	if(cur.disabled!==true||event.type!=="click"){matches=[];for(i=0;i<delegateCount;i++){handleObj=handlers[i]; // Don't conflict with Object.prototype properties (#13203)
	sel=handleObj.selector+" ";if(matches[sel]===undefined){matches[sel]=handleObj.needsContext?jQuery(sel,this).index(cur)>=0:jQuery.find(sel,this,null,[cur]).length}if(matches[sel]){matches.push(handleObj)}}if(matches.length){handlerQueue.push({elem:cur,handlers:matches})}}}} // Add the remaining (directly-bound) handlers
	if(delegateCount<handlers.length){handlerQueue.push({elem:this,handlers:handlers.slice(delegateCount)})}return handlerQueue}, // Includes some event props shared by KeyEvent and MouseEvent
	props:"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),fixHooks:{},keyHooks:{props:"char charCode key keyCode".split(" "),filter:function(event,original){ // Add which for key events
	if(event.which==null){event.which=original.charCode!=null?original.charCode:original.keyCode}return event}},mouseHooks:{props:"button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),filter:function(event,original){var eventDoc,doc,body,button=original.button; // Calculate pageX/Y if missing and clientX/Y available
	if(event.pageX==null&&original.clientX!=null){eventDoc=event.target.ownerDocument||document;doc=eventDoc.documentElement;body=eventDoc.body;event.pageX=original.clientX+(doc&&doc.scrollLeft||body&&body.scrollLeft||0)-(doc&&doc.clientLeft||body&&body.clientLeft||0);event.pageY=original.clientY+(doc&&doc.scrollTop||body&&body.scrollTop||0)-(doc&&doc.clientTop||body&&body.clientTop||0)} // Add which for click: 1 === left; 2 === middle; 3 === right
	// Note: button is not normalized, so don't use it
	if(!event.which&&button!==undefined){event.which=button&1?1:button&2?3:button&4?2:0}return event}},fix:function(event){if(event[jQuery.expando]){return event} // Create a writable copy of the event object and normalize some properties
	var i,prop,copy,type=event.type,originalEvent=event,fixHook=this.fixHooks[type];if(!fixHook){this.fixHooks[type]=fixHook=rmouseEvent.test(type)?this.mouseHooks:rkeyEvent.test(type)?this.keyHooks:{}}copy=fixHook.props?this.props.concat(fixHook.props):this.props;event=new jQuery.Event(originalEvent);i=copy.length;while(i--){prop=copy[i];event[prop]=originalEvent[prop]} // Support: Cordova 2.5 (WebKit) (#13255)
	// All events should have a target; Cordova deviceready doesn't
	if(!event.target){event.target=document} // Support: Safari 6.0+, Chrome<28
	// Target should not be a text node (#504, #13143)
	if(event.target.nodeType===3){event.target=event.target.parentNode}return fixHook.filter?fixHook.filter(event,originalEvent):event},special:{load:{ // Prevent triggered image.load events from bubbling to window.load
	noBubble:true},focus:{ // Fire native event if possible so blur/focus sequence is correct
	trigger:function(){if(this!==safeActiveElement()&&this.focus){this.focus();return false}},delegateType:"focusin"},blur:{trigger:function(){if(this===safeActiveElement()&&this.blur){this.blur();return false}},delegateType:"focusout"},click:{ // For checkbox, fire native event so checked state will be right
	trigger:function(){if(this.type==="checkbox"&&this.click&&jQuery.nodeName(this,"input")){this.click();return false}}, // For cross-browser consistency, don't fire native .click() on links
	_default:function(event){return jQuery.nodeName(event.target,"a")}},beforeunload:{postDispatch:function(event){ // Support: Firefox 20+
	// Firefox doesn't alert if the returnValue field is not set.
	if(event.result!==undefined&&event.originalEvent){event.originalEvent.returnValue=event.result}}}},simulate:function(type,elem,event,bubble){ // Piggyback on a donor event to simulate a different one.
	// Fake originalEvent to avoid donor's stopPropagation, but if the
	// simulated event prevents default then we do the same on the donor.
	var e=jQuery.extend(new jQuery.Event,event,{type:type,isSimulated:true,originalEvent:{}});if(bubble){jQuery.event.trigger(e,null,elem)}else {jQuery.event.dispatch.call(elem,e)}if(e.isDefaultPrevented()){event.preventDefault()}}};jQuery.removeEvent=function(elem,type,handle){if(elem.removeEventListener){elem.removeEventListener(type,handle,false)}};jQuery.Event=function(src,props){ // Allow instantiation without the 'new' keyword
	if(!(this instanceof jQuery.Event)){return new jQuery.Event(src,props)} // Event object
	if(src&&src.type){this.originalEvent=src;this.type=src.type; // Events bubbling up the document may have been marked as prevented
	// by a handler lower down the tree; reflect the correct value.
	this.isDefaultPrevented=src.defaultPrevented||src.defaultPrevented===undefined&& // Support: Android<4.0
	src.returnValue===false?returnTrue:returnFalse; // Event type
	}else {this.type=src} // Put explicitly provided properties onto the event object
	if(props){jQuery.extend(this,props)} // Create a timestamp if incoming event doesn't have one
	this.timeStamp=src&&src.timeStamp||jQuery.now(); // Mark it as fixed
	this[jQuery.expando]=true}; // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
	// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
	jQuery.Event.prototype={isDefaultPrevented:returnFalse,isPropagationStopped:returnFalse,isImmediatePropagationStopped:returnFalse,preventDefault:function(){var e=this.originalEvent;this.isDefaultPrevented=returnTrue;if(e&&e.preventDefault){e.preventDefault()}},stopPropagation:function(){var e=this.originalEvent;this.isPropagationStopped=returnTrue;if(e&&e.stopPropagation){e.stopPropagation()}},stopImmediatePropagation:function(){var e=this.originalEvent;this.isImmediatePropagationStopped=returnTrue;if(e&&e.stopImmediatePropagation){e.stopImmediatePropagation()}this.stopPropagation()}}; // Create mouseenter/leave events using mouseover/out and event-time checks
	// Support: Chrome 15+
	jQuery.each({mouseenter:"mouseover",mouseleave:"mouseout",pointerenter:"pointerover",pointerleave:"pointerout"},function(orig,fix){jQuery.event.special[orig]={delegateType:fix,bindType:fix,handle:function(event){var ret,target=this,related=event.relatedTarget,handleObj=event.handleObj; // For mousenter/leave call the handler if related is outside the target.
	// NB: No relatedTarget if the mouse left/entered the browser window
	if(!related||related!==target&&!jQuery.contains(target,related)){event.type=handleObj.origType;ret=handleObj.handler.apply(this,arguments);event.type=fix}return ret}}}); // Support: Firefox, Chrome, Safari
	// Create "bubbling" focus and blur events
	if(!support.focusinBubbles){jQuery.each({focus:"focusin",blur:"focusout"},function(orig,fix){ // Attach a single capturing handler on the document while someone wants focusin/focusout
	var handler=function(event){jQuery.event.simulate(fix,event.target,jQuery.event.fix(event),true)};jQuery.event.special[fix]={setup:function(){var doc=this.ownerDocument||this,attaches=data_priv.access(doc,fix);if(!attaches){doc.addEventListener(orig,handler,true)}data_priv.access(doc,fix,(attaches||0)+1)},teardown:function(){var doc=this.ownerDocument||this,attaches=data_priv.access(doc,fix)-1;if(!attaches){doc.removeEventListener(orig,handler,true);data_priv.remove(doc,fix)}else {data_priv.access(doc,fix,attaches)}}}})}jQuery.fn.extend({on:function(types,selector,data,fn, /*INTERNAL*/one){var origFn,type; // Types can be a map of types/handlers
	if(typeof types==="object"){ // ( types-Object, selector, data )
	if(typeof selector!=="string"){ // ( types-Object, data )
	data=data||selector;selector=undefined}for(type in types){this.on(type,selector,data,types[type],one)}return this}if(data==null&&fn==null){ // ( types, fn )
	fn=selector;data=selector=undefined}else if(fn==null){if(typeof selector==="string"){ // ( types, selector, fn )
	fn=data;data=undefined}else { // ( types, data, fn )
	fn=data;data=selector;selector=undefined}}if(fn===false){fn=returnFalse}else if(!fn){return this}if(one===1){origFn=fn;fn=function(event){ // Can use an empty set, since event contains the info
	jQuery().off(event);return origFn.apply(this,arguments)}; // Use same guid so caller can remove using origFn
	fn.guid=origFn.guid||(origFn.guid=jQuery.guid++)}return this.each(function(){jQuery.event.add(this,types,fn,data,selector)})},one:function(types,selector,data,fn){return this.on(types,selector,data,fn,1)},off:function(types,selector,fn){var handleObj,type;if(types&&types.preventDefault&&types.handleObj){ // ( event )  dispatched jQuery.Event
	handleObj=types.handleObj;jQuery(types.delegateTarget).off(handleObj.namespace?handleObj.origType+"."+handleObj.namespace:handleObj.origType,handleObj.selector,handleObj.handler);return this}if(typeof types==="object"){ // ( types-object [, selector] )
	for(type in types){this.off(type,selector,types[type])}return this}if(selector===false||typeof selector==="function"){ // ( types [, fn] )
	fn=selector;selector=undefined}if(fn===false){fn=returnFalse}return this.each(function(){jQuery.event.remove(this,types,fn,selector)})},trigger:function(type,data){return this.each(function(){jQuery.event.trigger(type,data,this)})},triggerHandler:function(type,data){var elem=this[0];if(elem){return jQuery.event.trigger(type,data,elem,true)}}});var rxhtmlTag=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,rtagName=/<([\w:]+)/,rhtml=/<|&#?\w+;/,rnoInnerhtml=/<(?:script|style|link)/i, // checked="checked" or checked
	rchecked=/checked\s*(?:[^=]|=\s*.checked.)/i,rscriptType=/^$|\/(?:java|ecma)script/i,rscriptTypeMasked=/^true\/(.*)/,rcleanScript=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g, // We have to close these tags to support XHTML (#13200)
	wrapMap={ // Support: IE9
	option:[1,"<select multiple='multiple'>","</select>"],thead:[1,"<table>","</table>"],col:[2,"<table><colgroup>","</colgroup></table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:[0,"",""]}; // Support: IE9
	wrapMap.optgroup=wrapMap.option;wrapMap.tbody=wrapMap.tfoot=wrapMap.colgroup=wrapMap.caption=wrapMap.thead;wrapMap.th=wrapMap.td; // Support: 1.x compatibility
	// Manipulating tables requires a tbody
	function manipulationTarget(elem,content){return jQuery.nodeName(elem,"table")&&jQuery.nodeName(content.nodeType!==11?content:content.firstChild,"tr")?elem.getElementsByTagName("tbody")[0]||elem.appendChild(elem.ownerDocument.createElement("tbody")):elem} // Replace/restore the type attribute of script elements for safe DOM manipulation
	function disableScript(elem){elem.type=(elem.getAttribute("type")!==null)+"/"+elem.type;return elem}function restoreScript(elem){var match=rscriptTypeMasked.exec(elem.type);if(match){elem.type=match[1]}else {elem.removeAttribute("type")}return elem} // Mark scripts as having already been evaluated
	function setGlobalEval(elems,refElements){var i=0,l=elems.length;for(;i<l;i++){data_priv.set(elems[i],"globalEval",!refElements||data_priv.get(refElements[i],"globalEval"))}}function cloneCopyEvent(src,dest){var i,l,type,pdataOld,pdataCur,udataOld,udataCur,events;if(dest.nodeType!==1){return} // 1. Copy private data: events, handlers, etc.
	if(data_priv.hasData(src)){pdataOld=data_priv.access(src);pdataCur=data_priv.set(dest,pdataOld);events=pdataOld.events;if(events){delete pdataCur.handle;pdataCur.events={};for(type in events){for(i=0,l=events[type].length;i<l;i++){jQuery.event.add(dest,type,events[type][i])}}}} // 2. Copy user data
	if(data_user.hasData(src)){udataOld=data_user.access(src);udataCur=jQuery.extend({},udataOld);data_user.set(dest,udataCur)}}function getAll(context,tag){var ret=context.getElementsByTagName?context.getElementsByTagName(tag||"*"):context.querySelectorAll?context.querySelectorAll(tag||"*"):[];return tag===undefined||tag&&jQuery.nodeName(context,tag)?jQuery.merge([context],ret):ret} // Fix IE bugs, see support tests
	function fixInput(src,dest){var nodeName=dest.nodeName.toLowerCase(); // Fails to persist the checked state of a cloned checkbox or radio button.
	if(nodeName==="input"&&rcheckableType.test(src.type)){dest.checked=src.checked; // Fails to return the selected option to the default selected state when cloning options
	}else if(nodeName==="input"||nodeName==="textarea"){dest.defaultValue=src.defaultValue}}jQuery.extend({clone:function(elem,dataAndEvents,deepDataAndEvents){var i,l,srcElements,destElements,clone=elem.cloneNode(true),inPage=jQuery.contains(elem.ownerDocument,elem); // Fix IE cloning issues
	if(!support.noCloneChecked&&(elem.nodeType===1||elem.nodeType===11)&&!jQuery.isXMLDoc(elem)){ // We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
	destElements=getAll(clone);srcElements=getAll(elem);for(i=0,l=srcElements.length;i<l;i++){fixInput(srcElements[i],destElements[i])}} // Copy the events from the original to the clone
	if(dataAndEvents){if(deepDataAndEvents){srcElements=srcElements||getAll(elem);destElements=destElements||getAll(clone);for(i=0,l=srcElements.length;i<l;i++){cloneCopyEvent(srcElements[i],destElements[i])}}else {cloneCopyEvent(elem,clone)}} // Preserve script evaluation history
	destElements=getAll(clone,"script");if(destElements.length>0){setGlobalEval(destElements,!inPage&&getAll(elem,"script"))} // Return the cloned set
	return clone},buildFragment:function(elems,context,scripts,selection){var elem,tmp,tag,wrap,contains,j,fragment=context.createDocumentFragment(),nodes=[],i=0,l=elems.length;for(;i<l;i++){elem=elems[i];if(elem||elem===0){ // Add nodes directly
	if(jQuery.type(elem)==="object"){ // Support: QtWebKit, PhantomJS
	// push.apply(_, arraylike) throws on ancient WebKit
	jQuery.merge(nodes,elem.nodeType?[elem]:elem); // Convert non-html into a text node
	}else if(!rhtml.test(elem)){nodes.push(context.createTextNode(elem)); // Convert html into DOM nodes
	}else {tmp=tmp||fragment.appendChild(context.createElement("div")); // Deserialize a standard representation
	tag=(rtagName.exec(elem)||["",""])[1].toLowerCase();wrap=wrapMap[tag]||wrapMap._default;tmp.innerHTML=wrap[1]+elem.replace(rxhtmlTag,"<$1></$2>")+wrap[2]; // Descend through wrappers to the right content
	j=wrap[0];while(j--){tmp=tmp.lastChild} // Support: QtWebKit, PhantomJS
	// push.apply(_, arraylike) throws on ancient WebKit
	jQuery.merge(nodes,tmp.childNodes); // Remember the top-level container
	tmp=fragment.firstChild; // Ensure the created nodes are orphaned (#12392)
	tmp.textContent=""}}} // Remove wrapper from fragment
	fragment.textContent="";i=0;while(elem=nodes[i++]){ // #4087 - If origin and destination elements are the same, and this is
	// that element, do not do anything
	if(selection&&jQuery.inArray(elem,selection)!==-1){continue}contains=jQuery.contains(elem.ownerDocument,elem); // Append to fragment
	tmp=getAll(fragment.appendChild(elem),"script"); // Preserve script evaluation history
	if(contains){setGlobalEval(tmp)} // Capture executables
	if(scripts){j=0;while(elem=tmp[j++]){if(rscriptType.test(elem.type||"")){scripts.push(elem)}}}}return fragment},cleanData:function(elems){var data,elem,type,key,special=jQuery.event.special,i=0;for(;(elem=elems[i])!==undefined;i++){if(jQuery.acceptData(elem)){key=elem[data_priv.expando];if(key&&(data=data_priv.cache[key])){if(data.events){for(type in data.events){if(special[type]){jQuery.event.remove(elem,type); // This is a shortcut to avoid jQuery.event.remove's overhead
	}else {jQuery.removeEvent(elem,type,data.handle)}}}if(data_priv.cache[key]){ // Discard any remaining `private` data
	delete data_priv.cache[key]}}} // Discard any remaining `user` data
	delete data_user.cache[elem[data_user.expando]]}}});jQuery.fn.extend({text:function(value){return access(this,function(value){return value===undefined?jQuery.text(this):this.empty().each(function(){if(this.nodeType===1||this.nodeType===11||this.nodeType===9){this.textContent=value}})},null,value,arguments.length)},append:function(){return this.domManip(arguments,function(elem){if(this.nodeType===1||this.nodeType===11||this.nodeType===9){var target=manipulationTarget(this,elem);target.appendChild(elem)}})},prepend:function(){return this.domManip(arguments,function(elem){if(this.nodeType===1||this.nodeType===11||this.nodeType===9){var target=manipulationTarget(this,elem);target.insertBefore(elem,target.firstChild)}})},before:function(){return this.domManip(arguments,function(elem){if(this.parentNode){this.parentNode.insertBefore(elem,this)}})},after:function(){return this.domManip(arguments,function(elem){if(this.parentNode){this.parentNode.insertBefore(elem,this.nextSibling)}})},remove:function(selector,keepData /* Internal Use Only */){var elem,elems=selector?jQuery.filter(selector,this):this,i=0;for(;(elem=elems[i])!=null;i++){if(!keepData&&elem.nodeType===1){jQuery.cleanData(getAll(elem))}if(elem.parentNode){if(keepData&&jQuery.contains(elem.ownerDocument,elem)){setGlobalEval(getAll(elem,"script"))}elem.parentNode.removeChild(elem)}}return this},empty:function(){var elem,i=0;for(;(elem=this[i])!=null;i++){if(elem.nodeType===1){ // Prevent memory leaks
	jQuery.cleanData(getAll(elem,false)); // Remove any remaining nodes
	elem.textContent=""}}return this},clone:function(dataAndEvents,deepDataAndEvents){dataAndEvents=dataAndEvents==null?false:dataAndEvents;deepDataAndEvents=deepDataAndEvents==null?dataAndEvents:deepDataAndEvents;return this.map(function(){return jQuery.clone(this,dataAndEvents,deepDataAndEvents)})},html:function(value){return access(this,function(value){var elem=this[0]||{},i=0,l=this.length;if(value===undefined&&elem.nodeType===1){return elem.innerHTML} // See if we can take a shortcut and just use innerHTML
	if(typeof value==="string"&&!rnoInnerhtml.test(value)&&!wrapMap[(rtagName.exec(value)||["",""])[1].toLowerCase()]){value=value.replace(rxhtmlTag,"<$1></$2>");try{for(;i<l;i++){elem=this[i]||{}; // Remove element nodes and prevent memory leaks
	if(elem.nodeType===1){jQuery.cleanData(getAll(elem,false));elem.innerHTML=value}}elem=0; // If using innerHTML throws an exception, use the fallback method
	}catch(e) {}}if(elem){this.empty().append(value)}},null,value,arguments.length)},replaceWith:function(){var arg=arguments[0]; // Make the changes, replacing each context element with the new content
	this.domManip(arguments,function(elem){arg=this.parentNode;jQuery.cleanData(getAll(this));if(arg){arg.replaceChild(elem,this)}}); // Force removal if there was no new content (e.g., from empty arguments)
	return arg&&(arg.length||arg.nodeType)?this:this.remove()},detach:function(selector){return this.remove(selector,true)},domManip:function(args,callback){ // Flatten any nested arrays
	args=concat.apply([],args);var fragment,first,scripts,hasScripts,node,doc,i=0,l=this.length,set=this,iNoClone=l-1,value=args[0],isFunction=jQuery.isFunction(value); // We can't cloneNode fragments that contain checked, in WebKit
	if(isFunction||l>1&&typeof value==="string"&&!support.checkClone&&rchecked.test(value)){return this.each(function(index){var self=set.eq(index);if(isFunction){args[0]=value.call(this,index,self.html())}self.domManip(args,callback)})}if(l){fragment=jQuery.buildFragment(args,this[0].ownerDocument,false,this);first=fragment.firstChild;if(fragment.childNodes.length===1){fragment=first}if(first){scripts=jQuery.map(getAll(fragment,"script"),disableScript);hasScripts=scripts.length; // Use the original fragment for the last item instead of the first because it can end up
	// being emptied incorrectly in certain situations (#8070).
	for(;i<l;i++){node=fragment;if(i!==iNoClone){node=jQuery.clone(node,true,true); // Keep references to cloned scripts for later restoration
	if(hasScripts){ // Support: QtWebKit
	// jQuery.merge because push.apply(_, arraylike) throws
	jQuery.merge(scripts,getAll(node,"script"))}}callback.call(this[i],node,i)}if(hasScripts){doc=scripts[scripts.length-1].ownerDocument; // Reenable scripts
	jQuery.map(scripts,restoreScript); // Evaluate executable scripts on first document insertion
	for(i=0;i<hasScripts;i++){node=scripts[i];if(rscriptType.test(node.type||"")&&!data_priv.access(node,"globalEval")&&jQuery.contains(doc,node)){if(node.src){ // Optional AJAX dependency, but won't run scripts if not present
	if(jQuery._evalUrl){jQuery._evalUrl(node.src)}}else {jQuery.globalEval(node.textContent.replace(rcleanScript,""))}}}}}}return this}});jQuery.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(name,original){jQuery.fn[name]=function(selector){var elems,ret=[],insert=jQuery(selector),last=insert.length-1,i=0;for(;i<=last;i++){elems=i===last?this:this.clone(true);jQuery(insert[i])[original](elems); // Support: QtWebKit
	// .get() because push.apply(_, arraylike) throws
	push.apply(ret,elems.get())}return this.pushStack(ret)}});var iframe,elemdisplay={}; /**
	 * Retrieve the actual display of a element
	 * @param {String} name nodeName of the element
	 * @param {Object} doc Document object
	 */ // Called only from within defaultDisplay
	function actualDisplay(name,doc){var style,elem=jQuery(doc.createElement(name)).appendTo(doc.body), // getDefaultComputedStyle might be reliably used only on attached element
	display=window.getDefaultComputedStyle&&(style=window.getDefaultComputedStyle(elem[0]))? // Use of this method is a temporary fix (more like optimization) until something better comes along,
	// since it was removed from specification and supported only in FF
	style.display:jQuery.css(elem[0],"display"); // We don't have any data stored on the element,
	// so use "detach" method as fast way to get rid of the element
	elem.detach();return display} /**
	 * Try to determine the default display value of an element
	 * @param {String} nodeName
	 */function defaultDisplay(nodeName){var doc=document,display=elemdisplay[nodeName];if(!display){display=actualDisplay(nodeName,doc); // If the simple way fails, read from inside an iframe
	if(display==="none"||!display){ // Use the already-created iframe if possible
	iframe=(iframe||jQuery("<iframe frameborder='0' width='0' height='0'/>")).appendTo(doc.documentElement); // Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
	doc=iframe[0].contentDocument; // Support: IE
	doc.write();doc.close();display=actualDisplay(nodeName,doc);iframe.detach()} // Store the correct default display
	elemdisplay[nodeName]=display}return display}var rmargin=/^margin/;var rnumnonpx=new RegExp("^("+pnum+")(?!px)[a-z%]+$","i");var getStyles=function(elem){ // Support: IE<=11+, Firefox<=30+ (#15098, #14150)
	// IE throws on elements created in popups
	// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
	if(elem.ownerDocument.defaultView.opener){return elem.ownerDocument.defaultView.getComputedStyle(elem,null)}return window.getComputedStyle(elem,null)};function curCSS(elem,name,computed){var width,minWidth,maxWidth,ret,style=elem.style;computed=computed||getStyles(elem); // Support: IE9
	// getPropertyValue is only needed for .css('filter') (#12537)
	if(computed){ret=computed.getPropertyValue(name)||computed[name]}if(computed){if(ret===""&&!jQuery.contains(elem.ownerDocument,elem)){ret=jQuery.style(elem,name)} // Support: iOS < 6
	// A tribute to the "awesome hack by Dean Edwards"
	// iOS < 6 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
	// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
	if(rnumnonpx.test(ret)&&rmargin.test(name)){ // Remember the original values
	width=style.width;minWidth=style.minWidth;maxWidth=style.maxWidth; // Put in the new values to get a computed value out
	style.minWidth=style.maxWidth=style.width=ret;ret=computed.width; // Revert the changed values
	style.width=width;style.minWidth=minWidth;style.maxWidth=maxWidth}}return ret!==undefined? // Support: IE
	// IE returns zIndex value as an integer.
	ret+"":ret}function addGetHookIf(conditionFn,hookFn){ // Define the hook, we'll check on the first run if it's really needed.
	return {get:function(){if(conditionFn()){ // Hook not needed (or it's not possible to use it due
	// to missing dependency), remove it.
	delete this.get;return} // Hook needed; redefine it so that the support test is not executed again.
	return (this.get=hookFn).apply(this,arguments)}}}(function(){var pixelPositionVal,boxSizingReliableVal,docElem=document.documentElement,container=document.createElement("div"),div=document.createElement("div");if(!div.style){return} // Support: IE9-11+
	// Style of cloned element affects source element cloned (#8908)
	div.style.backgroundClip="content-box";div.cloneNode(true).style.backgroundClip="";support.clearCloneStyle=div.style.backgroundClip==="content-box";container.style.cssText="border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;"+"position:absolute";container.appendChild(div); // Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computePixelPositionAndBoxSizingReliable(){div.style.cssText= // Support: Firefox<29, Android 2.3
	// Vendor-prefix box-sizing
	"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;"+"box-sizing:border-box;display:block;margin-top:1%;top:1%;"+"border:1px;padding:1px;width:4px;position:absolute";div.innerHTML="";docElem.appendChild(container);var divStyle=window.getComputedStyle(div,null);pixelPositionVal=divStyle.top!=="1%";boxSizingReliableVal=divStyle.width==="4px";docElem.removeChild(container)} // Support: node.js jsdom
	// Don't assume that getComputedStyle is a property of the global object
	if(window.getComputedStyle){jQuery.extend(support,{pixelPosition:function(){ // This test is executed only once but we still do memoizing
	// since we can use the boxSizingReliable pre-computing.
	// No need to check if the test was already performed, though.
	computePixelPositionAndBoxSizingReliable();return pixelPositionVal},boxSizingReliable:function(){if(boxSizingReliableVal==null){computePixelPositionAndBoxSizingReliable()}return boxSizingReliableVal},reliableMarginRight:function(){ // Support: Android 2.3
	// Check if div with explicit width and no margin-right incorrectly
	// gets computed margin-right based on width of container. (#3333)
	// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
	// This support function is only executed once so no memoizing is needed.
	var ret,marginDiv=div.appendChild(document.createElement("div")); // Reset CSS: box-sizing; display; margin; border; padding
	marginDiv.style.cssText=div.style.cssText= // Support: Firefox<29, Android 2.3
	// Vendor-prefix box-sizing
	"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;"+"box-sizing:content-box;display:block;margin:0;border:0;padding:0";marginDiv.style.marginRight=marginDiv.style.width="0";div.style.width="1px";docElem.appendChild(container);ret=!parseFloat(window.getComputedStyle(marginDiv,null).marginRight);docElem.removeChild(container);div.removeChild(marginDiv);return ret}})}})(); // A method for quickly swapping in/out CSS properties to get correct calculations.
	jQuery.swap=function(elem,options,callback,args){var ret,name,old={}; // Remember the old values, and insert the new ones
	for(name in options){old[name]=elem.style[name];elem.style[name]=options[name]}ret=callback.apply(elem,args||[]); // Revert the old values
	for(name in options){elem.style[name]=old[name]}return ret};var  // Swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap=/^(none|table(?!-c[ea]).+)/,rnumsplit=new RegExp("^("+pnum+")(.*)$","i"),rrelNum=new RegExp("^([+-])=("+pnum+")","i"),cssShow={position:"absolute",visibility:"hidden",display:"block"},cssNormalTransform={letterSpacing:"0",fontWeight:"400"},cssPrefixes=["Webkit","O","Moz","ms"]; // Return a css property mapped to a potentially vendor prefixed property
	function vendorPropName(style,name){ // Shortcut for names that are not vendor prefixed
	if(name in style){return name} // Check for vendor prefixed names
	var capName=name[0].toUpperCase()+name.slice(1),origName=name,i=cssPrefixes.length;while(i--){name=cssPrefixes[i]+capName;if(name in style){return name}}return origName}function setPositiveNumber(elem,value,subtract){var matches=rnumsplit.exec(value);return matches? // Guard against undefined "subtract", e.g., when used as in cssHooks
	Math.max(0,matches[1]-(subtract||0))+(matches[2]||"px"):value}function augmentWidthOrHeight(elem,name,extra,isBorderBox,styles){var i=extra===(isBorderBox?"border":"content")? // If we already have the right measurement, avoid augmentation
	4: // Otherwise initialize for horizontal or vertical properties
	name==="width"?1:0,val=0;for(;i<4;i+=2){ // Both box models exclude margin, so add it if we want it
	if(extra==="margin"){val+=jQuery.css(elem,extra+cssExpand[i],true,styles)}if(isBorderBox){ // border-box includes padding, so remove it if we want content
	if(extra==="content"){val-=jQuery.css(elem,"padding"+cssExpand[i],true,styles)} // At this point, extra isn't border nor margin, so remove border
	if(extra!=="margin"){val-=jQuery.css(elem,"border"+cssExpand[i]+"Width",true,styles)}}else { // At this point, extra isn't content, so add padding
	val+=jQuery.css(elem,"padding"+cssExpand[i],true,styles); // At this point, extra isn't content nor padding, so add border
	if(extra!=="padding"){val+=jQuery.css(elem,"border"+cssExpand[i]+"Width",true,styles)}}}return val}function getWidthOrHeight(elem,name,extra){ // Start with offset property, which is equivalent to the border-box value
	var valueIsBorderBox=true,val=name==="width"?elem.offsetWidth:elem.offsetHeight,styles=getStyles(elem),isBorderBox=jQuery.css(elem,"boxSizing",false,styles)==="border-box"; // Some non-html elements return undefined for offsetWidth, so check for null/undefined
	// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
	// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
	if(val<=0||val==null){ // Fall back to computed then uncomputed css if necessary
	val=curCSS(elem,name,styles);if(val<0||val==null){val=elem.style[name]} // Computed unit is not pixels. Stop here and return.
	if(rnumnonpx.test(val)){return val} // Check for style in case a browser which returns unreliable values
	// for getComputedStyle silently falls back to the reliable elem.style
	valueIsBorderBox=isBorderBox&&(support.boxSizingReliable()||val===elem.style[name]); // Normalize "", auto, and prepare for extra
	val=parseFloat(val)||0} // Use the active box-sizing model to add/subtract irrelevant styles
	return val+augmentWidthOrHeight(elem,name,extra||(isBorderBox?"border":"content"),valueIsBorderBox,styles)+"px"}function showHide(elements,show){var display,elem,hidden,values=[],index=0,length=elements.length;for(;index<length;index++){elem=elements[index];if(!elem.style){continue}values[index]=data_priv.get(elem,"olddisplay");display=elem.style.display;if(show){ // Reset the inline display of this element to learn if it is
	// being hidden by cascaded rules or not
	if(!values[index]&&display==="none"){elem.style.display=""} // Set elements which have been overridden with display: none
	// in a stylesheet to whatever the default browser style is
	// for such an element
	if(elem.style.display===""&&isHidden(elem)){values[index]=data_priv.access(elem,"olddisplay",defaultDisplay(elem.nodeName))}}else {hidden=isHidden(elem);if(display!=="none"||!hidden){data_priv.set(elem,"olddisplay",hidden?display:jQuery.css(elem,"display"))}}} // Set the display of most of the elements in a second loop
	// to avoid the constant reflow
	for(index=0;index<length;index++){elem=elements[index];if(!elem.style){continue}if(!show||elem.style.display==="none"||elem.style.display===""){elem.style.display=show?values[index]||"":"none"}}return elements}jQuery.extend({ // Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks:{opacity:{get:function(elem,computed){if(computed){ // We should always get a number back from opacity
	var ret=curCSS(elem,"opacity");return ret===""?"1":ret}}}}, // Don't automatically add "px" to these possibly-unitless properties
	cssNumber:{"columnCount":true,"fillOpacity":true,"flexGrow":true,"flexShrink":true,"fontWeight":true,"lineHeight":true,"opacity":true,"order":true,"orphans":true,"widows":true,"zIndex":true,"zoom":true}, // Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps:{"float":"cssFloat"}, // Get and set the style property on a DOM Node
	style:function(elem,name,value,extra){ // Don't set styles on text and comment nodes
	if(!elem||elem.nodeType===3||elem.nodeType===8||!elem.style){return} // Make sure that we're working with the right name
	var ret,type,hooks,origName=jQuery.camelCase(name),style=elem.style;name=jQuery.cssProps[origName]||(jQuery.cssProps[origName]=vendorPropName(style,origName)); // Gets hook for the prefixed version, then unprefixed version
	hooks=jQuery.cssHooks[name]||jQuery.cssHooks[origName]; // Check if we're setting a value
	if(value!==undefined){type=typeof value; // Convert "+=" or "-=" to relative numbers (#7345)
	if(type==="string"&&(ret=rrelNum.exec(value))){value=(ret[1]+1)*ret[2]+parseFloat(jQuery.css(elem,name)); // Fixes bug #9237
	type="number"} // Make sure that null and NaN values aren't set (#7116)
	if(value==null||value!==value){return} // If a number, add 'px' to the (except for certain CSS properties)
	if(type==="number"&&!jQuery.cssNumber[origName]){value+="px"} // Support: IE9-11+
	// background-* props affect original clone's values
	if(!support.clearCloneStyle&&value===""&&name.indexOf("background")===0){style[name]="inherit"} // If a hook was provided, use that value, otherwise just set the specified value
	if(!hooks||!("set" in hooks)||(value=hooks.set(elem,value,extra))!==undefined){style[name]=value}}else { // If a hook was provided get the non-computed value from there
	if(hooks&&"get" in hooks&&(ret=hooks.get(elem,false,extra))!==undefined){return ret} // Otherwise just get the value from the style object
	return style[name]}},css:function(elem,name,extra,styles){var val,num,hooks,origName=jQuery.camelCase(name); // Make sure that we're working with the right name
	name=jQuery.cssProps[origName]||(jQuery.cssProps[origName]=vendorPropName(elem.style,origName)); // Try prefixed name followed by the unprefixed name
	hooks=jQuery.cssHooks[name]||jQuery.cssHooks[origName]; // If a hook was provided get the computed value from there
	if(hooks&&"get" in hooks){val=hooks.get(elem,true,extra)} // Otherwise, if a way to get the computed value exists, use that
	if(val===undefined){val=curCSS(elem,name,styles)} // Convert "normal" to computed value
	if(val==="normal"&&name in cssNormalTransform){val=cssNormalTransform[name]} // Make numeric if forced or a qualifier was provided and val looks numeric
	if(extra===""||extra){num=parseFloat(val);return extra===true||jQuery.isNumeric(num)?num||0:val}return val}});jQuery.each(["height","width"],function(i,name){jQuery.cssHooks[name]={get:function(elem,computed,extra){if(computed){ // Certain elements can have dimension info if we invisibly show them
	// but it must have a current display style that would benefit
	return rdisplayswap.test(jQuery.css(elem,"display"))&&elem.offsetWidth===0?jQuery.swap(elem,cssShow,function(){return getWidthOrHeight(elem,name,extra)}):getWidthOrHeight(elem,name,extra)}},set:function(elem,value,extra){var styles=extra&&getStyles(elem);return setPositiveNumber(elem,value,extra?augmentWidthOrHeight(elem,name,extra,jQuery.css(elem,"boxSizing",false,styles)==="border-box",styles):0)}}}); // Support: Android 2.3
	jQuery.cssHooks.marginRight=addGetHookIf(support.reliableMarginRight,function(elem,computed){if(computed){return jQuery.swap(elem,{"display":"inline-block"},curCSS,[elem,"marginRight"])}}); // These hooks are used by animate to expand properties
	jQuery.each({margin:"",padding:"",border:"Width"},function(prefix,suffix){jQuery.cssHooks[prefix+suffix]={expand:function(value){var i=0,expanded={}, // Assumes a single number if not a string
	parts=typeof value==="string"?value.split(" "):[value];for(;i<4;i++){expanded[prefix+cssExpand[i]+suffix]=parts[i]||parts[i-2]||parts[0]}return expanded}};if(!rmargin.test(prefix)){jQuery.cssHooks[prefix+suffix].set=setPositiveNumber}});jQuery.fn.extend({css:function(name,value){return access(this,function(elem,name,value){var styles,len,map={},i=0;if(jQuery.isArray(name)){styles=getStyles(elem);len=name.length;for(;i<len;i++){map[name[i]]=jQuery.css(elem,name[i],false,styles)}return map}return value!==undefined?jQuery.style(elem,name,value):jQuery.css(elem,name)},name,value,arguments.length>1)},show:function(){return showHide(this,true)},hide:function(){return showHide(this)},toggle:function(state){if(typeof state==="boolean"){return state?this.show():this.hide()}return this.each(function(){if(isHidden(this)){jQuery(this).show()}else {jQuery(this).hide()}})}});function Tween(elem,options,prop,end,easing){return new Tween.prototype.init(elem,options,prop,end,easing)}jQuery.Tween=Tween;Tween.prototype={constructor:Tween,init:function(elem,options,prop,end,easing,unit){this.elem=elem;this.prop=prop;this.easing=easing||"swing";this.options=options;this.start=this.now=this.cur();this.end=end;this.unit=unit||(jQuery.cssNumber[prop]?"":"px")},cur:function(){var hooks=Tween.propHooks[this.prop];return hooks&&hooks.get?hooks.get(this):Tween.propHooks._default.get(this)},run:function(percent){var eased,hooks=Tween.propHooks[this.prop];if(this.options.duration){this.pos=eased=jQuery.easing[this.easing](percent,this.options.duration*percent,0,1,this.options.duration)}else {this.pos=eased=percent}this.now=(this.end-this.start)*eased+this.start;if(this.options.step){this.options.step.call(this.elem,this.now,this)}if(hooks&&hooks.set){hooks.set(this)}else {Tween.propHooks._default.set(this)}return this}};Tween.prototype.init.prototype=Tween.prototype;Tween.propHooks={_default:{get:function(tween){var result;if(tween.elem[tween.prop]!=null&&(!tween.elem.style||tween.elem.style[tween.prop]==null)){return tween.elem[tween.prop]} // Passing an empty string as a 3rd parameter to .css will automatically
	// attempt a parseFloat and fallback to a string if the parse fails.
	// Simple values such as "10px" are parsed to Float;
	// complex values such as "rotate(1rad)" are returned as-is.
	result=jQuery.css(tween.elem,tween.prop,""); // Empty strings, null, undefined and "auto" are converted to 0.
	return !result||result==="auto"?0:result},set:function(tween){ // Use step hook for back compat.
	// Use cssHook if its there.
	// Use .style if available and use plain properties where available.
	if(jQuery.fx.step[tween.prop]){jQuery.fx.step[tween.prop](tween)}else if(tween.elem.style&&(tween.elem.style[jQuery.cssProps[tween.prop]]!=null||jQuery.cssHooks[tween.prop])){jQuery.style(tween.elem,tween.prop,tween.now+tween.unit)}else {tween.elem[tween.prop]=tween.now}}}}; // Support: IE9
	// Panic based approach to setting things on disconnected nodes
	Tween.propHooks.scrollTop=Tween.propHooks.scrollLeft={set:function(tween){if(tween.elem.nodeType&&tween.elem.parentNode){tween.elem[tween.prop]=tween.now}}};jQuery.easing={linear:function(p){return p},swing:function(p){return 0.5-Math.cos(p*Math.PI)/2}};jQuery.fx=Tween.prototype.init; // Back Compat <1.8 extension point
	jQuery.fx.step={};var fxNow,timerId,rfxtypes=/^(?:toggle|show|hide)$/,rfxnum=new RegExp("^(?:([+-])=|)("+pnum+")([a-z%]*)$","i"),rrun=/queueHooks$/,animationPrefilters=[defaultPrefilter],tweeners={"*":[function(prop,value){var tween=this.createTween(prop,value),target=tween.cur(),parts=rfxnum.exec(value),unit=parts&&parts[3]||(jQuery.cssNumber[prop]?"":"px"), // Starting value computation is required for potential unit mismatches
	start=(jQuery.cssNumber[prop]||unit!=="px"&&+target)&&rfxnum.exec(jQuery.css(tween.elem,prop)),scale=1,maxIterations=20;if(start&&start[3]!==unit){ // Trust units reported by jQuery.css
	unit=unit||start[3]; // Make sure we update the tween properties later on
	parts=parts||[]; // Iteratively approximate from a nonzero starting point
	start=+target||1;do { // If previous iteration zeroed out, double until we get *something*.
	// Use string for doubling so we don't accidentally see scale as unchanged below
	scale=scale||".5"; // Adjust and apply
	start=start/scale;jQuery.style(tween.elem,prop,start+unit); // Update scale, tolerating zero or NaN from tween.cur(),
	// break the loop if scale is unchanged or perfect, or if we've just had enough
	}while(scale!==(scale=tween.cur()/target)&&scale!==1&&--maxIterations)} // Update tween properties
	if(parts){start=tween.start=+start||+target||0;tween.unit=unit; // If a +=/-= token was provided, we're doing a relative animation
	tween.end=parts[1]?start+(parts[1]+1)*parts[2]:+parts[2]}return tween}]}; // Animations created synchronously will run synchronously
	function createFxNow(){setTimeout(function(){fxNow=undefined});return fxNow=jQuery.now()} // Generate parameters to create a standard animation
	function genFx(type,includeWidth){var which,i=0,attrs={height:type}; // If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth=includeWidth?1:0;for(;i<4;i+=2-includeWidth){which=cssExpand[i];attrs["margin"+which]=attrs["padding"+which]=type}if(includeWidth){attrs.opacity=attrs.width=type}return attrs}function createTween(value,prop,animation){var tween,collection=(tweeners[prop]||[]).concat(tweeners["*"]),index=0,length=collection.length;for(;index<length;index++){if(tween=collection[index].call(animation,prop,value)){ // We're done with this property
	return tween}}}function defaultPrefilter(elem,props,opts){ /* jshint validthis: true */var prop,value,toggle,tween,hooks,oldfire,display,checkDisplay,anim=this,orig={},style=elem.style,hidden=elem.nodeType&&isHidden(elem),dataShow=data_priv.get(elem,"fxshow"); // Handle queue: false promises
	if(!opts.queue){hooks=jQuery._queueHooks(elem,"fx");if(hooks.unqueued==null){hooks.unqueued=0;oldfire=hooks.empty.fire;hooks.empty.fire=function(){if(!hooks.unqueued){oldfire()}}}hooks.unqueued++;anim.always(function(){ // Ensure the complete handler is called before this completes
	anim.always(function(){hooks.unqueued--;if(!jQuery.queue(elem,"fx").length){hooks.empty.fire()}})})} // Height/width overflow pass
	if(elem.nodeType===1&&("height" in props||"width" in props)){ // Make sure that nothing sneaks out
	// Record all 3 overflow attributes because IE9-10 do not
	// change the overflow attribute when overflowX and
	// overflowY are set to the same value
	opts.overflow=[style.overflow,style.overflowX,style.overflowY]; // Set display property to inline-block for height/width
	// animations on inline elements that are having width/height animated
	display=jQuery.css(elem,"display"); // Test default display if display is currently "none"
	checkDisplay=display==="none"?data_priv.get(elem,"olddisplay")||defaultDisplay(elem.nodeName):display;if(checkDisplay==="inline"&&jQuery.css(elem,"float")==="none"){style.display="inline-block"}}if(opts.overflow){style.overflow="hidden";anim.always(function(){style.overflow=opts.overflow[0];style.overflowX=opts.overflow[1];style.overflowY=opts.overflow[2]})} // show/hide pass
	for(prop in props){value=props[prop];if(rfxtypes.exec(value)){delete props[prop];toggle=toggle||value==="toggle";if(value===(hidden?"hide":"show")){ // If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden
	if(value==="show"&&dataShow&&dataShow[prop]!==undefined){hidden=true}else {continue}}orig[prop]=dataShow&&dataShow[prop]||jQuery.style(elem,prop); // Any non-fx value stops us from restoring the original display value
	}else {display=undefined}}if(!jQuery.isEmptyObject(orig)){if(dataShow){if("hidden" in dataShow){hidden=dataShow.hidden}}else {dataShow=data_priv.access(elem,"fxshow",{})} // Store state if its toggle - enables .stop().toggle() to "reverse"
	if(toggle){dataShow.hidden=!hidden}if(hidden){jQuery(elem).show()}else {anim.done(function(){jQuery(elem).hide()})}anim.done(function(){var prop;data_priv.remove(elem,"fxshow");for(prop in orig){jQuery.style(elem,prop,orig[prop])}});for(prop in orig){tween=createTween(hidden?dataShow[prop]:0,prop,anim);if(!(prop in dataShow)){dataShow[prop]=tween.start;if(hidden){tween.end=tween.start;tween.start=prop==="width"||prop==="height"?1:0}}} // If this is a noop like .hide().hide(), restore an overwritten display value
	}else if((display==="none"?defaultDisplay(elem.nodeName):display)==="inline"){style.display=display}}function propFilter(props,specialEasing){var index,name,easing,value,hooks; // camelCase, specialEasing and expand cssHook pass
	for(index in props){name=jQuery.camelCase(index);easing=specialEasing[name];value=props[index];if(jQuery.isArray(value)){easing=value[1];value=props[index]=value[0]}if(index!==name){props[name]=value;delete props[index]}hooks=jQuery.cssHooks[name];if(hooks&&"expand" in hooks){value=hooks.expand(value);delete props[name]; // Not quite $.extend, this won't overwrite existing keys.
	// Reusing 'index' because we have the correct "name"
	for(index in value){if(!(index in props)){props[index]=value[index];specialEasing[index]=easing}}}else {specialEasing[name]=easing}}}function Animation(elem,properties,options){var result,stopped,index=0,length=animationPrefilters.length,deferred=jQuery.Deferred().always(function(){ // Don't match elem in the :animated selector
	delete tick.elem}),tick=function(){if(stopped){return false}var currentTime=fxNow||createFxNow(),remaining=Math.max(0,animation.startTime+animation.duration-currentTime), // Support: Android 2.3
	// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
	temp=remaining/animation.duration||0,percent=1-temp,index=0,length=animation.tweens.length;for(;index<length;index++){animation.tweens[index].run(percent)}deferred.notifyWith(elem,[animation,percent,remaining]);if(percent<1&&length){return remaining}else {deferred.resolveWith(elem,[animation]);return false}},animation=deferred.promise({elem:elem,props:jQuery.extend({},properties),opts:jQuery.extend(true,{specialEasing:{}},options),originalProperties:properties,originalOptions:options,startTime:fxNow||createFxNow(),duration:options.duration,tweens:[],createTween:function(prop,end){var tween=jQuery.Tween(elem,animation.opts,prop,end,animation.opts.specialEasing[prop]||animation.opts.easing);animation.tweens.push(tween);return tween},stop:function(gotoEnd){var index=0, // If we are going to the end, we want to run all the tweens
	// otherwise we skip this part
	length=gotoEnd?animation.tweens.length:0;if(stopped){return this}stopped=true;for(;index<length;index++){animation.tweens[index].run(1)} // Resolve when we played the last frame; otherwise, reject
	if(gotoEnd){deferred.resolveWith(elem,[animation,gotoEnd])}else {deferred.rejectWith(elem,[animation,gotoEnd])}return this}}),props=animation.props;propFilter(props,animation.opts.specialEasing);for(;index<length;index++){result=animationPrefilters[index].call(animation,elem,props,animation.opts);if(result){return result}}jQuery.map(props,createTween,animation);if(jQuery.isFunction(animation.opts.start)){animation.opts.start.call(elem,animation)}jQuery.fx.timer(jQuery.extend(tick,{elem:elem,anim:animation,queue:animation.opts.queue})); // attach callbacks from options
	return animation.progress(animation.opts.progress).done(animation.opts.done,animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always)}jQuery.Animation=jQuery.extend(Animation,{tweener:function(props,callback){if(jQuery.isFunction(props)){callback=props;props=["*"]}else {props=props.split(" ")}var prop,index=0,length=props.length;for(;index<length;index++){prop=props[index];tweeners[prop]=tweeners[prop]||[];tweeners[prop].unshift(callback)}},prefilter:function(callback,prepend){if(prepend){animationPrefilters.unshift(callback)}else {animationPrefilters.push(callback)}}});jQuery.speed=function(speed,easing,fn){var opt=speed&&typeof speed==="object"?jQuery.extend({},speed):{complete:fn||!fn&&easing||jQuery.isFunction(speed)&&speed,duration:speed,easing:fn&&easing||easing&&!jQuery.isFunction(easing)&&easing};opt.duration=jQuery.fx.off?0:typeof opt.duration==="number"?opt.duration:opt.duration in jQuery.fx.speeds?jQuery.fx.speeds[opt.duration]:jQuery.fx.speeds._default; // Normalize opt.queue - true/undefined/null -> "fx"
	if(opt.queue==null||opt.queue===true){opt.queue="fx"} // Queueing
	opt.old=opt.complete;opt.complete=function(){if(jQuery.isFunction(opt.old)){opt.old.call(this)}if(opt.queue){jQuery.dequeue(this,opt.queue)}};return opt};jQuery.fn.extend({fadeTo:function(speed,to,easing,callback){ // Show any hidden elements after setting opacity to 0
	return this.filter(isHidden).css("opacity",0).show() // Animate to the value specified
	.end().animate({opacity:to},speed,easing,callback)},animate:function(prop,speed,easing,callback){var empty=jQuery.isEmptyObject(prop),optall=jQuery.speed(speed,easing,callback),doAnimation=function(){ // Operate on a copy of prop so per-property easing won't be lost
	var anim=Animation(this,jQuery.extend({},prop),optall); // Empty animations, or finishing resolves immediately
	if(empty||data_priv.get(this,"finish")){anim.stop(true)}};doAnimation.finish=doAnimation;return empty||optall.queue===false?this.each(doAnimation):this.queue(optall.queue,doAnimation)},stop:function(type,clearQueue,gotoEnd){var stopQueue=function(hooks){var stop=hooks.stop;delete hooks.stop;stop(gotoEnd)};if(typeof type!=="string"){gotoEnd=clearQueue;clearQueue=type;type=undefined}if(clearQueue&&type!==false){this.queue(type||"fx",[])}return this.each(function(){var dequeue=true,index=type!=null&&type+"queueHooks",timers=jQuery.timers,data=data_priv.get(this);if(index){if(data[index]&&data[index].stop){stopQueue(data[index])}}else {for(index in data){if(data[index]&&data[index].stop&&rrun.test(index)){stopQueue(data[index])}}}for(index=timers.length;index--;){if(timers[index].elem===this&&(type==null||timers[index].queue===type)){timers[index].anim.stop(gotoEnd);dequeue=false;timers.splice(index,1)}} // Start the next in the queue if the last step wasn't forced.
	// Timers currently will call their complete callbacks, which
	// will dequeue but only if they were gotoEnd.
	if(dequeue||!gotoEnd){jQuery.dequeue(this,type)}})},finish:function(type){if(type!==false){type=type||"fx"}return this.each(function(){var index,data=data_priv.get(this),queue=data[type+"queue"],hooks=data[type+"queueHooks"],timers=jQuery.timers,length=queue?queue.length:0; // Enable finishing flag on private data
	data.finish=true; // Empty the queue first
	jQuery.queue(this,type,[]);if(hooks&&hooks.stop){hooks.stop.call(this,true)} // Look for any active animations, and finish them
	for(index=timers.length;index--;){if(timers[index].elem===this&&timers[index].queue===type){timers[index].anim.stop(true);timers.splice(index,1)}} // Look for any animations in the old queue and finish them
	for(index=0;index<length;index++){if(queue[index]&&queue[index].finish){queue[index].finish.call(this)}} // Turn off finishing flag
	delete data.finish})}});jQuery.each(["toggle","show","hide"],function(i,name){var cssFn=jQuery.fn[name];jQuery.fn[name]=function(speed,easing,callback){return speed==null||typeof speed==="boolean"?cssFn.apply(this,arguments):this.animate(genFx(name,true),speed,easing,callback)}}); // Generate shortcuts for custom animations
	jQuery.each({slideDown:genFx("show"),slideUp:genFx("hide"),slideToggle:genFx("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(name,props){jQuery.fn[name]=function(speed,easing,callback){return this.animate(props,speed,easing,callback)}});jQuery.timers=[];jQuery.fx.tick=function(){var timer,i=0,timers=jQuery.timers;fxNow=jQuery.now();for(;i<timers.length;i++){timer=timers[i]; // Checks the timer has not already been removed
	if(!timer()&&timers[i]===timer){timers.splice(i--,1)}}if(!timers.length){jQuery.fx.stop()}fxNow=undefined};jQuery.fx.timer=function(timer){jQuery.timers.push(timer);if(timer()){jQuery.fx.start()}else {jQuery.timers.pop()}};jQuery.fx.interval=13;jQuery.fx.start=function(){if(!timerId){timerId=setInterval(jQuery.fx.tick,jQuery.fx.interval)}};jQuery.fx.stop=function(){clearInterval(timerId);timerId=null};jQuery.fx.speeds={slow:600,fast:200, // Default speed
	_default:400}; // Based off of the plugin by Clint Helfers, with permission.
	// http://blindsignals.com/index.php/2009/07/jquery-delay/
	jQuery.fn.delay=function(time,type){time=jQuery.fx?jQuery.fx.speeds[time]||time:time;type=type||"fx";return this.queue(type,function(next,hooks){var timeout=setTimeout(next,time);hooks.stop=function(){clearTimeout(timeout)}})};(function(){var input=document.createElement("input"),select=document.createElement("select"),opt=select.appendChild(document.createElement("option"));input.type="checkbox"; // Support: iOS<=5.1, Android<=4.2+
	// Default value for a checkbox should be "on"
	support.checkOn=input.value!==""; // Support: IE<=11+
	// Must access selectedIndex to make default options select
	support.optSelected=opt.selected; // Support: Android<=2.3
	// Options inside disabled selects are incorrectly marked as disabled
	select.disabled=true;support.optDisabled=!opt.disabled; // Support: IE<=11+
	// An input loses its value after becoming a radio
	input=document.createElement("input");input.value="t";input.type="radio";support.radioValue=input.value==="t"})();var nodeHook,boolHook,attrHandle=jQuery.expr.attrHandle;jQuery.fn.extend({attr:function(name,value){return access(this,jQuery.attr,name,value,arguments.length>1)},removeAttr:function(name){return this.each(function(){jQuery.removeAttr(this,name)})}});jQuery.extend({attr:function(elem,name,value){var hooks,ret,nType=elem.nodeType; // don't get/set attributes on text, comment and attribute nodes
	if(!elem||nType===3||nType===8||nType===2){return} // Fallback to prop when attributes are not supported
	if(typeof elem.getAttribute===strundefined){return jQuery.prop(elem,name,value)} // All attributes are lowercase
	// Grab necessary hook if one is defined
	if(nType!==1||!jQuery.isXMLDoc(elem)){name=name.toLowerCase();hooks=jQuery.attrHooks[name]||(jQuery.expr.match.bool.test(name)?boolHook:nodeHook)}if(value!==undefined){if(value===null){jQuery.removeAttr(elem,name)}else if(hooks&&"set" in hooks&&(ret=hooks.set(elem,value,name))!==undefined){return ret}else {elem.setAttribute(name,value+"");return value}}else if(hooks&&"get" in hooks&&(ret=hooks.get(elem,name))!==null){return ret}else {ret=jQuery.find.attr(elem,name); // Non-existent attributes return null, we normalize to undefined
	return ret==null?undefined:ret}},removeAttr:function(elem,value){var name,propName,i=0,attrNames=value&&value.match(rnotwhite);if(attrNames&&elem.nodeType===1){while(name=attrNames[i++]){propName=jQuery.propFix[name]||name; // Boolean attributes get special treatment (#10870)
	if(jQuery.expr.match.bool.test(name)){ // Set corresponding property to false
	elem[propName]=false}elem.removeAttribute(name)}}},attrHooks:{type:{set:function(elem,value){if(!support.radioValue&&value==="radio"&&jQuery.nodeName(elem,"input")){var val=elem.value;elem.setAttribute("type",value);if(val){elem.value=val}return value}}}}}); // Hooks for boolean attributes
	boolHook={set:function(elem,value,name){if(value===false){ // Remove boolean attributes when set to false
	jQuery.removeAttr(elem,name)}else {elem.setAttribute(name,name)}return name}};jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g),function(i,name){var getter=attrHandle[name]||jQuery.find.attr;attrHandle[name]=function(elem,name,isXML){var ret,handle;if(!isXML){ // Avoid an infinite loop by temporarily removing this function from the getter
	handle=attrHandle[name];attrHandle[name]=ret;ret=getter(elem,name,isXML)!=null?name.toLowerCase():null;attrHandle[name]=handle}return ret}});var rfocusable=/^(?:input|select|textarea|button)$/i;jQuery.fn.extend({prop:function(name,value){return access(this,jQuery.prop,name,value,arguments.length>1)},removeProp:function(name){return this.each(function(){delete this[jQuery.propFix[name]||name]})}});jQuery.extend({propFix:{"for":"htmlFor","class":"className"},prop:function(elem,name,value){var ret,hooks,notxml,nType=elem.nodeType; // Don't get/set properties on text, comment and attribute nodes
	if(!elem||nType===3||nType===8||nType===2){return}notxml=nType!==1||!jQuery.isXMLDoc(elem);if(notxml){ // Fix name and attach hooks
	name=jQuery.propFix[name]||name;hooks=jQuery.propHooks[name]}if(value!==undefined){return hooks&&"set" in hooks&&(ret=hooks.set(elem,value,name))!==undefined?ret:elem[name]=value}else {return hooks&&"get" in hooks&&(ret=hooks.get(elem,name))!==null?ret:elem[name]}},propHooks:{tabIndex:{get:function(elem){return elem.hasAttribute("tabindex")||rfocusable.test(elem.nodeName)||elem.href?elem.tabIndex:-1}}}});if(!support.optSelected){jQuery.propHooks.selected={get:function(elem){var parent=elem.parentNode;if(parent&&parent.parentNode){parent.parentNode.selectedIndex}return null}}}jQuery.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){jQuery.propFix[this.toLowerCase()]=this});var rclass=/[\t\r\n\f]/g;jQuery.fn.extend({addClass:function(value){var classes,elem,cur,clazz,j,finalValue,proceed=typeof value==="string"&&value,i=0,len=this.length;if(jQuery.isFunction(value)){return this.each(function(j){jQuery(this).addClass(value.call(this,j,this.className))})}if(proceed){ // The disjunction here is for better compressibility (see removeClass)
	classes=(value||"").match(rnotwhite)||[];for(;i<len;i++){elem=this[i];cur=elem.nodeType===1&&(elem.className?(" "+elem.className+" ").replace(rclass," "):" ");if(cur){j=0;while(clazz=classes[j++]){if(cur.indexOf(" "+clazz+" ")<0){cur+=clazz+" "}} // only assign if different to avoid unneeded rendering.
	finalValue=jQuery.trim(cur);if(elem.className!==finalValue){elem.className=finalValue}}}}return this},removeClass:function(value){var classes,elem,cur,clazz,j,finalValue,proceed=arguments.length===0||typeof value==="string"&&value,i=0,len=this.length;if(jQuery.isFunction(value)){return this.each(function(j){jQuery(this).removeClass(value.call(this,j,this.className))})}if(proceed){classes=(value||"").match(rnotwhite)||[];for(;i<len;i++){elem=this[i]; // This expression is here for better compressibility (see addClass)
	cur=elem.nodeType===1&&(elem.className?(" "+elem.className+" ").replace(rclass," "):"");if(cur){j=0;while(clazz=classes[j++]){ // Remove *all* instances
	while(cur.indexOf(" "+clazz+" ")>=0){cur=cur.replace(" "+clazz+" "," ")}} // Only assign if different to avoid unneeded rendering.
	finalValue=value?jQuery.trim(cur):"";if(elem.className!==finalValue){elem.className=finalValue}}}}return this},toggleClass:function(value,stateVal){var type=typeof value;if(typeof stateVal==="boolean"&&type==="string"){return stateVal?this.addClass(value):this.removeClass(value)}if(jQuery.isFunction(value)){return this.each(function(i){jQuery(this).toggleClass(value.call(this,i,this.className,stateVal),stateVal)})}return this.each(function(){if(type==="string"){ // Toggle individual class names
	var className,i=0,self=jQuery(this),classNames=value.match(rnotwhite)||[];while(className=classNames[i++]){ // Check each className given, space separated list
	if(self.hasClass(className)){self.removeClass(className)}else {self.addClass(className)}} // Toggle whole class name
	}else if(type===strundefined||type==="boolean"){if(this.className){ // store className if set
	data_priv.set(this,"__className__",this.className)} // If the element has a class name or if we're passed `false`,
	// then remove the whole classname (if there was one, the above saved it).
	// Otherwise bring back whatever was previously saved (if anything),
	// falling back to the empty string if nothing was stored.
	this.className=this.className||value===false?"":data_priv.get(this,"__className__")||""}})},hasClass:function(selector){var className=" "+selector+" ",i=0,l=this.length;for(;i<l;i++){if(this[i].nodeType===1&&(" "+this[i].className+" ").replace(rclass," ").indexOf(className)>=0){return true}}return false}});var rreturn=/\r/g;jQuery.fn.extend({val:function(value){var hooks,ret,isFunction,elem=this[0];if(!arguments.length){if(elem){hooks=jQuery.valHooks[elem.type]||jQuery.valHooks[elem.nodeName.toLowerCase()];if(hooks&&"get" in hooks&&(ret=hooks.get(elem,"value"))!==undefined){return ret}ret=elem.value;return typeof ret==="string"? // Handle most common string cases
	ret.replace(rreturn,""): // Handle cases where value is null/undef or number
	ret==null?"":ret}return}isFunction=jQuery.isFunction(value);return this.each(function(i){var val;if(this.nodeType!==1){return}if(isFunction){val=value.call(this,i,jQuery(this).val())}else {val=value} // Treat null/undefined as ""; convert numbers to string
	if(val==null){val=""}else if(typeof val==="number"){val+=""}else if(jQuery.isArray(val)){val=jQuery.map(val,function(value){return value==null?"":value+""})}hooks=jQuery.valHooks[this.type]||jQuery.valHooks[this.nodeName.toLowerCase()]; // If set returns undefined, fall back to normal setting
	if(!hooks||!("set" in hooks)||hooks.set(this,val,"value")===undefined){this.value=val}})}});jQuery.extend({valHooks:{option:{get:function(elem){var val=jQuery.find.attr(elem,"value");return val!=null?val: // Support: IE10-11+
	// option.text throws exceptions (#14686, #14858)
	jQuery.trim(jQuery.text(elem))}},select:{get:function(elem){var value,option,options=elem.options,index=elem.selectedIndex,one=elem.type==="select-one"||index<0,values=one?null:[],max=one?index+1:options.length,i=index<0?max:one?index:0; // Loop through all the selected options
	for(;i<max;i++){option=options[i]; // IE6-9 doesn't update selected after form reset (#2551)
	if((option.selected||i===index)&&( // Don't return options that are disabled or in a disabled optgroup
	support.optDisabled?!option.disabled:option.getAttribute("disabled")===null)&&(!option.parentNode.disabled||!jQuery.nodeName(option.parentNode,"optgroup"))){ // Get the specific value for the option
	value=jQuery(option).val(); // We don't need an array for one selects
	if(one){return value} // Multi-Selects return an array
	values.push(value)}}return values},set:function(elem,value){var optionSet,option,options=elem.options,values=jQuery.makeArray(value),i=options.length;while(i--){option=options[i];if(option.selected=jQuery.inArray(option.value,values)>=0){optionSet=true}} // Force browsers to behave consistently when non-matching value is set
	if(!optionSet){elem.selectedIndex=-1}return values}}}}); // Radios and checkboxes getter/setter
	jQuery.each(["radio","checkbox"],function(){jQuery.valHooks[this]={set:function(elem,value){if(jQuery.isArray(value)){return elem.checked=jQuery.inArray(jQuery(elem).val(),value)>=0}}};if(!support.checkOn){jQuery.valHooks[this].get=function(elem){return elem.getAttribute("value")===null?"on":elem.value}}}); // Return jQuery for attributes-only inclusion
	jQuery.each(("blur focus focusin focusout load resize scroll unload click dblclick "+"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave "+"change select submit keydown keypress keyup error contextmenu").split(" "),function(i,name){ // Handle event binding
	jQuery.fn[name]=function(data,fn){return arguments.length>0?this.on(name,null,data,fn):this.trigger(name)}});jQuery.fn.extend({hover:function(fnOver,fnOut){return this.mouseenter(fnOver).mouseleave(fnOut||fnOver)},bind:function(types,data,fn){return this.on(types,null,data,fn)},unbind:function(types,fn){return this.off(types,null,fn)},delegate:function(selector,types,data,fn){return this.on(types,selector,data,fn)},undelegate:function(selector,types,fn){ // ( namespace ) or ( selector, types [, fn] )
	return arguments.length===1?this.off(selector,"**"):this.off(types,selector||"**",fn)}});var nonce=jQuery.now();var rquery=/\?/; // Support: Android 2.3
	// Workaround failure to string-cast null input
	jQuery.parseJSON=function(data){return JSON.parse(data+"")}; // Cross-browser xml parsing
	jQuery.parseXML=function(data){var xml,tmp;if(!data||typeof data!=="string"){return null} // Support: IE9
	try{tmp=new DOMParser;xml=tmp.parseFromString(data,"text/xml")}catch(e) {xml=undefined}if(!xml||xml.getElementsByTagName("parsererror").length){jQuery.error("Invalid XML: "+data)}return xml};var rhash=/#.*$/,rts=/([?&])_=[^&]*/,rheaders=/^(.*?):[ \t]*([^\r\n]*)$/mg, // #7653, #8125, #8152: local protocol detection
	rlocalProtocol=/^(?:about|app|app-storage|.+-extension|file|res|widget):$/,rnoContent=/^(?:GET|HEAD)$/,rprotocol=/^\/\//,rurl=/^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/, /* Prefilters
		 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
		 * 2) These are called:
		 *    - BEFORE asking for a transport
		 *    - AFTER param serialization (s.data is a string if s.processData is true)
		 * 3) key is the dataType
		 * 4) the catchall symbol "*" can be used
		 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
		 */prefilters={}, /* Transports bindings
		 * 1) key is the dataType
		 * 2) the catchall symbol "*" can be used
		 * 3) selection will start with transport dataType and THEN go to "*" if needed
		 */transports={}, // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes="*/".concat("*"), // Document location
	ajaxLocation=window.location.href, // Segment location into parts
	ajaxLocParts=rurl.exec(ajaxLocation.toLowerCase())||[]; // Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
	function addToPrefiltersOrTransports(structure){ // dataTypeExpression is optional and defaults to "*"
	return function(dataTypeExpression,func){if(typeof dataTypeExpression!=="string"){func=dataTypeExpression;dataTypeExpression="*"}var dataType,i=0,dataTypes=dataTypeExpression.toLowerCase().match(rnotwhite)||[];if(jQuery.isFunction(func)){ // For each dataType in the dataTypeExpression
	while(dataType=dataTypes[i++]){ // Prepend if requested
	if(dataType[0]==="+"){dataType=dataType.slice(1)||"*";(structure[dataType]=structure[dataType]||[]).unshift(func); // Otherwise append
	}else {(structure[dataType]=structure[dataType]||[]).push(func)}}}}} // Base inspection function for prefilters and transports
	function inspectPrefiltersOrTransports(structure,options,originalOptions,jqXHR){var inspected={},seekingTransport=structure===transports;function inspect(dataType){var selected;inspected[dataType]=true;jQuery.each(structure[dataType]||[],function(_,prefilterOrFactory){var dataTypeOrTransport=prefilterOrFactory(options,originalOptions,jqXHR);if(typeof dataTypeOrTransport==="string"&&!seekingTransport&&!inspected[dataTypeOrTransport]){options.dataTypes.unshift(dataTypeOrTransport);inspect(dataTypeOrTransport);return false}else if(seekingTransport){return !(selected=dataTypeOrTransport)}});return selected}return inspect(options.dataTypes[0])||!inspected["*"]&&inspect("*")} // A special extend for ajax options
	// that takes "flat" options (not to be deep extended)
	// Fixes #9887
	function ajaxExtend(target,src){var key,deep,flatOptions=jQuery.ajaxSettings.flatOptions||{};for(key in src){if(src[key]!==undefined){(flatOptions[key]?target:deep||(deep={}))[key]=src[key]}}if(deep){jQuery.extend(true,target,deep)}return target} /* Handles responses to an ajax request:
	 * - finds the right dataType (mediates between content-type and expected dataType)
	 * - returns the corresponding response
	 */function ajaxHandleResponses(s,jqXHR,responses){var ct,type,finalDataType,firstDataType,contents=s.contents,dataTypes=s.dataTypes; // Remove auto dataType and get content-type in the process
	while(dataTypes[0]==="*"){dataTypes.shift();if(ct===undefined){ct=s.mimeType||jqXHR.getResponseHeader("Content-Type")}} // Check if we're dealing with a known content-type
	if(ct){for(type in contents){if(contents[type]&&contents[type].test(ct)){dataTypes.unshift(type);break}}} // Check to see if we have a response for the expected dataType
	if(dataTypes[0] in responses){finalDataType=dataTypes[0]}else { // Try convertible dataTypes
	for(type in responses){if(!dataTypes[0]||s.converters[type+" "+dataTypes[0]]){finalDataType=type;break}if(!firstDataType){firstDataType=type}} // Or just use first one
	finalDataType=finalDataType||firstDataType} // If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if(finalDataType){if(finalDataType!==dataTypes[0]){dataTypes.unshift(finalDataType)}return responses[finalDataType]}} /* Chain conversions given the request and the original response
	 * Also sets the responseXXX fields on the jqXHR instance
	 */function ajaxConvert(s,response,jqXHR,isSuccess){var conv2,current,conv,tmp,prev,converters={}, // Work with a copy of dataTypes in case we need to modify it for conversion
	dataTypes=s.dataTypes.slice(); // Create converters map with lowercased keys
	if(dataTypes[1]){for(conv in s.converters){converters[conv.toLowerCase()]=s.converters[conv]}}current=dataTypes.shift(); // Convert to each sequential dataType
	while(current){if(s.responseFields[current]){jqXHR[s.responseFields[current]]=response} // Apply the dataFilter if provided
	if(!prev&&isSuccess&&s.dataFilter){response=s.dataFilter(response,s.dataType)}prev=current;current=dataTypes.shift();if(current){ // There's only work to do if current dataType is non-auto
	if(current==="*"){current=prev; // Convert response if prev dataType is non-auto and differs from current
	}else if(prev!=="*"&&prev!==current){ // Seek a direct converter
	conv=converters[prev+" "+current]||converters["* "+current]; // If none found, seek a pair
	if(!conv){for(conv2 in converters){ // If conv2 outputs current
	tmp=conv2.split(" ");if(tmp[1]===current){ // If prev can be converted to accepted input
	conv=converters[prev+" "+tmp[0]]||converters["* "+tmp[0]];if(conv){ // Condense equivalence converters
	if(conv===true){conv=converters[conv2]; // Otherwise, insert the intermediate dataType
	}else if(converters[conv2]!==true){current=tmp[0];dataTypes.unshift(tmp[1])}break}}}} // Apply converter (if not an equivalence)
	if(conv!==true){ // Unless errors are allowed to bubble, catch and return them
	if(conv&&s["throws"]){response=conv(response)}else {try{response=conv(response)}catch(e) {return {state:"parsererror",error:conv?e:"No conversion from "+prev+" to "+current}}}}}}}return {state:"success",data:response}}jQuery.extend({ // Counter for holding the number of active queries
	active:0, // Last-Modified header cache for next request
	lastModified:{},etag:{},ajaxSettings:{url:ajaxLocation,type:"GET",isLocal:rlocalProtocol.test(ajaxLocParts[1]),global:true,processData:true,async:true,contentType:"application/x-www-form-urlencoded; charset=UTF-8", /*
			timeout: 0,
			data: null,
			dataType: null,
			username: null,
			password: null,
			cache: null,
			throws: false,
			traditional: false,
			headers: {},
			*/accepts:{"*":allTypes,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/xml/,html:/html/,json:/json/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"}, // Data converters
	// Keys separate source (or catchall "*") and destination types with a single space
	converters:{ // Convert anything to text
	"* text":String, // Text to html (true = no transformation)
	"text html":true, // Evaluate text as a json expression
	"text json":jQuery.parseJSON, // Parse text as xml
	"text xml":jQuery.parseXML}, // For options that shouldn't be deep extended:
	// you can add your own custom options here if
	// and when you create one that shouldn't be
	// deep extended (see ajaxExtend)
	flatOptions:{url:true,context:true}}, // Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup:function(target,settings){return settings? // Building a settings object
	ajaxExtend(ajaxExtend(target,jQuery.ajaxSettings),settings): // Extending ajaxSettings
	ajaxExtend(jQuery.ajaxSettings,target)},ajaxPrefilter:addToPrefiltersOrTransports(prefilters),ajaxTransport:addToPrefiltersOrTransports(transports), // Main method
	ajax:function(url,options){ // If url is an object, simulate pre-1.5 signature
	if(typeof url==="object"){options=url;url=undefined} // Force options to be an object
	options=options||{};var transport, // URL without anti-cache param
	cacheURL, // Response headers
	responseHeadersString,responseHeaders, // timeout handle
	timeoutTimer, // Cross-domain detection vars
	parts, // To know if global events are to be dispatched
	fireGlobals, // Loop variable
	i, // Create the final options object
	s=jQuery.ajaxSetup({},options), // Callbacks context
	callbackContext=s.context||s, // Context for global events is callbackContext if it is a DOM node or jQuery collection
	globalEventContext=s.context&&(callbackContext.nodeType||callbackContext.jquery)?jQuery(callbackContext):jQuery.event, // Deferreds
	deferred=jQuery.Deferred(),completeDeferred=jQuery.Callbacks("once memory"), // Status-dependent callbacks
	statusCode=s.statusCode||{}, // Headers (they are sent all at once)
	requestHeaders={},requestHeadersNames={}, // The jqXHR state
	state=0, // Default abort message
	strAbort="canceled", // Fake xhr
	jqXHR={readyState:0, // Builds headers hashtable if needed
	getResponseHeader:function(key){var match;if(state===2){if(!responseHeaders){responseHeaders={};while(match=rheaders.exec(responseHeadersString)){responseHeaders[match[1].toLowerCase()]=match[2]}}match=responseHeaders[key.toLowerCase()]}return match==null?null:match}, // Raw string
	getAllResponseHeaders:function(){return state===2?responseHeadersString:null}, // Caches the header
	setRequestHeader:function(name,value){var lname=name.toLowerCase();if(!state){name=requestHeadersNames[lname]=requestHeadersNames[lname]||name;requestHeaders[name]=value}return this}, // Overrides response content-type header
	overrideMimeType:function(type){if(!state){s.mimeType=type}return this}, // Status-dependent callbacks
	statusCode:function(map){var code;if(map){if(state<2){for(code in map){ // Lazy-add the new callback in a way that preserves old ones
	statusCode[code]=[statusCode[code],map[code]]}}else { // Execute the appropriate callbacks
	jqXHR.always(map[jqXHR.status])}}return this}, // Cancel the request
	abort:function(statusText){var finalText=statusText||strAbort;if(transport){transport.abort(finalText)}done(0,finalText);return this}}; // Attach deferreds
	deferred.promise(jqXHR).complete=completeDeferred.add;jqXHR.success=jqXHR.done;jqXHR.error=jqXHR.fail; // Remove hash character (#7531: and string promotion)
	// Add protocol if not provided (prefilters might expect it)
	// Handle falsy url in the settings object (#10093: consistency with old signature)
	// We also use the url parameter if available
	s.url=((url||s.url||ajaxLocation)+"").replace(rhash,"").replace(rprotocol,ajaxLocParts[1]+"//"); // Alias method option to type as per ticket #12004
	s.type=options.method||options.type||s.method||s.type; // Extract dataTypes list
	s.dataTypes=jQuery.trim(s.dataType||"*").toLowerCase().match(rnotwhite)||[""]; // A cross-domain request is in order when we have a protocol:host:port mismatch
	if(s.crossDomain==null){parts=rurl.exec(s.url.toLowerCase());s.crossDomain=!!(parts&&(parts[1]!==ajaxLocParts[1]||parts[2]!==ajaxLocParts[2]||(parts[3]||(parts[1]==="http:"?"80":"443"))!==(ajaxLocParts[3]||(ajaxLocParts[1]==="http:"?"80":"443"))))} // Convert data if not already a string
	if(s.data&&s.processData&&typeof s.data!=="string"){s.data=jQuery.param(s.data,s.traditional)} // Apply prefilters
	inspectPrefiltersOrTransports(prefilters,s,options,jqXHR); // If request was aborted inside a prefilter, stop there
	if(state===2){return jqXHR} // We can fire global events as of now if asked to
	// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
	fireGlobals=jQuery.event&&s.global; // Watch for a new set of requests
	if(fireGlobals&&jQuery.active++===0){jQuery.event.trigger("ajaxStart")} // Uppercase the type
	s.type=s.type.toUpperCase(); // Determine if request has content
	s.hasContent=!rnoContent.test(s.type); // Save the URL in case we're toying with the If-Modified-Since
	// and/or If-None-Match header later on
	cacheURL=s.url; // More options handling for requests with no content
	if(!s.hasContent){ // If data is available, append data to url
	if(s.data){cacheURL=s.url+=(rquery.test(cacheURL)?"&":"?")+s.data; // #9682: remove data so that it's not used in an eventual retry
	delete s.data} // Add anti-cache in url if needed
	if(s.cache===false){s.url=rts.test(cacheURL)? // If there is already a '_' parameter, set its value
	cacheURL.replace(rts,"$1_="+nonce++): // Otherwise add one to the end
	cacheURL+(rquery.test(cacheURL)?"&":"?")+"_="+nonce++}} // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
	if(s.ifModified){if(jQuery.lastModified[cacheURL]){jqXHR.setRequestHeader("If-Modified-Since",jQuery.lastModified[cacheURL])}if(jQuery.etag[cacheURL]){jqXHR.setRequestHeader("If-None-Match",jQuery.etag[cacheURL])}} // Set the correct header, if data is being sent
	if(s.data&&s.hasContent&&s.contentType!==false||options.contentType){jqXHR.setRequestHeader("Content-Type",s.contentType)} // Set the Accepts header for the server, depending on the dataType
	jqXHR.setRequestHeader("Accept",s.dataTypes[0]&&s.accepts[s.dataTypes[0]]?s.accepts[s.dataTypes[0]]+(s.dataTypes[0]!=="*"?", "+allTypes+"; q=0.01":""):s.accepts["*"]); // Check for headers option
	for(i in s.headers){jqXHR.setRequestHeader(i,s.headers[i])} // Allow custom headers/mimetypes and early abort
	if(s.beforeSend&&(s.beforeSend.call(callbackContext,jqXHR,s)===false||state===2)){ // Abort if not done already and return
	return jqXHR.abort()} // Aborting is no longer a cancellation
	strAbort="abort"; // Install callbacks on deferreds
	for(i in {success:1,error:1,complete:1}){jqXHR[i](s[i])} // Get transport
	transport=inspectPrefiltersOrTransports(transports,s,options,jqXHR); // If no transport, we auto-abort
	if(!transport){done(-1,"No Transport")}else {jqXHR.readyState=1; // Send global event
	if(fireGlobals){globalEventContext.trigger("ajaxSend",[jqXHR,s])} // Timeout
	if(s.async&&s.timeout>0){timeoutTimer=setTimeout(function(){jqXHR.abort("timeout")},s.timeout)}try{state=1;transport.send(requestHeaders,done)}catch(e) { // Propagate exception as error if not done
	if(state<2){done(-1,e); // Simply rethrow otherwise
	}else {throw e}}} // Callback for when everything is done
	function done(status,nativeStatusText,responses,headers){var isSuccess,success,error,response,modified,statusText=nativeStatusText; // Called once
	if(state===2){return} // State is "done" now
	state=2; // Clear timeout if it exists
	if(timeoutTimer){clearTimeout(timeoutTimer)} // Dereference transport for early garbage collection
	// (no matter how long the jqXHR object will be used)
	transport=undefined; // Cache response headers
	responseHeadersString=headers||""; // Set readyState
	jqXHR.readyState=status>0?4:0; // Determine if successful
	isSuccess=status>=200&&status<300||status===304; // Get response data
	if(responses){response=ajaxHandleResponses(s,jqXHR,responses)} // Convert no matter what (that way responseXXX fields are always set)
	response=ajaxConvert(s,response,jqXHR,isSuccess); // If successful, handle type chaining
	if(isSuccess){ // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
	if(s.ifModified){modified=jqXHR.getResponseHeader("Last-Modified");if(modified){jQuery.lastModified[cacheURL]=modified}modified=jqXHR.getResponseHeader("etag");if(modified){jQuery.etag[cacheURL]=modified}} // if no content
	if(status===204||s.type==="HEAD"){statusText="nocontent"; // if not modified
	}else if(status===304){statusText="notmodified"; // If we have data, let's convert it
	}else {statusText=response.state;success=response.data;error=response.error;isSuccess=!error}}else { // Extract error from statusText and normalize for non-aborts
	error=statusText;if(status||!statusText){statusText="error";if(status<0){status=0}}} // Set data for the fake xhr object
	jqXHR.status=status;jqXHR.statusText=(nativeStatusText||statusText)+""; // Success/Error
	if(isSuccess){deferred.resolveWith(callbackContext,[success,statusText,jqXHR])}else {deferred.rejectWith(callbackContext,[jqXHR,statusText,error])} // Status-dependent callbacks
	jqXHR.statusCode(statusCode);statusCode=undefined;if(fireGlobals){globalEventContext.trigger(isSuccess?"ajaxSuccess":"ajaxError",[jqXHR,s,isSuccess?success:error])} // Complete
	completeDeferred.fireWith(callbackContext,[jqXHR,statusText]);if(fireGlobals){globalEventContext.trigger("ajaxComplete",[jqXHR,s]); // Handle the global AJAX counter
	if(! --jQuery.active){jQuery.event.trigger("ajaxStop")}}}return jqXHR},getJSON:function(url,data,callback){return jQuery.get(url,data,callback,"json")},getScript:function(url,callback){return jQuery.get(url,undefined,callback,"script")}});jQuery.each(["get","post"],function(i,method){jQuery[method]=function(url,data,callback,type){ // Shift arguments if data argument was omitted
	if(jQuery.isFunction(data)){type=type||callback;callback=data;data=undefined}return jQuery.ajax({url:url,type:method,dataType:type,data:data,success:callback})}});jQuery._evalUrl=function(url){return jQuery.ajax({url:url,type:"GET",dataType:"script",async:false,global:false,"throws":true})};jQuery.fn.extend({wrapAll:function(html){var wrap;if(jQuery.isFunction(html)){return this.each(function(i){jQuery(this).wrapAll(html.call(this,i))})}if(this[0]){ // The elements to wrap the target around
	wrap=jQuery(html,this[0].ownerDocument).eq(0).clone(true);if(this[0].parentNode){wrap.insertBefore(this[0])}wrap.map(function(){var elem=this;while(elem.firstElementChild){elem=elem.firstElementChild}return elem}).append(this)}return this},wrapInner:function(html){if(jQuery.isFunction(html)){return this.each(function(i){jQuery(this).wrapInner(html.call(this,i))})}return this.each(function(){var self=jQuery(this),contents=self.contents();if(contents.length){contents.wrapAll(html)}else {self.append(html)}})},wrap:function(html){var isFunction=jQuery.isFunction(html);return this.each(function(i){jQuery(this).wrapAll(isFunction?html.call(this,i):html)})},unwrap:function(){return this.parent().each(function(){if(!jQuery.nodeName(this,"body")){jQuery(this).replaceWith(this.childNodes)}}).end()}});jQuery.expr.filters.hidden=function(elem){ // Support: Opera <= 12.12
	// Opera reports offsetWidths and offsetHeights less than zero on some elements
	return elem.offsetWidth<=0&&elem.offsetHeight<=0};jQuery.expr.filters.visible=function(elem){return !jQuery.expr.filters.hidden(elem)};var r20=/%20/g,rbracket=/\[\]$/,rCRLF=/\r?\n/g,rsubmitterTypes=/^(?:submit|button|image|reset|file)$/i,rsubmittable=/^(?:input|select|textarea|keygen)/i;function buildParams(prefix,obj,traditional,add){var name;if(jQuery.isArray(obj)){ // Serialize array item.
	jQuery.each(obj,function(i,v){if(traditional||rbracket.test(prefix)){ // Treat each array item as a scalar.
	add(prefix,v)}else { // Item is non-scalar (array or object), encode its numeric index.
	buildParams(prefix+"["+(typeof v==="object"?i:"")+"]",v,traditional,add)}})}else if(!traditional&&jQuery.type(obj)==="object"){ // Serialize object item.
	for(name in obj){buildParams(prefix+"["+name+"]",obj[name],traditional,add)}}else { // Serialize scalar item.
	add(prefix,obj)}} // Serialize an array of form elements or a set of
	// key/values into a query string
	jQuery.param=function(a,traditional){var prefix,s=[],add=function(key,value){ // If value is a function, invoke it and return its value
	value=jQuery.isFunction(value)?value():value==null?"":value;s[s.length]=encodeURIComponent(key)+"="+encodeURIComponent(value)}; // Set traditional to true for jQuery <= 1.3.2 behavior.
	if(traditional===undefined){traditional=jQuery.ajaxSettings&&jQuery.ajaxSettings.traditional} // If an array was passed in, assume that it is an array of form elements.
	if(jQuery.isArray(a)||a.jquery&&!jQuery.isPlainObject(a)){ // Serialize the form elements
	jQuery.each(a,function(){add(this.name,this.value)})}else { // If traditional, encode the "old" way (the way 1.3.2 or older
	// did it), otherwise encode params recursively.
	for(prefix in a){buildParams(prefix,a[prefix],traditional,add)}} // Return the resulting serialization
	return s.join("&").replace(r20,"+")};jQuery.fn.extend({serialize:function(){return jQuery.param(this.serializeArray())},serializeArray:function(){return this.map(function(){ // Can add propHook for "elements" to filter or add form elements
	var elements=jQuery.prop(this,"elements");return elements?jQuery.makeArray(elements):this}).filter(function(){var type=this.type; // Use .is( ":disabled" ) so that fieldset[disabled] works
	return this.name&&!jQuery(this).is(":disabled")&&rsubmittable.test(this.nodeName)&&!rsubmitterTypes.test(type)&&(this.checked||!rcheckableType.test(type))}).map(function(i,elem){var val=jQuery(this).val();return val==null?null:jQuery.isArray(val)?jQuery.map(val,function(val){return {name:elem.name,value:val.replace(rCRLF,"\r\n")}}):{name:elem.name,value:val.replace(rCRLF,"\r\n")}}).get()}});jQuery.ajaxSettings.xhr=function(){try{return new XMLHttpRequest}catch(e) {}};var xhrId=0,xhrCallbacks={},xhrSuccessStatus={ // file protocol always yields status code 0, assume 200
	0:200, // Support: IE9
	// #1450: sometimes IE returns 1223 when it should be 204
	1223:204},xhrSupported=jQuery.ajaxSettings.xhr(); // Support: IE9
	// Open requests must be manually aborted on unload (#5280)
	// See https://support.microsoft.com/kb/2856746 for more info
	if(window.attachEvent){window.attachEvent("onunload",function(){for(var key in xhrCallbacks){xhrCallbacks[key]()}})}support.cors=!!xhrSupported&&"withCredentials" in xhrSupported;support.ajax=xhrSupported=!!xhrSupported;jQuery.ajaxTransport(function(options){var callback; // Cross domain only allowed if supported through XMLHttpRequest
	if(support.cors||xhrSupported&&!options.crossDomain){return {send:function(headers,complete){var i,xhr=options.xhr(),id=++xhrId;xhr.open(options.type,options.url,options.async,options.username,options.password); // Apply custom fields if provided
	if(options.xhrFields){for(i in options.xhrFields){xhr[i]=options.xhrFields[i]}} // Override mime type if needed
	if(options.mimeType&&xhr.overrideMimeType){xhr.overrideMimeType(options.mimeType)} // X-Requested-With header
	// For cross-domain requests, seeing as conditions for a preflight are
	// akin to a jigsaw puzzle, we simply never set it to be sure.
	// (it can always be set on a per-request basis or even using ajaxSetup)
	// For same-domain requests, won't change header if already provided.
	if(!options.crossDomain&&!headers["X-Requested-With"]){headers["X-Requested-With"]="XMLHttpRequest"} // Set headers
	for(i in headers){xhr.setRequestHeader(i,headers[i])} // Callback
	callback=function(type){return function(){if(callback){delete xhrCallbacks[id];callback=xhr.onload=xhr.onerror=null;if(type==="abort"){xhr.abort()}else if(type==="error"){complete( // file: protocol always yields status 0; see #8605, #14207
	xhr.status,xhr.statusText)}else {complete(xhrSuccessStatus[xhr.status]||xhr.status,xhr.statusText, // Support: IE9
	// Accessing binary-data responseText throws an exception
	// (#11426)
	typeof xhr.responseText==="string"?{text:xhr.responseText}:undefined,xhr.getAllResponseHeaders())}}}}; // Listen to events
	xhr.onload=callback();xhr.onerror=callback("error"); // Create the abort callback
	callback=xhrCallbacks[id]=callback("abort");try{ // Do send the request (this may raise an exception)
	xhr.send(options.hasContent&&options.data||null)}catch(e) { // #14683: Only rethrow if this hasn't been notified as an error yet
	if(callback){throw e}}},abort:function(){if(callback){callback()}}}}}); // Install script dataType
	jQuery.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/(?:java|ecma)script/},converters:{"text script":function(text){jQuery.globalEval(text);return text}}}); // Handle cache's special case and crossDomain
	jQuery.ajaxPrefilter("script",function(s){if(s.cache===undefined){s.cache=false}if(s.crossDomain){s.type="GET"}}); // Bind script tag hack transport
	jQuery.ajaxTransport("script",function(s){ // This transport only deals with cross domain requests
	if(s.crossDomain){var script,callback;return {send:function(_,complete){script=jQuery("<script>").prop({async:true,charset:s.scriptCharset,src:s.url}).on("load error",callback=function(evt){script.remove();callback=null;if(evt){complete(evt.type==="error"?404:200,evt.type)}});document.head.appendChild(script[0])},abort:function(){if(callback){callback()}}}}});var oldCallbacks=[],rjsonp=/(=)\?(?=&|$)|\?\?/; // Default jsonp settings
	jQuery.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var callback=oldCallbacks.pop()||jQuery.expando+"_"+nonce++;this[callback]=true;return callback}}); // Detect, normalize options and install callbacks for jsonp requests
	jQuery.ajaxPrefilter("json jsonp",function(s,originalSettings,jqXHR){var callbackName,overwritten,responseContainer,jsonProp=s.jsonp!==false&&(rjsonp.test(s.url)?"url":typeof s.data==="string"&&!(s.contentType||"").indexOf("application/x-www-form-urlencoded")&&rjsonp.test(s.data)&&"data"); // Handle iff the expected data type is "jsonp" or we have a parameter to set
	if(jsonProp||s.dataTypes[0]==="jsonp"){ // Get callback name, remembering preexisting value associated with it
	callbackName=s.jsonpCallback=jQuery.isFunction(s.jsonpCallback)?s.jsonpCallback():s.jsonpCallback; // Insert callback into url or form data
	if(jsonProp){s[jsonProp]=s[jsonProp].replace(rjsonp,"$1"+callbackName)}else if(s.jsonp!==false){s.url+=(rquery.test(s.url)?"&":"?")+s.jsonp+"="+callbackName} // Use data converter to retrieve json after script execution
	s.converters["script json"]=function(){if(!responseContainer){jQuery.error(callbackName+" was not called")}return responseContainer[0]}; // force json dataType
	s.dataTypes[0]="json"; // Install callback
	overwritten=window[callbackName];window[callbackName]=function(){responseContainer=arguments}; // Clean-up function (fires after converters)
	jqXHR.always(function(){ // Restore preexisting value
	window[callbackName]=overwritten; // Save back as free
	if(s[callbackName]){ // make sure that re-using the options doesn't screw things around
	s.jsonpCallback=originalSettings.jsonpCallback; // save the callback name for future use
	oldCallbacks.push(callbackName)} // Call if it was a function and we have a response
	if(responseContainer&&jQuery.isFunction(overwritten)){overwritten(responseContainer[0])}responseContainer=overwritten=undefined}); // Delegate to script
	return "script"}}); // data: string of html
	// context (optional): If specified, the fragment will be created in this context, defaults to document
	// keepScripts (optional): If true, will include scripts passed in the html string
	jQuery.parseHTML=function(data,context,keepScripts){if(!data||typeof data!=="string"){return null}if(typeof context==="boolean"){keepScripts=context;context=false}context=context||document;var parsed=rsingleTag.exec(data),scripts=!keepScripts&&[]; // Single tag
	if(parsed){return [context.createElement(parsed[1])]}parsed=jQuery.buildFragment([data],context,scripts);if(scripts&&scripts.length){jQuery(scripts).remove()}return jQuery.merge([],parsed.childNodes)}; // Keep a copy of the old load method
	var _load=jQuery.fn.load; /**
	 * Load a url into a page
	 */jQuery.fn.load=function(url,params,callback){if(typeof url!=="string"&&_load){return _load.apply(this,arguments)}var selector,type,response,self=this,off=url.indexOf(" ");if(off>=0){selector=jQuery.trim(url.slice(off));url=url.slice(0,off)} // If it's a function
	if(jQuery.isFunction(params)){ // We assume that it's the callback
	callback=params;params=undefined; // Otherwise, build a param string
	}else if(params&&typeof params==="object"){type="POST"} // If we have elements to modify, make the request
	if(self.length>0){jQuery.ajax({url:url, // if "type" variable is undefined, then "GET" method will be used
	type:type,dataType:"html",data:params}).done(function(responseText){ // Save response for use in complete callback
	response=arguments;self.html(selector? // If a selector was specified, locate the right elements in a dummy div
	// Exclude scripts to avoid IE 'Permission Denied' errors
	jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector): // Otherwise use the full result
	responseText)}).complete(callback&&function(jqXHR,status){self.each(callback,response||[jqXHR.responseText,status,jqXHR])})}return this}; // Attach a bunch of functions for handling common AJAX events
	jQuery.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(i,type){jQuery.fn[type]=function(fn){return this.on(type,fn)}});jQuery.expr.filters.animated=function(elem){return jQuery.grep(jQuery.timers,function(fn){return elem===fn.elem}).length};var docElem=window.document.documentElement; /**
	 * Gets a window from an element
	 */function getWindow(elem){return jQuery.isWindow(elem)?elem:elem.nodeType===9&&elem.defaultView}jQuery.offset={setOffset:function(elem,options,i){var curPosition,curLeft,curCSSTop,curTop,curOffset,curCSSLeft,calculatePosition,position=jQuery.css(elem,"position"),curElem=jQuery(elem),props={}; // Set position first, in-case top/left are set even on static elem
	if(position==="static"){elem.style.position="relative"}curOffset=curElem.offset();curCSSTop=jQuery.css(elem,"top");curCSSLeft=jQuery.css(elem,"left");calculatePosition=(position==="absolute"||position==="fixed")&&(curCSSTop+curCSSLeft).indexOf("auto")>-1; // Need to be able to calculate position if either
	// top or left is auto and position is either absolute or fixed
	if(calculatePosition){curPosition=curElem.position();curTop=curPosition.top;curLeft=curPosition.left}else {curTop=parseFloat(curCSSTop)||0;curLeft=parseFloat(curCSSLeft)||0}if(jQuery.isFunction(options)){options=options.call(elem,i,curOffset)}if(options.top!=null){props.top=options.top-curOffset.top+curTop}if(options.left!=null){props.left=options.left-curOffset.left+curLeft}if("using" in options){options.using.call(elem,props)}else {curElem.css(props)}}};jQuery.fn.extend({offset:function(options){if(arguments.length){return options===undefined?this:this.each(function(i){jQuery.offset.setOffset(this,options,i)})}var docElem,win,elem=this[0],box={top:0,left:0},doc=elem&&elem.ownerDocument;if(!doc){return}docElem=doc.documentElement; // Make sure it's not a disconnected DOM node
	if(!jQuery.contains(docElem,elem)){return box} // Support: BlackBerry 5, iOS 3 (original iPhone)
	// If we don't have gBCR, just use 0,0 rather than error
	if(typeof elem.getBoundingClientRect!==strundefined){box=elem.getBoundingClientRect()}win=getWindow(doc);return {top:box.top+win.pageYOffset-docElem.clientTop,left:box.left+win.pageXOffset-docElem.clientLeft}},position:function(){if(!this[0]){return}var offsetParent,offset,elem=this[0],parentOffset={top:0,left:0}; // Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent
	if(jQuery.css(elem,"position")==="fixed"){ // Assume getBoundingClientRect is there when computed position is fixed
	offset=elem.getBoundingClientRect()}else { // Get *real* offsetParent
	offsetParent=this.offsetParent(); // Get correct offsets
	offset=this.offset();if(!jQuery.nodeName(offsetParent[0],"html")){parentOffset=offsetParent.offset()} // Add offsetParent borders
	parentOffset.top+=jQuery.css(offsetParent[0],"borderTopWidth",true);parentOffset.left+=jQuery.css(offsetParent[0],"borderLeftWidth",true)} // Subtract parent offsets and element margins
	return {top:offset.top-parentOffset.top-jQuery.css(elem,"marginTop",true),left:offset.left-parentOffset.left-jQuery.css(elem,"marginLeft",true)}},offsetParent:function(){return this.map(function(){var offsetParent=this.offsetParent||docElem;while(offsetParent&&!jQuery.nodeName(offsetParent,"html")&&jQuery.css(offsetParent,"position")==="static"){offsetParent=offsetParent.offsetParent}return offsetParent||docElem})}}); // Create scrollLeft and scrollTop methods
	jQuery.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(method,prop){var top="pageYOffset"===prop;jQuery.fn[method]=function(val){return access(this,function(elem,method,val){var win=getWindow(elem);if(val===undefined){return win?win[prop]:elem[method]}if(win){win.scrollTo(!top?val:window.pageXOffset,top?val:window.pageYOffset)}else {elem[method]=val}},method,val,arguments.length,null)}}); // Support: Safari<7+, Chrome<37+
	// Add the top/left cssHooks using jQuery.fn.position
	// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
	// Blink bug: https://code.google.com/p/chromium/issues/detail?id=229280
	// getComputedStyle returns percent when specified for top/left/bottom/right;
	// rather than make the css module depend on the offset module, just check for it here
	jQuery.each(["top","left"],function(i,prop){jQuery.cssHooks[prop]=addGetHookIf(support.pixelPosition,function(elem,computed){if(computed){computed=curCSS(elem,prop); // If curCSS returns percentage, fallback to offset
	return rnumnonpx.test(computed)?jQuery(elem).position()[prop]+"px":computed}})}); // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
	jQuery.each({Height:"height",Width:"width"},function(name,type){jQuery.each({padding:"inner"+name,content:type,"":"outer"+name},function(defaultExtra,funcName){ // Margin is only for outerHeight, outerWidth
	jQuery.fn[funcName]=function(margin,value){var chainable=arguments.length&&(defaultExtra||typeof margin!=="boolean"),extra=defaultExtra||(margin===true||value===true?"margin":"border");return access(this,function(elem,type,value){var doc;if(jQuery.isWindow(elem)){ // As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
	// isn't a whole lot we can do. See pull request at this URL for discussion:
	// https://github.com/jquery/jquery/pull/764
	return elem.document.documentElement["client"+name]} // Get document width or height
	if(elem.nodeType===9){doc=elem.documentElement; // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
	// whichever is greatest
	return Math.max(elem.body["scroll"+name],doc["scroll"+name],elem.body["offset"+name],doc["offset"+name],doc["client"+name])}return value===undefined? // Get width or height on the element, requesting but not forcing parseFloat
	jQuery.css(elem,type,extra): // Set width or height on the element
	jQuery.style(elem,type,value,extra)},type,chainable?margin:undefined,chainable,null)}})}); // The number of elements contained in the matched element set
	jQuery.fn.size=function(){return this.length};jQuery.fn.andSelf=jQuery.fn.addBack; // Register as a named AMD module, since jQuery can be concatenated with other
	// files that may use define, but not via a proper concatenation script that
	// understands anonymous AMD modules. A named AMD is safest and most robust
	// way to register. Lowercase jquery is used because AMD module names are
	// derived from file names, and jQuery is normally delivered in a lowercase
	// file name. Do this after creating the global so that if an AMD module wants
	// to call noConflict to hide this version of jQuery, it will work.
	// Note that for maximum portability, libraries that are not jQuery should
	// declare themselves as anonymous modules, and avoid setting a global if an
	// AMD loader is present. jQuery is a special case. For more information, see
	// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon
	if(true){!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function(){return jQuery}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))}var  // Map over jQuery in case of overwrite
	_jQuery=window.jQuery, // Map over the $ in case of overwrite
	_$=window.$;jQuery.noConflict=function(deep){if(window.$===jQuery){window.$=_$}if(deep&&window.jQuery===jQuery){window.jQuery=_jQuery}return jQuery}; // Expose jQuery and $ identifiers, even in AMD
	// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
	// and CommonJS for browser emulators (#13566)
	if(typeof noGlobal===strundefined){window.jQuery=window.$=jQuery}return jQuery});

/***/ },
/* 127 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 128 */,
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	// CodeMirror, copyright (c) by Marijn Haverbeke and others
	// Distributed under an MIT license: http://codemirror.net/LICENSE
	// This is CodeMirror (http://codemirror.net), a code editor
	// implemented in JavaScript on top of the browser's DOM.
	//
	// You can find some technical background for some of the code below
	// at http://marijnhaverbeke.nl/blog/#cm-internals .
	(function(mod){if(true) // CommonJS
	module.exports=mod();else if(typeof define=="function"&&define.amd) // AMD
	return define([],mod);else  // Plain browser env
	this.CodeMirror=mod()})(function(){"use strict" // BROWSER SNIFFING
	// Kludges for bugs and behavior differences that can't be feature
	// detected are enabled based on userAgent etc sniffing.
	;var userAgent=navigator.userAgent;var platform=navigator.platform;var gecko=/gecko\/\d/i.test(userAgent);var ie_upto10=/MSIE \d/.test(userAgent);var ie_11up=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(userAgent);var ie=ie_upto10||ie_11up;var ie_version=ie&&(ie_upto10?document.documentMode||6:ie_11up[1]);var webkit=/WebKit\//.test(userAgent);var qtwebkit=webkit&&/Qt\/\d+\.\d+/.test(userAgent);var chrome=/Chrome\//.test(userAgent);var presto=/Opera\//.test(userAgent);var safari=/Apple Computer/.test(navigator.vendor);var mac_geMountainLion=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(userAgent);var phantom=/PhantomJS/.test(userAgent);var ios=/AppleWebKit/.test(userAgent)&&/Mobile\/\w+/.test(userAgent); // This is woefully incomplete. Suggestions for alternative methods welcome.
	var mobile=ios||/Android|webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);var mac=ios||/Mac/.test(platform);var windows=/win/i.test(platform);var presto_version=presto&&userAgent.match(/Version\/(\d*\.\d*)/);if(presto_version)presto_version=Number(presto_version[1]);if(presto_version&&presto_version>=15){presto=false;webkit=true} // Some browsers use the wrong event properties to signal cmd/ctrl on OS X
	var flipCtrlCmd=mac&&(qtwebkit||presto&&(presto_version==null||presto_version<12.11));var captureRightClick=gecko||ie&&ie_version>=9; // Optimize some code when these features are not used.
	var sawReadOnlySpans=false,sawCollapsedSpans=false; // EDITOR CONSTRUCTOR
	// A CodeMirror instance represents an editor. This is the object
	// that user code is usually dealing with.
	function CodeMirror(place,options){if(!(this instanceof CodeMirror))return new CodeMirror(place,options);this.options=options=options?copyObj(options):{}; // Determine effective options based on given values and defaults.
	copyObj(defaults,options,false);setGuttersForLineNumbers(options);var doc=options.value;if(typeof doc=="string")doc=new Doc(doc,options.mode,null,options.lineSeparator);this.doc=doc;var input=new CodeMirror.inputStyles[options.inputStyle](this);var display=this.display=new Display(place,doc,input);display.wrapper.CodeMirror=this;updateGutters(this);themeChanged(this);if(options.lineWrapping)this.display.wrapper.className+=" CodeMirror-wrap";if(options.autofocus&&!mobile)display.input.focus();initScrollbars(this);this.state={keyMaps:[], // stores maps added by addKeyMap
	overlays:[], // highlighting overlays, as added by addOverlay
	modeGen:0, // bumped when mode/overlay changes, used to invalidate highlighting info
	overwrite:false,delayingBlurEvent:false,focused:false,suppressEdits:false, // used to disable editing during key handlers when in readOnly mode
	pasteIncoming:false,cutIncoming:false, // help recognize paste/cut edits in input.poll
	selectingText:false,draggingText:false,highlight:new Delayed, // stores highlight worker timeout
	keySeq:null, // Unfinished key sequence
	specialChars:null};var cm=this; // Override magic textarea content restore that IE sometimes does
	// on our hidden textarea on reload
	if(ie&&ie_version<11)setTimeout(function(){cm.display.input.reset(true)},20);registerEventHandlers(this);ensureGlobalHandlers();startOperation(this);this.curOp.forceUpdate=true;attachDoc(this,doc);if(options.autofocus&&!mobile||cm.hasFocus())setTimeout(bind(onFocus,this),20);else onBlur(this);for(var opt in optionHandlers)if(optionHandlers.hasOwnProperty(opt))optionHandlers[opt](this,options[opt],Init);maybeUpdateLineNumberWidth(this);if(options.finishInit)options.finishInit(this);for(var i=0;i<initHooks.length;++i)initHooks[i](this);endOperation(this); // Suppress optimizelegibility in Webkit, since it breaks text
	// measuring on line wrapping boundaries.
	if(webkit&&options.lineWrapping&&getComputedStyle(display.lineDiv).textRendering=="optimizelegibility")display.lineDiv.style.textRendering="auto"} // DISPLAY CONSTRUCTOR
	// The display handles the DOM integration, both for input reading
	// and content drawing. It holds references to DOM nodes and
	// display-related state.
	function Display(place,doc,input){var d=this;this.input=input; // Covers bottom-right square when both scrollbars are present.
	d.scrollbarFiller=elt("div",null,"CodeMirror-scrollbar-filler");d.scrollbarFiller.setAttribute("cm-not-content","true"); // Covers bottom of gutter when coverGutterNextToScrollbar is on
	// and h scrollbar is present.
	d.gutterFiller=elt("div",null,"CodeMirror-gutter-filler");d.gutterFiller.setAttribute("cm-not-content","true"); // Will contain the actual code, positioned to cover the viewport.
	d.lineDiv=elt("div",null,"CodeMirror-code"); // Elements are added to these to represent selection and cursors.
	d.selectionDiv=elt("div",null,null,"position: relative; z-index: 1");d.cursorDiv=elt("div",null,"CodeMirror-cursors"); // A visibility: hidden element used to find the size of things.
	d.measure=elt("div",null,"CodeMirror-measure"); // When lines outside of the viewport are measured, they are drawn in this.
	d.lineMeasure=elt("div",null,"CodeMirror-measure"); // Wraps everything that needs to exist inside the vertically-padded coordinate system
	d.lineSpace=elt("div",[d.measure,d.lineMeasure,d.selectionDiv,d.cursorDiv,d.lineDiv],null,"position: relative; outline: none"); // Moved around its parent to cover visible view.
	d.mover=elt("div",[elt("div",[d.lineSpace],"CodeMirror-lines")],null,"position: relative"); // Set to the height of the document, allowing scrolling.
	d.sizer=elt("div",[d.mover],"CodeMirror-sizer");d.sizerWidth=null; // Behavior of elts with overflow: auto and padding is
	// inconsistent across browsers. This is used to ensure the
	// scrollable area is big enough.
	d.heightForcer=elt("div",null,null,"position: absolute; height: "+scrollerGap+"px; width: 1px;"); // Will contain the gutters, if any.
	d.gutters=elt("div",null,"CodeMirror-gutters");d.lineGutter=null; // Actual scrollable element.
	d.scroller=elt("div",[d.sizer,d.heightForcer,d.gutters],"CodeMirror-scroll");d.scroller.setAttribute("tabIndex","-1"); // The element in which the editor lives.
	d.wrapper=elt("div",[d.scrollbarFiller,d.gutterFiller,d.scroller],"CodeMirror"); // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)
	if(ie&&ie_version<8){d.gutters.style.zIndex=-1;d.scroller.style.paddingRight=0}if(!webkit&&!(gecko&&mobile))d.scroller.draggable=true;if(place){if(place.appendChild)place.appendChild(d.wrapper);else place(d.wrapper)} // Current rendered range (may be bigger than the view window).
	d.viewFrom=d.viewTo=doc.first;d.reportedViewFrom=d.reportedViewTo=doc.first; // Information about the rendered lines.
	d.view=[];d.renderedView=null; // Holds info about a single rendered line when it was rendered
	// for measurement, while not in view.
	d.externalMeasured=null; // Empty space (in pixels) above the view
	d.viewOffset=0;d.lastWrapHeight=d.lastWrapWidth=0;d.updateLineNumbers=null;d.nativeBarWidth=d.barHeight=d.barWidth=0;d.scrollbarsClipped=false; // Used to only resize the line number gutter when necessary (when
	// the amount of lines crosses a boundary that makes its width change)
	d.lineNumWidth=d.lineNumInnerWidth=d.lineNumChars=null; // Set to true when a non-horizontal-scrolling line widget is
	// added. As an optimization, line widget aligning is skipped when
	// this is false.
	d.alignWidgets=false;d.cachedCharWidth=d.cachedTextHeight=d.cachedPaddingH=null; // Tracks the maximum line length so that the horizontal scrollbar
	// can be kept static when scrolling.
	d.maxLine=null;d.maxLineLength=0;d.maxLineChanged=false; // Used for measuring wheel scrolling granularity
	d.wheelDX=d.wheelDY=d.wheelStartX=d.wheelStartY=null; // True when shift is held down.
	d.shift=false; // Used to track whether anything happened since the context menu
	// was opened.
	d.selForContextMenu=null;d.activeTouch=null;input.init(d)} // STATE UPDATES
	// Used to get the editor into a consistent state again when options change.
	function loadMode(cm){cm.doc.mode=CodeMirror.getMode(cm.options,cm.doc.modeOption);resetModeState(cm)}function resetModeState(cm){cm.doc.iter(function(line){if(line.stateAfter)line.stateAfter=null;if(line.styles)line.styles=null});cm.doc.frontier=cm.doc.first;startWorker(cm,100);cm.state.modeGen++;if(cm.curOp)regChange(cm)}function wrappingChanged(cm){if(cm.options.lineWrapping){addClass(cm.display.wrapper,"CodeMirror-wrap");cm.display.sizer.style.minWidth="";cm.display.sizerWidth=null}else {rmClass(cm.display.wrapper,"CodeMirror-wrap");findMaxLine(cm)}estimateLineHeights(cm);regChange(cm);clearCaches(cm);setTimeout(function(){updateScrollbars(cm)},100)} // Returns a function that estimates the height of a line, to use as
	// first approximation until the line becomes visible (and is thus
	// properly measurable).
	function estimateHeight(cm){var th=textHeight(cm.display),wrapping=cm.options.lineWrapping;var perLine=wrapping&&Math.max(5,cm.display.scroller.clientWidth/charWidth(cm.display)-3);return function(line){if(lineIsHidden(cm.doc,line))return 0;var widgetsHeight=0;if(line.widgets)for(var i=0;i<line.widgets.length;i++){if(line.widgets[i].height)widgetsHeight+=line.widgets[i].height}if(wrapping)return widgetsHeight+(Math.ceil(line.text.length/perLine)||1)*th;else return widgetsHeight+th}}function estimateLineHeights(cm){var doc=cm.doc,est=estimateHeight(cm);doc.iter(function(line){var estHeight=est(line);if(estHeight!=line.height)updateLineHeight(line,estHeight)})}function themeChanged(cm){cm.display.wrapper.className=cm.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+cm.options.theme.replace(/(^|\s)\s*/g," cm-s-");clearCaches(cm)}function guttersChanged(cm){updateGutters(cm);regChange(cm);setTimeout(function(){alignHorizontally(cm)},20)} // Rebuild the gutter elements, ensure the margin to the left of the
	// code matches their width.
	function updateGutters(cm){var gutters=cm.display.gutters,specs=cm.options.gutters;removeChildren(gutters);for(var i=0;i<specs.length;++i){var gutterClass=specs[i];var gElt=gutters.appendChild(elt("div",null,"CodeMirror-gutter "+gutterClass));if(gutterClass=="CodeMirror-linenumbers"){cm.display.lineGutter=gElt;gElt.style.width=(cm.display.lineNumWidth||1)+"px"}}gutters.style.display=i?"":"none";updateGutterSpace(cm)}function updateGutterSpace(cm){var width=cm.display.gutters.offsetWidth;cm.display.sizer.style.marginLeft=width+"px"} // Compute the character length of a line, taking into account
	// collapsed ranges (see markText) that might hide parts, and join
	// other lines onto it.
	function lineLength(line){if(line.height==0)return 0;var len=line.text.length,merged,cur=line;while(merged=collapsedSpanAtStart(cur)){var found=merged.find(0,true);cur=found.from.line;len+=found.from.ch-found.to.ch}cur=line;while(merged=collapsedSpanAtEnd(cur)){var found=merged.find(0,true);len-=cur.text.length-found.from.ch;cur=found.to.line;len+=cur.text.length-found.to.ch}return len} // Find the longest line in the document.
	function findMaxLine(cm){var d=cm.display,doc=cm.doc;d.maxLine=getLine(doc,doc.first);d.maxLineLength=lineLength(d.maxLine);d.maxLineChanged=true;doc.iter(function(line){var len=lineLength(line);if(len>d.maxLineLength){d.maxLineLength=len;d.maxLine=line}})} // Make sure the gutters options contains the element
	// "CodeMirror-linenumbers" when the lineNumbers option is true.
	function setGuttersForLineNumbers(options){var found=indexOf(options.gutters,"CodeMirror-linenumbers");if(found==-1&&options.lineNumbers){options.gutters=options.gutters.concat(["CodeMirror-linenumbers"])}else if(found>-1&&!options.lineNumbers){options.gutters=options.gutters.slice(0);options.gutters.splice(found,1)}} // SCROLLBARS
	// Prepare DOM reads needed to update the scrollbars. Done in one
	// shot to minimize update/measure roundtrips.
	function measureForScrollbars(cm){var d=cm.display,gutterW=d.gutters.offsetWidth;var docH=Math.round(cm.doc.height+paddingVert(cm.display));return {clientHeight:d.scroller.clientHeight,viewHeight:d.wrapper.clientHeight,scrollWidth:d.scroller.scrollWidth,clientWidth:d.scroller.clientWidth,viewWidth:d.wrapper.clientWidth,barLeft:cm.options.fixedGutter?gutterW:0,docHeight:docH,scrollHeight:docH+scrollGap(cm)+d.barHeight,nativeBarWidth:d.nativeBarWidth,gutterWidth:gutterW}}function NativeScrollbars(place,scroll,cm){this.cm=cm;var vert=this.vert=elt("div",[elt("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar");var horiz=this.horiz=elt("div",[elt("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");place(vert);place(horiz);on(vert,"scroll",function(){if(vert.clientHeight)scroll(vert.scrollTop,"vertical")});on(horiz,"scroll",function(){if(horiz.clientWidth)scroll(horiz.scrollLeft,"horizontal")});this.checkedZeroWidth=false; // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).
	if(ie&&ie_version<8)this.horiz.style.minHeight=this.vert.style.minWidth="18px"}NativeScrollbars.prototype=copyObj({update:function(measure){var needsH=measure.scrollWidth>measure.clientWidth+1;var needsV=measure.scrollHeight>measure.clientHeight+1;var sWidth=measure.nativeBarWidth;if(needsV){this.vert.style.display="block";this.vert.style.bottom=needsH?sWidth+"px":"0";var totalHeight=measure.viewHeight-(needsH?sWidth:0); // A bug in IE8 can cause this value to be negative, so guard it.
	this.vert.firstChild.style.height=Math.max(0,measure.scrollHeight-measure.clientHeight+totalHeight)+"px"}else {this.vert.style.display="";this.vert.firstChild.style.height="0"}if(needsH){this.horiz.style.display="block";this.horiz.style.right=needsV?sWidth+"px":"0";this.horiz.style.left=measure.barLeft+"px";var totalWidth=measure.viewWidth-measure.barLeft-(needsV?sWidth:0);this.horiz.firstChild.style.width=measure.scrollWidth-measure.clientWidth+totalWidth+"px"}else {this.horiz.style.display="";this.horiz.firstChild.style.width="0"}if(!this.checkedZeroWidth&&measure.clientHeight>0){if(sWidth==0)this.zeroWidthHack();this.checkedZeroWidth=true}return {right:needsV?sWidth:0,bottom:needsH?sWidth:0}},setScrollLeft:function(pos){if(this.horiz.scrollLeft!=pos)this.horiz.scrollLeft=pos;if(this.disableHoriz)this.enableZeroWidthBar(this.horiz,this.disableHoriz)},setScrollTop:function(pos){if(this.vert.scrollTop!=pos)this.vert.scrollTop=pos;if(this.disableVert)this.enableZeroWidthBar(this.vert,this.disableVert)},zeroWidthHack:function(){var w=mac&&!mac_geMountainLion?"12px":"18px";this.horiz.style.height=this.vert.style.width=w;this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none";this.disableHoriz=new Delayed;this.disableVert=new Delayed},enableZeroWidthBar:function(bar,delay){bar.style.pointerEvents="auto";function maybeDisable(){ // To find out whether the scrollbar is still visible, we
	// check whether the element under the pixel in the bottom
	// left corner of the scrollbar box is the scrollbar box
	// itself (when the bar is still visible) or its filler child
	// (when the bar is hidden). If it is still visible, we keep
	// it enabled, if it's hidden, we disable pointer events.
	var box=bar.getBoundingClientRect();var elt=document.elementFromPoint(box.left+1,box.bottom-1);if(elt!=bar)bar.style.pointerEvents="none";else delay.set(1000,maybeDisable)}delay.set(1000,maybeDisable)},clear:function(){var parent=this.horiz.parentNode;parent.removeChild(this.horiz);parent.removeChild(this.vert)}},NativeScrollbars.prototype);function NullScrollbars(){}NullScrollbars.prototype=copyObj({update:function(){return {bottom:0,right:0}},setScrollLeft:function(){},setScrollTop:function(){},clear:function(){}},NullScrollbars.prototype);CodeMirror.scrollbarModel={"native":NativeScrollbars,"null":NullScrollbars};function initScrollbars(cm){if(cm.display.scrollbars){cm.display.scrollbars.clear();if(cm.display.scrollbars.addClass)rmClass(cm.display.wrapper,cm.display.scrollbars.addClass)}cm.display.scrollbars=new CodeMirror.scrollbarModel[cm.options.scrollbarStyle](function(node){cm.display.wrapper.insertBefore(node,cm.display.scrollbarFiller); // Prevent clicks in the scrollbars from killing focus
	on(node,"mousedown",function(){if(cm.state.focused)setTimeout(function(){cm.display.input.focus()},0)});node.setAttribute("cm-not-content","true")},function(pos,axis){if(axis=="horizontal")setScrollLeft(cm,pos);else setScrollTop(cm,pos)},cm);if(cm.display.scrollbars.addClass)addClass(cm.display.wrapper,cm.display.scrollbars.addClass)}function updateScrollbars(cm,measure){if(!measure)measure=measureForScrollbars(cm);var startWidth=cm.display.barWidth,startHeight=cm.display.barHeight;updateScrollbarsInner(cm,measure);for(var i=0;i<4&&startWidth!=cm.display.barWidth||startHeight!=cm.display.barHeight;i++){if(startWidth!=cm.display.barWidth&&cm.options.lineWrapping)updateHeightsInViewport(cm);updateScrollbarsInner(cm,measureForScrollbars(cm));startWidth=cm.display.barWidth;startHeight=cm.display.barHeight}} // Re-synchronize the fake scrollbars with the actual size of the
	// content.
	function updateScrollbarsInner(cm,measure){var d=cm.display;var sizes=d.scrollbars.update(measure);d.sizer.style.paddingRight=(d.barWidth=sizes.right)+"px";d.sizer.style.paddingBottom=(d.barHeight=sizes.bottom)+"px";if(sizes.right&&sizes.bottom){d.scrollbarFiller.style.display="block";d.scrollbarFiller.style.height=sizes.bottom+"px";d.scrollbarFiller.style.width=sizes.right+"px"}else d.scrollbarFiller.style.display="";if(sizes.bottom&&cm.options.coverGutterNextToScrollbar&&cm.options.fixedGutter){d.gutterFiller.style.display="block";d.gutterFiller.style.height=sizes.bottom+"px";d.gutterFiller.style.width=measure.gutterWidth+"px"}else d.gutterFiller.style.display=""} // Compute the lines that are visible in a given viewport (defaults
	// the the current scroll position). viewport may contain top,
	// height, and ensure (see op.scrollToPos) properties.
	function visibleLines(display,doc,viewport){var top=viewport&&viewport.top!=null?Math.max(0,viewport.top):display.scroller.scrollTop;top=Math.floor(top-paddingTop(display));var bottom=viewport&&viewport.bottom!=null?viewport.bottom:top+display.wrapper.clientHeight;var from=lineAtHeight(doc,top),to=lineAtHeight(doc,bottom); // Ensure is a {from: {line, ch}, to: {line, ch}} object, and
	// forces those lines into the viewport (if possible).
	if(viewport&&viewport.ensure){var ensureFrom=viewport.ensure.from.line,ensureTo=viewport.ensure.to.line;if(ensureFrom<from){from=ensureFrom;to=lineAtHeight(doc,heightAtLine(getLine(doc,ensureFrom))+display.wrapper.clientHeight)}else if(Math.min(ensureTo,doc.lastLine())>=to){from=lineAtHeight(doc,heightAtLine(getLine(doc,ensureTo))-display.wrapper.clientHeight);to=ensureTo}}return {from:from,to:Math.max(to,from+1)}} // LINE NUMBERS
	// Re-align line numbers and gutter marks to compensate for
	// horizontal scrolling.
	function alignHorizontally(cm){var display=cm.display,view=display.view;if(!display.alignWidgets&&(!display.gutters.firstChild||!cm.options.fixedGutter))return;var comp=compensateForHScroll(display)-display.scroller.scrollLeft+cm.doc.scrollLeft;var gutterW=display.gutters.offsetWidth,left=comp+"px";for(var i=0;i<view.length;i++)if(!view[i].hidden){if(cm.options.fixedGutter&&view[i].gutter)view[i].gutter.style.left=left;var align=view[i].alignable;if(align)for(var j=0;j<align.length;j++)align[j].style.left=left}if(cm.options.fixedGutter)display.gutters.style.left=comp+gutterW+"px"} // Used to ensure that the line number gutter is still the right
	// size for the current document size. Returns true when an update
	// is needed.
	function maybeUpdateLineNumberWidth(cm){if(!cm.options.lineNumbers)return false;var doc=cm.doc,last=lineNumberFor(cm.options,doc.first+doc.size-1),display=cm.display;if(last.length!=display.lineNumChars){var test=display.measure.appendChild(elt("div",[elt("div",last)],"CodeMirror-linenumber CodeMirror-gutter-elt"));var innerW=test.firstChild.offsetWidth,padding=test.offsetWidth-innerW;display.lineGutter.style.width="";display.lineNumInnerWidth=Math.max(innerW,display.lineGutter.offsetWidth-padding)+1;display.lineNumWidth=display.lineNumInnerWidth+padding;display.lineNumChars=display.lineNumInnerWidth?last.length:-1;display.lineGutter.style.width=display.lineNumWidth+"px";updateGutterSpace(cm);return true}return false}function lineNumberFor(options,i){return String(options.lineNumberFormatter(i+options.firstLineNumber))} // Computes display.scroller.scrollLeft + display.gutters.offsetWidth,
	// but using getBoundingClientRect to get a sub-pixel-accurate
	// result.
	function compensateForHScroll(display){return display.scroller.getBoundingClientRect().left-display.sizer.getBoundingClientRect().left} // DISPLAY DRAWING
	function DisplayUpdate(cm,viewport,force){var display=cm.display;this.viewport=viewport; // Store some values that we'll need later (but don't want to force a relayout for)
	this.visible=visibleLines(display,cm.doc,viewport);this.editorIsHidden=!display.wrapper.offsetWidth;this.wrapperHeight=display.wrapper.clientHeight;this.wrapperWidth=display.wrapper.clientWidth;this.oldDisplayWidth=displayWidth(cm);this.force=force;this.dims=getDimensions(cm);this.events=[]}DisplayUpdate.prototype.signal=function(emitter,type){if(hasHandler(emitter,type))this.events.push(arguments)};DisplayUpdate.prototype.finish=function(){for(var i=0;i<this.events.length;i++)signal.apply(null,this.events[i])};function maybeClipScrollbars(cm){var display=cm.display;if(!display.scrollbarsClipped&&display.scroller.offsetWidth){display.nativeBarWidth=display.scroller.offsetWidth-display.scroller.clientWidth;display.heightForcer.style.height=scrollGap(cm)+"px";display.sizer.style.marginBottom=-display.nativeBarWidth+"px";display.sizer.style.borderRightWidth=scrollGap(cm)+"px";display.scrollbarsClipped=true}} // Does the actual updating of the line display. Bails out
	// (returning false) when there is nothing to be done and forced is
	// false.
	function updateDisplayIfNeeded(cm,update){var display=cm.display,doc=cm.doc;if(update.editorIsHidden){resetView(cm);return false} // Bail out if the visible area is already rendered and nothing changed.
	if(!update.force&&update.visible.from>=display.viewFrom&&update.visible.to<=display.viewTo&&(display.updateLineNumbers==null||display.updateLineNumbers>=display.viewTo)&&display.renderedView==display.view&&countDirtyView(cm)==0)return false;if(maybeUpdateLineNumberWidth(cm)){resetView(cm);update.dims=getDimensions(cm)} // Compute a suitable new viewport (from & to)
	var end=doc.first+doc.size;var from=Math.max(update.visible.from-cm.options.viewportMargin,doc.first);var to=Math.min(end,update.visible.to+cm.options.viewportMargin);if(display.viewFrom<from&&from-display.viewFrom<20)from=Math.max(doc.first,display.viewFrom);if(display.viewTo>to&&display.viewTo-to<20)to=Math.min(end,display.viewTo);if(sawCollapsedSpans){from=visualLineNo(cm.doc,from);to=visualLineEndNo(cm.doc,to)}var different=from!=display.viewFrom||to!=display.viewTo||display.lastWrapHeight!=update.wrapperHeight||display.lastWrapWidth!=update.wrapperWidth;adjustView(cm,from,to);display.viewOffset=heightAtLine(getLine(cm.doc,display.viewFrom)); // Position the mover div to align with the current scroll position
	cm.display.mover.style.top=display.viewOffset+"px";var toUpdate=countDirtyView(cm);if(!different&&toUpdate==0&&!update.force&&display.renderedView==display.view&&(display.updateLineNumbers==null||display.updateLineNumbers>=display.viewTo))return false; // For big changes, we hide the enclosing element during the
	// update, since that speeds up the operations on most browsers.
	var focused=activeElt();if(toUpdate>4)display.lineDiv.style.display="none";patchDisplay(cm,display.updateLineNumbers,update.dims);if(toUpdate>4)display.lineDiv.style.display="";display.renderedView=display.view; // There might have been a widget with a focused element that got
	// hidden or updated, if so re-focus it.
	if(focused&&activeElt()!=focused&&focused.offsetHeight)focused.focus(); // Prevent selection and cursors from interfering with the scroll
	// width and height.
	removeChildren(display.cursorDiv);removeChildren(display.selectionDiv);display.gutters.style.height=display.sizer.style.minHeight=0;if(different){display.lastWrapHeight=update.wrapperHeight;display.lastWrapWidth=update.wrapperWidth;startWorker(cm,400)}display.updateLineNumbers=null;return true}function postUpdateDisplay(cm,update){var viewport=update.viewport;for(var first=true;;first=false){if(!first||!cm.options.lineWrapping||update.oldDisplayWidth==displayWidth(cm)){ // Clip forced viewport to actual scrollable area.
	if(viewport&&viewport.top!=null)viewport={top:Math.min(cm.doc.height+paddingVert(cm.display)-displayHeight(cm),viewport.top)}; // Updated line heights might result in the drawn area not
	// actually covering the viewport. Keep looping until it does.
	update.visible=visibleLines(cm.display,cm.doc,viewport);if(update.visible.from>=cm.display.viewFrom&&update.visible.to<=cm.display.viewTo)break}if(!updateDisplayIfNeeded(cm,update))break;updateHeightsInViewport(cm);var barMeasure=measureForScrollbars(cm);updateSelection(cm);setDocumentHeight(cm,barMeasure);updateScrollbars(cm,barMeasure)}update.signal(cm,"update",cm);if(cm.display.viewFrom!=cm.display.reportedViewFrom||cm.display.viewTo!=cm.display.reportedViewTo){update.signal(cm,"viewportChange",cm,cm.display.viewFrom,cm.display.viewTo);cm.display.reportedViewFrom=cm.display.viewFrom;cm.display.reportedViewTo=cm.display.viewTo}}function updateDisplaySimple(cm,viewport){var update=new DisplayUpdate(cm,viewport);if(updateDisplayIfNeeded(cm,update)){updateHeightsInViewport(cm);postUpdateDisplay(cm,update);var barMeasure=measureForScrollbars(cm);updateSelection(cm);setDocumentHeight(cm,barMeasure);updateScrollbars(cm,barMeasure);update.finish()}}function setDocumentHeight(cm,measure){cm.display.sizer.style.minHeight=measure.docHeight+"px";var total=measure.docHeight+cm.display.barHeight;cm.display.heightForcer.style.top=total+"px";cm.display.gutters.style.height=Math.max(total+scrollGap(cm),measure.clientHeight)+"px"} // Read the actual heights of the rendered lines, and update their
	// stored heights to match.
	function updateHeightsInViewport(cm){var display=cm.display;var prevBottom=display.lineDiv.offsetTop;for(var i=0;i<display.view.length;i++){var cur=display.view[i],height;if(cur.hidden)continue;if(ie&&ie_version<8){var bot=cur.node.offsetTop+cur.node.offsetHeight;height=bot-prevBottom;prevBottom=bot}else {var box=cur.node.getBoundingClientRect();height=box.bottom-box.top}var diff=cur.line.height-height;if(height<2)height=textHeight(display);if(diff>.001||diff<-.001){updateLineHeight(cur.line,height);updateWidgetHeight(cur.line);if(cur.rest)for(var j=0;j<cur.rest.length;j++)updateWidgetHeight(cur.rest[j])}}} // Read and store the height of line widgets associated with the
	// given line.
	function updateWidgetHeight(line){if(line.widgets)for(var i=0;i<line.widgets.length;++i)line.widgets[i].height=line.widgets[i].node.offsetHeight} // Do a bulk-read of the DOM positions and sizes needed to draw the
	// view, so that we don't interleave reading and writing to the DOM.
	function getDimensions(cm){var d=cm.display,left={},width={};var gutterLeft=d.gutters.clientLeft;for(var n=d.gutters.firstChild,i=0;n;n=n.nextSibling,++i){left[cm.options.gutters[i]]=n.offsetLeft+n.clientLeft+gutterLeft;width[cm.options.gutters[i]]=n.clientWidth}return {fixedPos:compensateForHScroll(d),gutterTotalWidth:d.gutters.offsetWidth,gutterLeft:left,gutterWidth:width,wrapperWidth:d.wrapper.clientWidth}} // Sync the actual display DOM structure with display.view, removing
	// nodes for lines that are no longer in view, and creating the ones
	// that are not there yet, and updating the ones that are out of
	// date.
	function patchDisplay(cm,updateNumbersFrom,dims){var display=cm.display,lineNumbers=cm.options.lineNumbers;var container=display.lineDiv,cur=container.firstChild;function rm(node){var next=node.nextSibling; // Works around a throw-scroll bug in OS X Webkit
	if(webkit&&mac&&cm.display.currentWheelTarget==node)node.style.display="none";else node.parentNode.removeChild(node);return next}var view=display.view,lineN=display.viewFrom; // Loop over the elements in the view, syncing cur (the DOM nodes
	// in display.lineDiv) with the view as we go.
	for(var i=0;i<view.length;i++){var lineView=view[i];if(lineView.hidden){}else if(!lineView.node||lineView.node.parentNode!=container){ // Not drawn yet
	var node=buildLineElement(cm,lineView,lineN,dims);container.insertBefore(node,cur)}else { // Already drawn
	while(cur!=lineView.node)cur=rm(cur);var updateNumber=lineNumbers&&updateNumbersFrom!=null&&updateNumbersFrom<=lineN&&lineView.lineNumber;if(lineView.changes){if(indexOf(lineView.changes,"gutter")>-1)updateNumber=false;updateLineForChanges(cm,lineView,lineN,dims)}if(updateNumber){removeChildren(lineView.lineNumber);lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options,lineN)))}cur=lineView.node.nextSibling}lineN+=lineView.size}while(cur)cur=rm(cur)} // When an aspect of a line changes, a string is added to
	// lineView.changes. This updates the relevant part of the line's
	// DOM structure.
	function updateLineForChanges(cm,lineView,lineN,dims){for(var j=0;j<lineView.changes.length;j++){var type=lineView.changes[j];if(type=="text")updateLineText(cm,lineView);else if(type=="gutter")updateLineGutter(cm,lineView,lineN,dims);else if(type=="class")updateLineClasses(lineView);else if(type=="widget")updateLineWidgets(cm,lineView,dims)}lineView.changes=null} // Lines with gutter elements, widgets or a background class need to
	// be wrapped, and have the extra elements added to the wrapper div
	function ensureLineWrapped(lineView){if(lineView.node==lineView.text){lineView.node=elt("div",null,null,"position: relative");if(lineView.text.parentNode)lineView.text.parentNode.replaceChild(lineView.node,lineView.text);lineView.node.appendChild(lineView.text);if(ie&&ie_version<8)lineView.node.style.zIndex=2}return lineView.node}function updateLineBackground(lineView){var cls=lineView.bgClass?lineView.bgClass+" "+(lineView.line.bgClass||""):lineView.line.bgClass;if(cls)cls+=" CodeMirror-linebackground";if(lineView.background){if(cls)lineView.background.className=cls;else {lineView.background.parentNode.removeChild(lineView.background);lineView.background=null}}else if(cls){var wrap=ensureLineWrapped(lineView);lineView.background=wrap.insertBefore(elt("div",null,cls),wrap.firstChild)}} // Wrapper around buildLineContent which will reuse the structure
	// in display.externalMeasured when possible.
	function getLineContent(cm,lineView){var ext=cm.display.externalMeasured;if(ext&&ext.line==lineView.line){cm.display.externalMeasured=null;lineView.measure=ext.measure;return ext.built}return buildLineContent(cm,lineView)} // Redraw the line's text. Interacts with the background and text
	// classes because the mode may output tokens that influence these
	// classes.
	function updateLineText(cm,lineView){var cls=lineView.text.className;var built=getLineContent(cm,lineView);if(lineView.text==lineView.node)lineView.node=built.pre;lineView.text.parentNode.replaceChild(built.pre,lineView.text);lineView.text=built.pre;if(built.bgClass!=lineView.bgClass||built.textClass!=lineView.textClass){lineView.bgClass=built.bgClass;lineView.textClass=built.textClass;updateLineClasses(lineView)}else if(cls){lineView.text.className=cls}}function updateLineClasses(lineView){updateLineBackground(lineView);if(lineView.line.wrapClass)ensureLineWrapped(lineView).className=lineView.line.wrapClass;else if(lineView.node!=lineView.text)lineView.node.className="";var textClass=lineView.textClass?lineView.textClass+" "+(lineView.line.textClass||""):lineView.line.textClass;lineView.text.className=textClass||""}function updateLineGutter(cm,lineView,lineN,dims){if(lineView.gutter){lineView.node.removeChild(lineView.gutter);lineView.gutter=null}if(lineView.gutterBackground){lineView.node.removeChild(lineView.gutterBackground);lineView.gutterBackground=null}if(lineView.line.gutterClass){var wrap=ensureLineWrapped(lineView);lineView.gutterBackground=elt("div",null,"CodeMirror-gutter-background "+lineView.line.gutterClass,"left: "+(cm.options.fixedGutter?dims.fixedPos:-dims.gutterTotalWidth)+"px; width: "+dims.gutterTotalWidth+"px");wrap.insertBefore(lineView.gutterBackground,lineView.text)}var markers=lineView.line.gutterMarkers;if(cm.options.lineNumbers||markers){var wrap=ensureLineWrapped(lineView);var gutterWrap=lineView.gutter=elt("div",null,"CodeMirror-gutter-wrapper","left: "+(cm.options.fixedGutter?dims.fixedPos:-dims.gutterTotalWidth)+"px");cm.display.input.setUneditable(gutterWrap);wrap.insertBefore(gutterWrap,lineView.text);if(lineView.line.gutterClass)gutterWrap.className+=" "+lineView.line.gutterClass;if(cm.options.lineNumbers&&(!markers||!markers["CodeMirror-linenumbers"]))lineView.lineNumber=gutterWrap.appendChild(elt("div",lineNumberFor(cm.options,lineN),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+dims.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+cm.display.lineNumInnerWidth+"px"));if(markers)for(var k=0;k<cm.options.gutters.length;++k){var id=cm.options.gutters[k],found=markers.hasOwnProperty(id)&&markers[id];if(found)gutterWrap.appendChild(elt("div",[found],"CodeMirror-gutter-elt","left: "+dims.gutterLeft[id]+"px; width: "+dims.gutterWidth[id]+"px"))}}}function updateLineWidgets(cm,lineView,dims){if(lineView.alignable)lineView.alignable=null;for(var node=lineView.node.firstChild,next;node;node=next){var next=node.nextSibling;if(node.className=="CodeMirror-linewidget")lineView.node.removeChild(node)}insertLineWidgets(cm,lineView,dims)} // Build a line's DOM representation from scratch
	function buildLineElement(cm,lineView,lineN,dims){var built=getLineContent(cm,lineView);lineView.text=lineView.node=built.pre;if(built.bgClass)lineView.bgClass=built.bgClass;if(built.textClass)lineView.textClass=built.textClass;updateLineClasses(lineView);updateLineGutter(cm,lineView,lineN,dims);insertLineWidgets(cm,lineView,dims);return lineView.node} // A lineView may contain multiple logical lines (when merged by
	// collapsed spans). The widgets for all of them need to be drawn.
	function insertLineWidgets(cm,lineView,dims){insertLineWidgetsFor(cm,lineView.line,lineView,dims,true);if(lineView.rest)for(var i=0;i<lineView.rest.length;i++)insertLineWidgetsFor(cm,lineView.rest[i],lineView,dims,false)}function insertLineWidgetsFor(cm,line,lineView,dims,allowAbove){if(!line.widgets)return;var wrap=ensureLineWrapped(lineView);for(var i=0,ws=line.widgets;i<ws.length;++i){var widget=ws[i],node=elt("div",[widget.node],"CodeMirror-linewidget");if(!widget.handleMouseEvents)node.setAttribute("cm-ignore-events","true");positionLineWidget(widget,node,lineView,dims);cm.display.input.setUneditable(node);if(allowAbove&&widget.above)wrap.insertBefore(node,lineView.gutter||lineView.text);else wrap.appendChild(node);signalLater(widget,"redraw")}}function positionLineWidget(widget,node,lineView,dims){if(widget.noHScroll){(lineView.alignable||(lineView.alignable=[])).push(node);var width=dims.wrapperWidth;node.style.left=dims.fixedPos+"px";if(!widget.coverGutter){width-=dims.gutterTotalWidth;node.style.paddingLeft=dims.gutterTotalWidth+"px"}node.style.width=width+"px"}if(widget.coverGutter){node.style.zIndex=5;node.style.position="relative";if(!widget.noHScroll)node.style.marginLeft=-dims.gutterTotalWidth+"px"}} // POSITION OBJECT
	// A Pos instance represents a position within the text.
	var Pos=CodeMirror.Pos=function(line,ch){if(!(this instanceof Pos))return new Pos(line,ch);this.line=line;this.ch=ch}; // Compare two positions, return 0 if they are the same, a negative
	// number when a is less, and a positive number otherwise.
	var cmp=CodeMirror.cmpPos=function(a,b){return a.line-b.line||a.ch-b.ch};function copyPos(x){return Pos(x.line,x.ch)}function maxPos(a,b){return cmp(a,b)<0?b:a}function minPos(a,b){return cmp(a,b)<0?a:b} // INPUT HANDLING
	function ensureFocus(cm){if(!cm.state.focused){cm.display.input.focus();onFocus(cm)}}function isReadOnly(cm){return cm.options.readOnly||cm.doc.cantEdit} // This will be set to an array of strings when copying, so that,
	// when pasting, we know what kind of selections the copied text
	// was made out of.
	var lastCopied=null;function applyTextInput(cm,inserted,deleted,sel,origin){var doc=cm.doc;cm.display.shift=false;if(!sel)sel=doc.sel;var paste=cm.state.pasteIncoming||origin=="paste";var textLines=doc.splitLines(inserted),multiPaste=null; // When pasing N lines into N selections, insert one line per selection
	if(paste&&sel.ranges.length>1){if(lastCopied&&lastCopied.join("\n")==inserted){if(sel.ranges.length%lastCopied.length==0){multiPaste=[];for(var i=0;i<lastCopied.length;i++)multiPaste.push(doc.splitLines(lastCopied[i]))}}else if(textLines.length==sel.ranges.length){multiPaste=map(textLines,function(l){return [l]})}} // Normal behavior is to insert the new text into every selection
	for(var i=sel.ranges.length-1;i>=0;i--){var range=sel.ranges[i];var from=range.from(),to=range.to();if(range.empty()){if(deleted&&deleted>0) // Handle deletion
	from=Pos(from.line,from.ch-deleted);else if(cm.state.overwrite&&!paste) // Handle overwrite
	to=Pos(to.line,Math.min(getLine(doc,to.line).text.length,to.ch+lst(textLines).length))}var updateInput=cm.curOp.updateInput;var changeEvent={from:from,to:to,text:multiPaste?multiPaste[i%multiPaste.length]:textLines,origin:origin||(paste?"paste":cm.state.cutIncoming?"cut":"+input")};makeChange(cm.doc,changeEvent);signalLater(cm,"inputRead",cm,changeEvent)}if(inserted&&!paste)triggerElectric(cm,inserted);ensureCursorVisible(cm);cm.curOp.updateInput=updateInput;cm.curOp.typing=true;cm.state.pasteIncoming=cm.state.cutIncoming=false}function handlePaste(e,cm){var pasted=e.clipboardData&&e.clipboardData.getData("text/plain");if(pasted){e.preventDefault();if(!isReadOnly(cm)&&!cm.options.disableInput)runInOp(cm,function(){applyTextInput(cm,pasted,0,null,"paste")});return true}}function triggerElectric(cm,inserted){ // When an 'electric' character is inserted, immediately trigger a reindent
	if(!cm.options.electricChars||!cm.options.smartIndent)return;var sel=cm.doc.sel;for(var i=sel.ranges.length-1;i>=0;i--){var range=sel.ranges[i];if(range.head.ch>100||i&&sel.ranges[i-1].head.line==range.head.line)continue;var mode=cm.getModeAt(range.head);var indented=false;if(mode.electricChars){for(var j=0;j<mode.electricChars.length;j++)if(inserted.indexOf(mode.electricChars.charAt(j))>-1){indented=indentLine(cm,range.head.line,"smart");break}}else if(mode.electricInput){if(mode.electricInput.test(getLine(cm.doc,range.head.line).text.slice(0,range.head.ch)))indented=indentLine(cm,range.head.line,"smart")}if(indented)signalLater(cm,"electricInput",cm,range.head.line)}}function copyableRanges(cm){var text=[],ranges=[];for(var i=0;i<cm.doc.sel.ranges.length;i++){var line=cm.doc.sel.ranges[i].head.line;var lineRange={anchor:Pos(line,0),head:Pos(line+1,0)};ranges.push(lineRange);text.push(cm.getRange(lineRange.anchor,lineRange.head))}return {text:text,ranges:ranges}}function disableBrowserMagic(field){field.setAttribute("autocorrect","off");field.setAttribute("autocapitalize","off");field.setAttribute("spellcheck","false")} // TEXTAREA INPUT STYLE
	function TextareaInput(cm){this.cm=cm; // See input.poll and input.reset
	this.prevInput=""; // Flag that indicates whether we expect input to appear real soon
	// now (after some event like 'keypress' or 'input') and are
	// polling intensively.
	this.pollingFast=false; // Self-resetting timeout for the poller
	this.polling=new Delayed; // Tracks when input.reset has punted to just putting a short
	// string into the textarea instead of the full selection.
	this.inaccurateSelection=false; // Used to work around IE issue with selection being forgotten when focus moves away from textarea
	this.hasSelection=false;this.composing=null};function hiddenTextarea(){var te=elt("textarea",null,null,"position: absolute; padding: 0; width: 1px; height: 1em; outline: none");var div=elt("div",[te],null,"overflow: hidden; position: relative; width: 3px; height: 0px;"); // The textarea is kept positioned near the cursor to prevent the
	// fact that it'll be scrolled into view on input from scrolling
	// our fake cursor out of view. On webkit, when wrap=off, paste is
	// very slow. So make the area wide instead.
	if(webkit)te.style.width="1000px";else te.setAttribute("wrap","off"); // If border: 0; -- iOS fails to open keyboard (issue #1287)
	if(ios)te.style.border="1px solid black";disableBrowserMagic(te);return div}TextareaInput.prototype=copyObj({init:function(display){var input=this,cm=this.cm; // Wraps and hides input textarea
	var div=this.wrapper=hiddenTextarea(); // The semihidden textarea that is focused when the editor is
	// focused, and receives input.
	var te=this.textarea=div.firstChild;display.wrapper.insertBefore(div,display.wrapper.firstChild); // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)
	if(ios)te.style.width="0px";on(te,"input",function(){if(ie&&ie_version>=9&&input.hasSelection)input.hasSelection=null;input.poll()});on(te,"paste",function(e){if(handlePaste(e,cm))return true;cm.state.pasteIncoming=true;input.fastPoll()});function prepareCopyCut(e){if(cm.somethingSelected()){lastCopied=cm.getSelections();if(input.inaccurateSelection){input.prevInput="";input.inaccurateSelection=false;te.value=lastCopied.join("\n");selectInput(te)}}else if(!cm.options.lineWiseCopyCut){return}else {var ranges=copyableRanges(cm);lastCopied=ranges.text;if(e.type=="cut"){cm.setSelections(ranges.ranges,null,sel_dontScroll)}else {input.prevInput="";te.value=ranges.text.join("\n");selectInput(te)}}if(e.type=="cut")cm.state.cutIncoming=true}on(te,"cut",prepareCopyCut);on(te,"copy",prepareCopyCut);on(display.scroller,"paste",function(e){if(eventInWidget(display,e))return;cm.state.pasteIncoming=true;input.focus()}); // Prevent normal selection in the editor (we handle our own)
	on(display.lineSpace,"selectstart",function(e){if(!eventInWidget(display,e))e_preventDefault(e)});on(te,"compositionstart",function(){var start=cm.getCursor("from");if(input.composing)input.composing.range.clear();input.composing={start:start,range:cm.markText(start,cm.getCursor("to"),{className:"CodeMirror-composing"})}});on(te,"compositionend",function(){if(input.composing){input.poll();input.composing.range.clear();input.composing=null}})},prepareSelection:function(){ // Redraw the selection and/or cursor
	var cm=this.cm,display=cm.display,doc=cm.doc;var result=prepareSelection(cm); // Move the hidden textarea near the cursor to prevent scrolling artifacts
	if(cm.options.moveInputWithCursor){var headPos=cursorCoords(cm,doc.sel.primary().head,"div");var wrapOff=display.wrapper.getBoundingClientRect(),lineOff=display.lineDiv.getBoundingClientRect();result.teTop=Math.max(0,Math.min(display.wrapper.clientHeight-10,headPos.top+lineOff.top-wrapOff.top));result.teLeft=Math.max(0,Math.min(display.wrapper.clientWidth-10,headPos.left+lineOff.left-wrapOff.left))}return result},showSelection:function(drawn){var cm=this.cm,display=cm.display;removeChildrenAndAdd(display.cursorDiv,drawn.cursors);removeChildrenAndAdd(display.selectionDiv,drawn.selection);if(drawn.teTop!=null){this.wrapper.style.top=drawn.teTop+"px";this.wrapper.style.left=drawn.teLeft+"px"}}, // Reset the input to correspond to the selection (or to be empty,
	// when not typing and nothing is selected)
	reset:function(typing){if(this.contextMenuPending)return;var minimal,selected,cm=this.cm,doc=cm.doc;if(cm.somethingSelected()){this.prevInput="";var range=doc.sel.primary();minimal=hasCopyEvent&&(range.to().line-range.from().line>100||(selected=cm.getSelection()).length>1000);var content=minimal?"-":selected||cm.getSelection();this.textarea.value=content;if(cm.state.focused)selectInput(this.textarea);if(ie&&ie_version>=9)this.hasSelection=content}else if(!typing){this.prevInput=this.textarea.value="";if(ie&&ie_version>=9)this.hasSelection=null}this.inaccurateSelection=minimal},getField:function(){return this.textarea},supportsTouch:function(){return false},focus:function(){if(this.cm.options.readOnly!="nocursor"&&(!mobile||activeElt()!=this.textarea)){try{this.textarea.focus()}catch(e) {} // IE8 will throw if the textarea is display: none or not in DOM
	}},blur:function(){this.textarea.blur()},resetPosition:function(){this.wrapper.style.top=this.wrapper.style.left=0},receivedFocus:function(){this.slowPoll()}, // Poll for input changes, using the normal rate of polling. This
	// runs as long as the editor is focused.
	slowPoll:function(){var input=this;if(input.pollingFast)return;input.polling.set(this.cm.options.pollInterval,function(){input.poll();if(input.cm.state.focused)input.slowPoll()})}, // When an event has just come in that is likely to add or change
	// something in the input textarea, we poll faster, to ensure that
	// the change appears on the screen quickly.
	fastPoll:function(){var missed=false,input=this;input.pollingFast=true;function p(){var changed=input.poll();if(!changed&&!missed){missed=true;input.polling.set(60,p)}else {input.pollingFast=false;input.slowPoll()}}input.polling.set(20,p)}, // Read input from the textarea, and update the document to match.
	// When something is selected, it is present in the textarea, and
	// selected (unless it is huge, in which case a placeholder is
	// used). When nothing is selected, the cursor sits after previously
	// seen text (can be empty), which is stored in prevInput (we must
	// not reset the textarea when typing, because that breaks IME).
	poll:function(){var cm=this.cm,input=this.textarea,prevInput=this.prevInput; // Since this is called a *lot*, try to bail out as cheaply as
	// possible when it is clear that nothing happened. hasSelection
	// will be the case when there is a lot of text in the textarea,
	// in which case reading its value would be expensive.
	if(this.contextMenuPending||!cm.state.focused||hasSelection(input)&&!prevInput&&!this.composing||isReadOnly(cm)||cm.options.disableInput||cm.state.keySeq)return false;var text=input.value; // If nothing changed, bail.
	if(text==prevInput&&!cm.somethingSelected())return false; // Work around nonsensical selection resetting in IE9/10, and
	// inexplicable appearance of private area unicode characters on
	// some key combos in Mac (#2689).
	if(ie&&ie_version>=9&&this.hasSelection===text||mac&&/[\uf700-\uf7ff]/.test(text)){cm.display.input.reset();return false}if(cm.doc.sel==cm.display.selForContextMenu){var first=text.charCodeAt(0);if(first==0x200b&&!prevInput)prevInput="\u200b";if(first==0x21da){this.reset();return this.cm.execCommand("undo")}} // Find the part of the input that is actually new
	var same=0,l=Math.min(prevInput.length,text.length);while(same<l&&prevInput.charCodeAt(same)==text.charCodeAt(same))++same;var self=this;runInOp(cm,function(){applyTextInput(cm,text.slice(same),prevInput.length-same,null,self.composing?"*compose":null); // Don't leave long text in the textarea, since it makes further polling slow
	if(text.length>1000||text.indexOf("\n")>-1)input.value=self.prevInput="";else self.prevInput=text;if(self.composing){self.composing.range.clear();self.composing.range=cm.markText(self.composing.start,cm.getCursor("to"),{className:"CodeMirror-composing"})}});return true},ensurePolled:function(){if(this.pollingFast&&this.poll())this.pollingFast=false},onKeyPress:function(){if(ie&&ie_version>=9)this.hasSelection=null;this.fastPoll()},onContextMenu:function(e){var input=this,cm=input.cm,display=cm.display,te=input.textarea;var pos=posFromMouse(cm,e),scrollPos=display.scroller.scrollTop;if(!pos||presto)return; // Opera is difficult.
	// Reset the current text selection only if the click is done outside of the selection
	// and 'resetSelectionOnContextMenu' option is true.
	var reset=cm.options.resetSelectionOnContextMenu;if(reset&&cm.doc.sel.contains(pos)==-1)operation(cm,setSelection)(cm.doc,simpleSelection(pos),sel_dontScroll);var oldCSS=te.style.cssText;input.wrapper.style.position="absolute";te.style.cssText="position: fixed; width: 30px; height: 30px; top: "+(e.clientY-5)+"px; left: "+(e.clientX-5)+"px; z-index: 1000; background: "+(ie?"rgba(255, 255, 255, .05)":"transparent")+"; outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";if(webkit)var oldScrollY=window.scrollY; // Work around Chrome issue (#2712)
	display.input.focus();if(webkit)window.scrollTo(null,oldScrollY);display.input.reset(); // Adds "Select all" to context menu in FF
	if(!cm.somethingSelected())te.value=input.prevInput=" ";input.contextMenuPending=true;display.selForContextMenu=cm.doc.sel;clearTimeout(display.detectingSelectAll); // Select-all will be greyed out if there's nothing to select, so
	// this adds a zero-width space so that we can later check whether
	// it got selected.
	function prepareSelectAllHack(){if(te.selectionStart!=null){var selected=cm.somethingSelected();var extval="\u200b"+(selected?te.value:"");te.value="\u21da"; // Used to catch context-menu undo
	te.value=extval;input.prevInput=selected?"":"\u200b";te.selectionStart=1;te.selectionEnd=extval.length; // Re-set this, in case some other handler touched the
	// selection in the meantime.
	display.selForContextMenu=cm.doc.sel}}function rehide(){input.contextMenuPending=false;input.wrapper.style.position="relative";te.style.cssText=oldCSS;if(ie&&ie_version<9)display.scrollbars.setScrollTop(display.scroller.scrollTop=scrollPos); // Try to detect the user choosing select-all
	if(te.selectionStart!=null){if(!ie||ie&&ie_version<9)prepareSelectAllHack();var i=0,poll=function(){if(display.selForContextMenu==cm.doc.sel&&te.selectionStart==0&&te.selectionEnd>0&&input.prevInput=="\u200b")operation(cm,commands.selectAll)(cm);else if(i++<10)display.detectingSelectAll=setTimeout(poll,500);else display.input.reset()};display.detectingSelectAll=setTimeout(poll,200)}}if(ie&&ie_version>=9)prepareSelectAllHack();if(captureRightClick){e_stop(e);var mouseup=function(){off(window,"mouseup",mouseup);setTimeout(rehide,20)};on(window,"mouseup",mouseup)}else {setTimeout(rehide,50)}},readOnlyChanged:function(val){if(!val)this.reset()},setUneditable:nothing,needsContentAttribute:false},TextareaInput.prototype); // CONTENTEDITABLE INPUT STYLE
	function ContentEditableInput(cm){this.cm=cm;this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null;this.polling=new Delayed;this.gracePeriod=false}ContentEditableInput.prototype=copyObj({init:function(display){var input=this,cm=input.cm;var div=input.div=display.lineDiv;disableBrowserMagic(div);on(div,"paste",function(e){handlePaste(e,cm)});on(div,"compositionstart",function(e){var data=e.data;input.composing={sel:cm.doc.sel,data:data,startData:data};if(!data)return;var prim=cm.doc.sel.primary();var line=cm.getLine(prim.head.line);var found=line.indexOf(data,Math.max(0,prim.head.ch-data.length));if(found>-1&&found<=prim.head.ch)input.composing.sel=simpleSelection(Pos(prim.head.line,found),Pos(prim.head.line,found+data.length))});on(div,"compositionupdate",function(e){input.composing.data=e.data});on(div,"compositionend",function(e){var ours=input.composing;if(!ours)return;if(e.data!=ours.startData&&!/\u200b/.test(e.data))ours.data=e.data; // Need a small delay to prevent other code (input event,
	// selection polling) from doing damage when fired right after
	// compositionend.
	setTimeout(function(){if(!ours.handled)input.applyComposition(ours);if(input.composing==ours)input.composing=null},50)});on(div,"touchstart",function(){input.forceCompositionEnd()});on(div,"input",function(){if(input.composing)return;if(isReadOnly(cm)||!input.pollContent())runInOp(input.cm,function(){regChange(cm)})});function onCopyCut(e){if(cm.somethingSelected()){lastCopied=cm.getSelections();if(e.type=="cut")cm.replaceSelection("",null,"cut")}else if(!cm.options.lineWiseCopyCut){return}else {var ranges=copyableRanges(cm);lastCopied=ranges.text;if(e.type=="cut"){cm.operation(function(){cm.setSelections(ranges.ranges,0,sel_dontScroll);cm.replaceSelection("",null,"cut")})}} // iOS exposes the clipboard API, but seems to discard content inserted into it
	if(e.clipboardData&&!ios){e.preventDefault();e.clipboardData.clearData();e.clipboardData.setData("text/plain",lastCopied.join("\n"))}else { // Old-fashioned briefly-focus-a-textarea hack
	var kludge=hiddenTextarea(),te=kludge.firstChild;cm.display.lineSpace.insertBefore(kludge,cm.display.lineSpace.firstChild);te.value=lastCopied.join("\n");var hadFocus=document.activeElement;selectInput(te);setTimeout(function(){cm.display.lineSpace.removeChild(kludge);hadFocus.focus()},50)}}on(div,"copy",onCopyCut);on(div,"cut",onCopyCut)},prepareSelection:function(){var result=prepareSelection(this.cm,false);result.focus=this.cm.state.focused;return result},showSelection:function(info){if(!info||!this.cm.display.view.length)return;if(info.focus)this.showPrimarySelection();this.showMultipleSelections(info)},showPrimarySelection:function(){var sel=window.getSelection(),prim=this.cm.doc.sel.primary();var curAnchor=domToPos(this.cm,sel.anchorNode,sel.anchorOffset);var curFocus=domToPos(this.cm,sel.focusNode,sel.focusOffset);if(curAnchor&&!curAnchor.bad&&curFocus&&!curFocus.bad&&cmp(minPos(curAnchor,curFocus),prim.from())==0&&cmp(maxPos(curAnchor,curFocus),prim.to())==0)return;var start=posToDOM(this.cm,prim.from());var end=posToDOM(this.cm,prim.to());if(!start&&!end)return;var view=this.cm.display.view;var old=sel.rangeCount&&sel.getRangeAt(0);if(!start){start={node:view[0].measure.map[2],offset:0}}else if(!end){ // FIXME dangerously hacky
	var measure=view[view.length-1].measure;var map=measure.maps?measure.maps[measure.maps.length-1]:measure.map;end={node:map[map.length-1],offset:map[map.length-2]-map[map.length-3]}}try{var rng=range(start.node,start.offset,end.offset,end.node)}catch(e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible
	if(rng){sel.removeAllRanges();sel.addRange(rng);if(old&&sel.anchorNode==null)sel.addRange(old);else if(gecko)this.startGracePeriod()}this.rememberSelection()},startGracePeriod:function(){var input=this;clearTimeout(this.gracePeriod);this.gracePeriod=setTimeout(function(){input.gracePeriod=false;if(input.selectionChanged())input.cm.operation(function(){input.cm.curOp.selectionChanged=true})},20)},showMultipleSelections:function(info){removeChildrenAndAdd(this.cm.display.cursorDiv,info.cursors);removeChildrenAndAdd(this.cm.display.selectionDiv,info.selection)},rememberSelection:function(){var sel=window.getSelection();this.lastAnchorNode=sel.anchorNode;this.lastAnchorOffset=sel.anchorOffset;this.lastFocusNode=sel.focusNode;this.lastFocusOffset=sel.focusOffset},selectionInEditor:function(){var sel=window.getSelection();if(!sel.rangeCount)return false;var node=sel.getRangeAt(0).commonAncestorContainer;return contains(this.div,node)},focus:function(){if(this.cm.options.readOnly!="nocursor")this.div.focus()},blur:function(){this.div.blur()},getField:function(){return this.div},supportsTouch:function(){return true},receivedFocus:function(){var input=this;if(this.selectionInEditor())this.pollSelection();else runInOp(this.cm,function(){input.cm.curOp.selectionChanged=true});function poll(){if(input.cm.state.focused){input.pollSelection();input.polling.set(input.cm.options.pollInterval,poll)}}this.polling.set(this.cm.options.pollInterval,poll)},selectionChanged:function(){var sel=window.getSelection();return sel.anchorNode!=this.lastAnchorNode||sel.anchorOffset!=this.lastAnchorOffset||sel.focusNode!=this.lastFocusNode||sel.focusOffset!=this.lastFocusOffset},pollSelection:function(){if(!this.composing&&!this.gracePeriod&&this.selectionChanged()){var sel=window.getSelection(),cm=this.cm;this.rememberSelection();var anchor=domToPos(cm,sel.anchorNode,sel.anchorOffset);var head=domToPos(cm,sel.focusNode,sel.focusOffset);if(anchor&&head)runInOp(cm,function(){setSelection(cm.doc,simpleSelection(anchor,head),sel_dontScroll);if(anchor.bad||head.bad)cm.curOp.selectionChanged=true})}},pollContent:function(){var cm=this.cm,display=cm.display,sel=cm.doc.sel.primary();var from=sel.from(),to=sel.to();if(from.line<display.viewFrom||to.line>display.viewTo-1)return false;var fromIndex;if(from.line==display.viewFrom||(fromIndex=findViewIndex(cm,from.line))==0){var fromLine=lineNo(display.view[0].line);var fromNode=display.view[0].node}else {var fromLine=lineNo(display.view[fromIndex].line);var fromNode=display.view[fromIndex-1].node.nextSibling}var toIndex=findViewIndex(cm,to.line);if(toIndex==display.view.length-1){var toLine=display.viewTo-1;var toNode=display.lineDiv.lastChild}else {var toLine=lineNo(display.view[toIndex+1].line)-1;var toNode=display.view[toIndex+1].node.previousSibling}var newText=cm.doc.splitLines(domTextBetween(cm,fromNode,toNode,fromLine,toLine));var oldText=getBetween(cm.doc,Pos(fromLine,0),Pos(toLine,getLine(cm.doc,toLine).text.length));while(newText.length>1&&oldText.length>1){if(lst(newText)==lst(oldText)){newText.pop();oldText.pop();toLine--}else if(newText[0]==oldText[0]){newText.shift();oldText.shift();fromLine++}else break}var cutFront=0,cutEnd=0;var newTop=newText[0],oldTop=oldText[0],maxCutFront=Math.min(newTop.length,oldTop.length);while(cutFront<maxCutFront&&newTop.charCodeAt(cutFront)==oldTop.charCodeAt(cutFront))++cutFront;var newBot=lst(newText),oldBot=lst(oldText);var maxCutEnd=Math.min(newBot.length-(newText.length==1?cutFront:0),oldBot.length-(oldText.length==1?cutFront:0));while(cutEnd<maxCutEnd&&newBot.charCodeAt(newBot.length-cutEnd-1)==oldBot.charCodeAt(oldBot.length-cutEnd-1))++cutEnd;newText[newText.length-1]=newBot.slice(0,newBot.length-cutEnd);newText[0]=newText[0].slice(cutFront);var chFrom=Pos(fromLine,cutFront);var chTo=Pos(toLine,oldText.length?lst(oldText).length-cutEnd:0);if(newText.length>1||newText[0]||cmp(chFrom,chTo)){replaceRange(cm.doc,newText,chFrom,chTo,"+input");return true}},ensurePolled:function(){this.forceCompositionEnd()},reset:function(){this.forceCompositionEnd()},forceCompositionEnd:function(){if(!this.composing||this.composing.handled)return;this.applyComposition(this.composing);this.composing.handled=true;this.div.blur();this.div.focus()},applyComposition:function(composing){if(isReadOnly(this.cm))operation(this.cm,regChange)(this.cm);else if(composing.data&&composing.data!=composing.startData)operation(this.cm,applyTextInput)(this.cm,composing.data,0,composing.sel)},setUneditable:function(node){node.contentEditable="false"},onKeyPress:function(e){e.preventDefault();if(!isReadOnly(this.cm))operation(this.cm,applyTextInput)(this.cm,String.fromCharCode(e.charCode==null?e.keyCode:e.charCode),0)},readOnlyChanged:function(val){this.div.contentEditable=String(val!="nocursor")},onContextMenu:nothing,resetPosition:nothing,needsContentAttribute:true},ContentEditableInput.prototype);function posToDOM(cm,pos){var view=findViewForLine(cm,pos.line);if(!view||view.hidden)return null;var line=getLine(cm.doc,pos.line);var info=mapFromLineView(view,line,pos.line);var order=getOrder(line),side="left";if(order){var partPos=getBidiPartAt(order,pos.ch);side=partPos%2?"right":"left"}var result=nodeAndOffsetInLineMap(info.map,pos.ch,side);result.offset=result.collapse=="right"?result.end:result.start;return result}function badPos(pos,bad){if(bad)pos.bad=true;return pos}function domToPos(cm,node,offset){var lineNode;if(node==cm.display.lineDiv){lineNode=cm.display.lineDiv.childNodes[offset];if(!lineNode)return badPos(cm.clipPos(Pos(cm.display.viewTo-1)),true);node=null;offset=0}else {for(lineNode=node;;lineNode=lineNode.parentNode){if(!lineNode||lineNode==cm.display.lineDiv)return null;if(lineNode.parentNode&&lineNode.parentNode==cm.display.lineDiv)break}}for(var i=0;i<cm.display.view.length;i++){var lineView=cm.display.view[i];if(lineView.node==lineNode)return locateNodeInLineView(lineView,node,offset)}}function locateNodeInLineView(lineView,node,offset){var wrapper=lineView.text.firstChild,bad=false;if(!node||!contains(wrapper,node))return badPos(Pos(lineNo(lineView.line),0),true);if(node==wrapper){bad=true;node=wrapper.childNodes[offset];offset=0;if(!node){var line=lineView.rest?lst(lineView.rest):lineView.line;return badPos(Pos(lineNo(line),line.text.length),bad)}}var textNode=node.nodeType==3?node:null,topNode=node;if(!textNode&&node.childNodes.length==1&&node.firstChild.nodeType==3){textNode=node.firstChild;if(offset)offset=textNode.nodeValue.length}while(topNode.parentNode!=wrapper)topNode=topNode.parentNode;var measure=lineView.measure,maps=measure.maps;function find(textNode,topNode,offset){for(var i=-1;i<(maps?maps.length:0);i++){var map=i<0?measure.map:maps[i];for(var j=0;j<map.length;j+=3){var curNode=map[j+2];if(curNode==textNode||curNode==topNode){var line=lineNo(i<0?lineView.line:lineView.rest[i]);var ch=map[j]+offset;if(offset<0||curNode!=textNode)ch=map[j+(offset?1:0)];return Pos(line,ch)}}}}var found=find(textNode,topNode,offset);if(found)return badPos(found,bad); // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems
	for(var after=topNode.nextSibling,dist=textNode?textNode.nodeValue.length-offset:0;after;after=after.nextSibling){found=find(after,after.firstChild,0);if(found)return badPos(Pos(found.line,found.ch-dist),bad);else dist+=after.textContent.length}for(var before=topNode.previousSibling,dist=offset;before;before=before.previousSibling){found=find(before,before.firstChild,-1);if(found)return badPos(Pos(found.line,found.ch+dist),bad);else dist+=after.textContent.length}}function domTextBetween(cm,from,to,fromLine,toLine){var text="",closing=false,lineSep=cm.doc.lineSeparator();function recognizeMarker(id){return function(marker){return marker.id==id}}function walk(node){if(node.nodeType==1){var cmText=node.getAttribute("cm-text");if(cmText!=null){if(cmText=="")cmText=node.textContent.replace(/\u200b/g,"");text+=cmText;return}var markerID=node.getAttribute("cm-marker"),range;if(markerID){var found=cm.findMarks(Pos(fromLine,0),Pos(toLine+1,0),recognizeMarker(+markerID));if(found.length&&(range=found[0].find()))text+=getBetween(cm.doc,range.from,range.to).join(lineSep);return}if(node.getAttribute("contenteditable")=="false")return;for(var i=0;i<node.childNodes.length;i++)walk(node.childNodes[i]);if(/^(pre|div|p)$/i.test(node.nodeName))closing=true}else if(node.nodeType==3){var val=node.nodeValue;if(!val)return;if(closing){text+=lineSep;closing=false}text+=val}}for(;;){walk(from);if(from==to)break;from=from.nextSibling}return text}CodeMirror.inputStyles={"textarea":TextareaInput,"contenteditable":ContentEditableInput}; // SELECTION / CURSOR
	// Selection objects are immutable. A new one is created every time
	// the selection changes. A selection is one or more non-overlapping
	// (and non-touching) ranges, sorted, and an integer that indicates
	// which one is the primary selection (the one that's scrolled into
	// view, that getCursor returns, etc).
	function Selection(ranges,primIndex){this.ranges=ranges;this.primIndex=primIndex}Selection.prototype={primary:function(){return this.ranges[this.primIndex]},equals:function(other){if(other==this)return true;if(other.primIndex!=this.primIndex||other.ranges.length!=this.ranges.length)return false;for(var i=0;i<this.ranges.length;i++){var here=this.ranges[i],there=other.ranges[i];if(cmp(here.anchor,there.anchor)!=0||cmp(here.head,there.head)!=0)return false}return true},deepCopy:function(){for(var out=[],i=0;i<this.ranges.length;i++)out[i]=new Range(copyPos(this.ranges[i].anchor),copyPos(this.ranges[i].head));return new Selection(out,this.primIndex)},somethingSelected:function(){for(var i=0;i<this.ranges.length;i++)if(!this.ranges[i].empty())return true;return false},contains:function(pos,end){if(!end)end=pos;for(var i=0;i<this.ranges.length;i++){var range=this.ranges[i];if(cmp(end,range.from())>=0&&cmp(pos,range.to())<=0)return i}return -1}};function Range(anchor,head){this.anchor=anchor;this.head=head}Range.prototype={from:function(){return minPos(this.anchor,this.head)},to:function(){return maxPos(this.anchor,this.head)},empty:function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch}}; // Take an unsorted, potentially overlapping set of ranges, and
	// build a selection out of it. 'Consumes' ranges array (modifying
	// it).
	function normalizeSelection(ranges,primIndex){var prim=ranges[primIndex];ranges.sort(function(a,b){return cmp(a.from(),b.from())});primIndex=indexOf(ranges,prim);for(var i=1;i<ranges.length;i++){var cur=ranges[i],prev=ranges[i-1];if(cmp(prev.to(),cur.from())>=0){var from=minPos(prev.from(),cur.from()),to=maxPos(prev.to(),cur.to());var inv=prev.empty()?cur.from()==cur.head:prev.from()==prev.head;if(i<=primIndex)--primIndex;ranges.splice(--i,2,new Range(inv?to:from,inv?from:to))}}return new Selection(ranges,primIndex)}function simpleSelection(anchor,head){return new Selection([new Range(anchor,head||anchor)],0)} // Most of the external API clips given positions to make sure they
	// actually exist within the document.
	function clipLine(doc,n){return Math.max(doc.first,Math.min(n,doc.first+doc.size-1))}function clipPos(doc,pos){if(pos.line<doc.first)return Pos(doc.first,0);var last=doc.first+doc.size-1;if(pos.line>last)return Pos(last,getLine(doc,last).text.length);return clipToLen(pos,getLine(doc,pos.line).text.length)}function clipToLen(pos,linelen){var ch=pos.ch;if(ch==null||ch>linelen)return Pos(pos.line,linelen);else if(ch<0)return Pos(pos.line,0);else return pos}function isLine(doc,l){return l>=doc.first&&l<doc.first+doc.size}function clipPosArray(doc,array){for(var out=[],i=0;i<array.length;i++)out[i]=clipPos(doc,array[i]);return out} // SELECTION UPDATES
	// The 'scroll' parameter given to many of these indicated whether
	// the new cursor position should be scrolled into view after
	// modifying the selection.
	// If shift is held or the extend flag is set, extends a range to
	// include a given position (and optionally a second position).
	// Otherwise, simply returns the range between the given positions.
	// Used for cursor motion and such.
	function extendRange(doc,range,head,other){if(doc.cm&&doc.cm.display.shift||doc.extend){var anchor=range.anchor;if(other){var posBefore=cmp(head,anchor)<0;if(posBefore!=cmp(other,anchor)<0){anchor=head;head=other}else if(posBefore!=cmp(head,other)<0){head=other}}return new Range(anchor,head)}else {return new Range(other||head,head)}} // Extend the primary selection range, discard the rest.
	function extendSelection(doc,head,other,options){setSelection(doc,new Selection([extendRange(doc,doc.sel.primary(),head,other)],0),options)} // Extend all selections (pos is an array of selections with length
	// equal the number of selections)
	function extendSelections(doc,heads,options){for(var out=[],i=0;i<doc.sel.ranges.length;i++)out[i]=extendRange(doc,doc.sel.ranges[i],heads[i],null);var newSel=normalizeSelection(out,doc.sel.primIndex);setSelection(doc,newSel,options)} // Updates a single range in the selection.
	function replaceOneSelection(doc,i,range,options){var ranges=doc.sel.ranges.slice(0);ranges[i]=range;setSelection(doc,normalizeSelection(ranges,doc.sel.primIndex),options)} // Reset the selection to a single range.
	function setSimpleSelection(doc,anchor,head,options){setSelection(doc,simpleSelection(anchor,head),options)} // Give beforeSelectionChange handlers a change to influence a
	// selection update.
	function filterSelectionChange(doc,sel){var obj={ranges:sel.ranges,update:function(ranges){this.ranges=[];for(var i=0;i<ranges.length;i++)this.ranges[i]=new Range(clipPos(doc,ranges[i].anchor),clipPos(doc,ranges[i].head))}};signal(doc,"beforeSelectionChange",doc,obj);if(doc.cm)signal(doc.cm,"beforeSelectionChange",doc.cm,obj);if(obj.ranges!=sel.ranges)return normalizeSelection(obj.ranges,obj.ranges.length-1);else return sel}function setSelectionReplaceHistory(doc,sel,options){var done=doc.history.done,last=lst(done);if(last&&last.ranges){done[done.length-1]=sel;setSelectionNoUndo(doc,sel,options)}else {setSelection(doc,sel,options)}} // Set a new selection.
	function setSelection(doc,sel,options){setSelectionNoUndo(doc,sel,options);addSelectionToHistory(doc,doc.sel,doc.cm?doc.cm.curOp.id:NaN,options)}function setSelectionNoUndo(doc,sel,options){if(hasHandler(doc,"beforeSelectionChange")||doc.cm&&hasHandler(doc.cm,"beforeSelectionChange"))sel=filterSelectionChange(doc,sel);var bias=options&&options.bias||(cmp(sel.primary().head,doc.sel.primary().head)<0?-1:1);setSelectionInner(doc,skipAtomicInSelection(doc,sel,bias,true));if(!(options&&options.scroll===false)&&doc.cm)ensureCursorVisible(doc.cm)}function setSelectionInner(doc,sel){if(sel.equals(doc.sel))return;doc.sel=sel;if(doc.cm){doc.cm.curOp.updateInput=doc.cm.curOp.selectionChanged=true;signalCursorActivity(doc.cm)}signalLater(doc,"cursorActivity",doc)} // Verify that the selection does not partially select any atomic
	// marked ranges.
	function reCheckSelection(doc){setSelectionInner(doc,skipAtomicInSelection(doc,doc.sel,null,false),sel_dontScroll)} // Return a selection that does not partially select any atomic
	// ranges.
	function skipAtomicInSelection(doc,sel,bias,mayClear){var out;for(var i=0;i<sel.ranges.length;i++){var range=sel.ranges[i];var newAnchor=skipAtomic(doc,range.anchor,bias,mayClear);var newHead=skipAtomic(doc,range.head,bias,mayClear);if(out||newAnchor!=range.anchor||newHead!=range.head){if(!out)out=sel.ranges.slice(0,i);out[i]=new Range(newAnchor,newHead)}}return out?normalizeSelection(out,sel.primIndex):sel} // Ensure a given position is not inside an atomic range.
	function skipAtomic(doc,pos,bias,mayClear){var flipped=false,curPos=pos;var dir=bias||1;doc.cantEdit=false;search: for(;;){var line=getLine(doc,curPos.line);if(line.markedSpans){for(var i=0;i<line.markedSpans.length;++i){var sp=line.markedSpans[i],m=sp.marker;if((sp.from==null||(m.inclusiveLeft?sp.from<=curPos.ch:sp.from<curPos.ch))&&(sp.to==null||(m.inclusiveRight?sp.to>=curPos.ch:sp.to>curPos.ch))){if(mayClear){signal(m,"beforeCursorEnter");if(m.explicitlyCleared){if(!line.markedSpans)break;else {--i;continue}}}if(!m.atomic)continue;var newPos=m.find(dir<0?-1:1);if(cmp(newPos,curPos)==0){newPos.ch+=dir;if(newPos.ch<0){if(newPos.line>doc.first)newPos=clipPos(doc,Pos(newPos.line-1));else newPos=null}else if(newPos.ch>line.text.length){if(newPos.line<doc.first+doc.size-1)newPos=Pos(newPos.line+1,0);else newPos=null}if(!newPos){if(flipped){ // Driven in a corner -- no valid cursor position found at all
	// -- try again *with* clearing, if we didn't already
	if(!mayClear)return skipAtomic(doc,pos,bias,true); // Otherwise, turn off editing until further notice, and return the start of the doc
	doc.cantEdit=true;return Pos(doc.first,0)}flipped=true;newPos=pos;dir=-dir}}curPos=newPos;continue search}}}return curPos}} // SELECTION DRAWING
	function updateSelection(cm){cm.display.input.showSelection(cm.display.input.prepareSelection())}function prepareSelection(cm,primary){var doc=cm.doc,result={};var curFragment=result.cursors=document.createDocumentFragment();var selFragment=result.selection=document.createDocumentFragment();for(var i=0;i<doc.sel.ranges.length;i++){if(primary===false&&i==doc.sel.primIndex)continue;var range=doc.sel.ranges[i];var collapsed=range.empty();if(collapsed||cm.options.showCursorWhenSelecting)drawSelectionCursor(cm,range.head,curFragment);if(!collapsed)drawSelectionRange(cm,range,selFragment)}return result} // Draws a cursor for the given range
	function drawSelectionCursor(cm,head,output){var pos=cursorCoords(cm,head,"div",null,null,!cm.options.singleCursorHeightPerLine);var cursor=output.appendChild(elt("div","\u00a0","CodeMirror-cursor"));cursor.style.left=pos.left+"px";cursor.style.top=pos.top+"px";cursor.style.height=Math.max(0,pos.bottom-pos.top)*cm.options.cursorHeight+"px";if(pos.other){ // Secondary cursor, shown when on a 'jump' in bi-directional text
	var otherCursor=output.appendChild(elt("div","\u00a0","CodeMirror-cursor CodeMirror-secondarycursor"));otherCursor.style.display="";otherCursor.style.left=pos.other.left+"px";otherCursor.style.top=pos.other.top+"px";otherCursor.style.height=(pos.other.bottom-pos.other.top)*.85+"px"}} // Draws the given range as a highlighted selection
	function drawSelectionRange(cm,range,output){var display=cm.display,doc=cm.doc;var fragment=document.createDocumentFragment();var padding=paddingH(cm.display),leftSide=padding.left;var rightSide=Math.max(display.sizerWidth,displayWidth(cm)-display.sizer.offsetLeft)-padding.right;function add(left,top,width,bottom){if(top<0)top=0;top=Math.round(top);bottom=Math.round(bottom);fragment.appendChild(elt("div",null,"CodeMirror-selected","position: absolute; left: "+left+"px; top: "+top+"px; width: "+(width==null?rightSide-left:width)+"px; height: "+(bottom-top)+"px"))}function drawForLine(line,fromArg,toArg){var lineObj=getLine(doc,line);var lineLen=lineObj.text.length;var start,end;function coords(ch,bias){return charCoords(cm,Pos(line,ch),"div",lineObj,bias)}iterateBidiSections(getOrder(lineObj),fromArg||0,toArg==null?lineLen:toArg,function(from,to,dir){var leftPos=coords(from,"left"),rightPos,left,right;if(from==to){rightPos=leftPos;left=right=leftPos.left}else {rightPos=coords(to-1,"right");if(dir=="rtl"){var tmp=leftPos;leftPos=rightPos;rightPos=tmp}left=leftPos.left;right=rightPos.right}if(fromArg==null&&from==0)left=leftSide;if(rightPos.top-leftPos.top>3){ // Different lines, draw top part
	add(left,leftPos.top,null,leftPos.bottom);left=leftSide;if(leftPos.bottom<rightPos.top)add(left,leftPos.bottom,null,rightPos.top)}if(toArg==null&&to==lineLen)right=rightSide;if(!start||leftPos.top<start.top||leftPos.top==start.top&&leftPos.left<start.left)start=leftPos;if(!end||rightPos.bottom>end.bottom||rightPos.bottom==end.bottom&&rightPos.right>end.right)end=rightPos;if(left<leftSide+1)left=leftSide;add(left,rightPos.top,right-left,rightPos.bottom)});return {start:start,end:end}}var sFrom=range.from(),sTo=range.to();if(sFrom.line==sTo.line){drawForLine(sFrom.line,sFrom.ch,sTo.ch)}else {var fromLine=getLine(doc,sFrom.line),toLine=getLine(doc,sTo.line);var singleVLine=visualLine(fromLine)==visualLine(toLine);var leftEnd=drawForLine(sFrom.line,sFrom.ch,singleVLine?fromLine.text.length+1:null).end;var rightStart=drawForLine(sTo.line,singleVLine?0:null,sTo.ch).start;if(singleVLine){if(leftEnd.top<rightStart.top-2){add(leftEnd.right,leftEnd.top,null,leftEnd.bottom);add(leftSide,rightStart.top,rightStart.left,rightStart.bottom)}else {add(leftEnd.right,leftEnd.top,rightStart.left-leftEnd.right,leftEnd.bottom)}}if(leftEnd.bottom<rightStart.top)add(leftSide,leftEnd.bottom,null,rightStart.top)}output.appendChild(fragment)} // Cursor-blinking
	function restartBlink(cm){if(!cm.state.focused)return;var display=cm.display;clearInterval(display.blinker);var on=true;display.cursorDiv.style.visibility="";if(cm.options.cursorBlinkRate>0)display.blinker=setInterval(function(){display.cursorDiv.style.visibility=(on=!on)?"":"hidden"},cm.options.cursorBlinkRate);else if(cm.options.cursorBlinkRate<0)display.cursorDiv.style.visibility="hidden"} // HIGHLIGHT WORKER
	function startWorker(cm,time){if(cm.doc.mode.startState&&cm.doc.frontier<cm.display.viewTo)cm.state.highlight.set(time,bind(highlightWorker,cm))}function highlightWorker(cm){var doc=cm.doc;if(doc.frontier<doc.first)doc.frontier=doc.first;if(doc.frontier>=cm.display.viewTo)return;var end=+new Date+cm.options.workTime;var state=copyState(doc.mode,getStateBefore(cm,doc.frontier));var changedLines=[];doc.iter(doc.frontier,Math.min(doc.first+doc.size,cm.display.viewTo+500),function(line){if(doc.frontier>=cm.display.viewFrom){ // Visible
	var oldStyles=line.styles,tooLong=line.text.length>cm.options.maxHighlightLength;var highlighted=highlightLine(cm,line,tooLong?copyState(doc.mode,state):state,true);line.styles=highlighted.styles;var oldCls=line.styleClasses,newCls=highlighted.classes;if(newCls)line.styleClasses=newCls;else if(oldCls)line.styleClasses=null;var ischange=!oldStyles||oldStyles.length!=line.styles.length||oldCls!=newCls&&(!oldCls||!newCls||oldCls.bgClass!=newCls.bgClass||oldCls.textClass!=newCls.textClass);for(var i=0;!ischange&&i<oldStyles.length;++i)ischange=oldStyles[i]!=line.styles[i];if(ischange)changedLines.push(doc.frontier);line.stateAfter=tooLong?state:copyState(doc.mode,state)}else {if(line.text.length<=cm.options.maxHighlightLength)processLine(cm,line.text,state);line.stateAfter=doc.frontier%5==0?copyState(doc.mode,state):null}++doc.frontier;if(+new Date>end){startWorker(cm,cm.options.workDelay);return true}});if(changedLines.length)runInOp(cm,function(){for(var i=0;i<changedLines.length;i++)regLineChange(cm,changedLines[i],"text")})} // Finds the line to start with when starting a parse. Tries to
	// find a line with a stateAfter, so that it can start with a
	// valid state. If that fails, it returns the line with the
	// smallest indentation, which tends to need the least context to
	// parse correctly.
	function findStartLine(cm,n,precise){var minindent,minline,doc=cm.doc;var lim=precise?-1:n-(cm.doc.mode.innerMode?1000:100);for(var search=n;search>lim;--search){if(search<=doc.first)return doc.first;var line=getLine(doc,search-1);if(line.stateAfter&&(!precise||search<=doc.frontier))return search;var indented=countColumn(line.text,null,cm.options.tabSize);if(minline==null||minindent>indented){minline=search-1;minindent=indented}}return minline}function getStateBefore(cm,n,precise){var doc=cm.doc,display=cm.display;if(!doc.mode.startState)return true;var pos=findStartLine(cm,n,precise),state=pos>doc.first&&getLine(doc,pos-1).stateAfter;if(!state)state=startState(doc.mode);else state=copyState(doc.mode,state);doc.iter(pos,n,function(line){processLine(cm,line.text,state);var save=pos==n-1||pos%5==0||pos>=display.viewFrom&&pos<display.viewTo;line.stateAfter=save?copyState(doc.mode,state):null;++pos});if(precise)doc.frontier=pos;return state} // POSITION MEASUREMENT
	function paddingTop(display){return display.lineSpace.offsetTop}function paddingVert(display){return display.mover.offsetHeight-display.lineSpace.offsetHeight}function paddingH(display){if(display.cachedPaddingH)return display.cachedPaddingH;var e=removeChildrenAndAdd(display.measure,elt("pre","x"));var style=window.getComputedStyle?window.getComputedStyle(e):e.currentStyle;var data={left:parseInt(style.paddingLeft),right:parseInt(style.paddingRight)};if(!isNaN(data.left)&&!isNaN(data.right))display.cachedPaddingH=data;return data}function scrollGap(cm){return scrollerGap-cm.display.nativeBarWidth}function displayWidth(cm){return cm.display.scroller.clientWidth-scrollGap(cm)-cm.display.barWidth}function displayHeight(cm){return cm.display.scroller.clientHeight-scrollGap(cm)-cm.display.barHeight} // Ensure the lineView.wrapping.heights array is populated. This is
	// an array of bottom offsets for the lines that make up a drawn
	// line. When lineWrapping is on, there might be more than one
	// height.
	function ensureLineHeights(cm,lineView,rect){var wrapping=cm.options.lineWrapping;var curWidth=wrapping&&displayWidth(cm);if(!lineView.measure.heights||wrapping&&lineView.measure.width!=curWidth){var heights=lineView.measure.heights=[];if(wrapping){lineView.measure.width=curWidth;var rects=lineView.text.firstChild.getClientRects();for(var i=0;i<rects.length-1;i++){var cur=rects[i],next=rects[i+1];if(Math.abs(cur.bottom-next.bottom)>2)heights.push((cur.bottom+next.top)/2-rect.top)}}heights.push(rect.bottom-rect.top)}} // Find a line map (mapping character offsets to text nodes) and a
	// measurement cache for the given line number. (A line view might
	// contain multiple lines when collapsed ranges are present.)
	function mapFromLineView(lineView,line,lineN){if(lineView.line==line)return {map:lineView.measure.map,cache:lineView.measure.cache};for(var i=0;i<lineView.rest.length;i++)if(lineView.rest[i]==line)return {map:lineView.measure.maps[i],cache:lineView.measure.caches[i]};for(var i=0;i<lineView.rest.length;i++)if(lineNo(lineView.rest[i])>lineN)return {map:lineView.measure.maps[i],cache:lineView.measure.caches[i],before:true}} // Render a line into the hidden node display.externalMeasured. Used
	// when measurement is needed for a line that's not in the viewport.
	function updateExternalMeasurement(cm,line){line=visualLine(line);var lineN=lineNo(line);var view=cm.display.externalMeasured=new LineView(cm.doc,line,lineN);view.lineN=lineN;var built=view.built=buildLineContent(cm,view);view.text=built.pre;removeChildrenAndAdd(cm.display.lineMeasure,built.pre);return view} // Get a {top, bottom, left, right} box (in line-local coordinates)
	// for a given character.
	function measureChar(cm,line,ch,bias){return measureCharPrepared(cm,prepareMeasureForLine(cm,line),ch,bias)} // Find a line view that corresponds to the given line number.
	function findViewForLine(cm,lineN){if(lineN>=cm.display.viewFrom&&lineN<cm.display.viewTo)return cm.display.view[findViewIndex(cm,lineN)];var ext=cm.display.externalMeasured;if(ext&&lineN>=ext.lineN&&lineN<ext.lineN+ext.size)return ext} // Measurement can be split in two steps, the set-up work that
	// applies to the whole line, and the measurement of the actual
	// character. Functions like coordsChar, that need to do a lot of
	// measurements in a row, can thus ensure that the set-up work is
	// only done once.
	function prepareMeasureForLine(cm,line){var lineN=lineNo(line);var view=findViewForLine(cm,lineN);if(view&&!view.text){view=null}else if(view&&view.changes){updateLineForChanges(cm,view,lineN,getDimensions(cm));cm.curOp.forceUpdate=true}if(!view)view=updateExternalMeasurement(cm,line);var info=mapFromLineView(view,line,lineN);return {line:line,view:view,rect:null,map:info.map,cache:info.cache,before:info.before,hasHeights:false}} // Given a prepared measurement object, measures the position of an
	// actual character (or fetches it from the cache).
	function measureCharPrepared(cm,prepared,ch,bias,varHeight){if(prepared.before)ch=-1;var key=ch+(bias||""),found;if(prepared.cache.hasOwnProperty(key)){found=prepared.cache[key]}else {if(!prepared.rect)prepared.rect=prepared.view.text.getBoundingClientRect();if(!prepared.hasHeights){ensureLineHeights(cm,prepared.view,prepared.rect);prepared.hasHeights=true}found=measureCharInner(cm,prepared,ch,bias);if(!found.bogus)prepared.cache[key]=found}return {left:found.left,right:found.right,top:varHeight?found.rtop:found.top,bottom:varHeight?found.rbottom:found.bottom}}var nullRect={left:0,right:0,top:0,bottom:0};function nodeAndOffsetInLineMap(map,ch,bias){var node,start,end,collapse; // First, search the line map for the text node corresponding to,
	// or closest to, the target character.
	for(var i=0;i<map.length;i+=3){var mStart=map[i],mEnd=map[i+1];if(ch<mStart){start=0;end=1;collapse="left"}else if(ch<mEnd){start=ch-mStart;end=start+1}else if(i==map.length-3||ch==mEnd&&map[i+3]>ch){end=mEnd-mStart;start=end-1;if(ch>=mEnd)collapse="right"}if(start!=null){node=map[i+2];if(mStart==mEnd&&bias==(node.insertLeft?"left":"right"))collapse=bias;if(bias=="left"&&start==0)while(i&&map[i-2]==map[i-3]&&map[i-1].insertLeft){node=map[(i-=3)+2];collapse="left"}if(bias=="right"&&start==mEnd-mStart)while(i<map.length-3&&map[i+3]==map[i+4]&&!map[i+5].insertLeft){node=map[(i+=3)+2];collapse="right"}break}}return {node:node,start:start,end:end,collapse:collapse,coverStart:mStart,coverEnd:mEnd}}function measureCharInner(cm,prepared,ch,bias){var place=nodeAndOffsetInLineMap(prepared.map,ch,bias);var node=place.node,start=place.start,end=place.end,collapse=place.collapse;var rect;if(node.nodeType==3){ // If it is a text node, use a range to retrieve the coordinates.
	for(var i=0;i<4;i++){ // Retry a maximum of 4 times when nonsense rectangles are returned
	while(start&&isExtendingChar(prepared.line.text.charAt(place.coverStart+start)))--start;while(place.coverStart+end<place.coverEnd&&isExtendingChar(prepared.line.text.charAt(place.coverStart+end)))++end;if(ie&&ie_version<9&&start==0&&end==place.coverEnd-place.coverStart){rect=node.parentNode.getBoundingClientRect()}else if(ie&&cm.options.lineWrapping){var rects=range(node,start,end).getClientRects();if(rects.length)rect=rects[bias=="right"?rects.length-1:0];else rect=nullRect}else {rect=range(node,start,end).getBoundingClientRect()||nullRect}if(rect.left||rect.right||start==0)break;end=start;start=start-1;collapse="right"}if(ie&&ie_version<11)rect=maybeUpdateRectForZooming(cm.display.measure,rect)}else { // If it is a widget, simply get the box for the whole widget.
	if(start>0)collapse=bias="right";var rects;if(cm.options.lineWrapping&&(rects=node.getClientRects()).length>1)rect=rects[bias=="right"?rects.length-1:0];else rect=node.getBoundingClientRect()}if(ie&&ie_version<9&&!start&&(!rect||!rect.left&&!rect.right)){var rSpan=node.parentNode.getClientRects()[0];if(rSpan)rect={left:rSpan.left,right:rSpan.left+charWidth(cm.display),top:rSpan.top,bottom:rSpan.bottom};else rect=nullRect}var rtop=rect.top-prepared.rect.top,rbot=rect.bottom-prepared.rect.top;var mid=(rtop+rbot)/2;var heights=prepared.view.measure.heights;for(var i=0;i<heights.length-1;i++)if(mid<heights[i])break;var top=i?heights[i-1]:0,bot=heights[i];var result={left:(collapse=="right"?rect.right:rect.left)-prepared.rect.left,right:(collapse=="left"?rect.left:rect.right)-prepared.rect.left,top:top,bottom:bot};if(!rect.left&&!rect.right)result.bogus=true;if(!cm.options.singleCursorHeightPerLine){result.rtop=rtop;result.rbottom=rbot}return result} // Work around problem with bounding client rects on ranges being
	// returned incorrectly when zoomed on IE10 and below.
	function maybeUpdateRectForZooming(measure,rect){if(!window.screen||screen.logicalXDPI==null||screen.logicalXDPI==screen.deviceXDPI||!hasBadZoomedRects(measure))return rect;var scaleX=screen.logicalXDPI/screen.deviceXDPI;var scaleY=screen.logicalYDPI/screen.deviceYDPI;return {left:rect.left*scaleX,right:rect.right*scaleX,top:rect.top*scaleY,bottom:rect.bottom*scaleY}}function clearLineMeasurementCacheFor(lineView){if(lineView.measure){lineView.measure.cache={};lineView.measure.heights=null;if(lineView.rest)for(var i=0;i<lineView.rest.length;i++)lineView.measure.caches[i]={}}}function clearLineMeasurementCache(cm){cm.display.externalMeasure=null;removeChildren(cm.display.lineMeasure);for(var i=0;i<cm.display.view.length;i++)clearLineMeasurementCacheFor(cm.display.view[i])}function clearCaches(cm){clearLineMeasurementCache(cm);cm.display.cachedCharWidth=cm.display.cachedTextHeight=cm.display.cachedPaddingH=null;if(!cm.options.lineWrapping)cm.display.maxLineChanged=true;cm.display.lineNumChars=null}function pageScrollX(){return window.pageXOffset||(document.documentElement||document.body).scrollLeft}function pageScrollY(){return window.pageYOffset||(document.documentElement||document.body).scrollTop} // Converts a {top, bottom, left, right} box from line-local
	// coordinates into another coordinate system. Context may be one of
	// "line", "div" (display.lineDiv), "local"/null (editor), "window",
	// or "page".
	function intoCoordSystem(cm,lineObj,rect,context){if(lineObj.widgets)for(var i=0;i<lineObj.widgets.length;++i)if(lineObj.widgets[i].above){var size=widgetHeight(lineObj.widgets[i]);rect.top+=size;rect.bottom+=size}if(context=="line")return rect;if(!context)context="local";var yOff=heightAtLine(lineObj);if(context=="local")yOff+=paddingTop(cm.display);else yOff-=cm.display.viewOffset;if(context=="page"||context=="window"){var lOff=cm.display.lineSpace.getBoundingClientRect();yOff+=lOff.top+(context=="window"?0:pageScrollY());var xOff=lOff.left+(context=="window"?0:pageScrollX());rect.left+=xOff;rect.right+=xOff}rect.top+=yOff;rect.bottom+=yOff;return rect} // Coverts a box from "div" coords to another coordinate system.
	// Context may be "window", "page", "div", or "local"/null.
	function fromCoordSystem(cm,coords,context){if(context=="div")return coords;var left=coords.left,top=coords.top; // First move into "page" coordinate system
	if(context=="page"){left-=pageScrollX();top-=pageScrollY()}else if(context=="local"||!context){var localBox=cm.display.sizer.getBoundingClientRect();left+=localBox.left;top+=localBox.top}var lineSpaceBox=cm.display.lineSpace.getBoundingClientRect();return {left:left-lineSpaceBox.left,top:top-lineSpaceBox.top}}function charCoords(cm,pos,context,lineObj,bias){if(!lineObj)lineObj=getLine(cm.doc,pos.line);return intoCoordSystem(cm,lineObj,measureChar(cm,lineObj,pos.ch,bias),context)} // Returns a box for a given cursor position, which may have an
	// 'other' property containing the position of the secondary cursor
	// on a bidi boundary.
	function cursorCoords(cm,pos,context,lineObj,preparedMeasure,varHeight){lineObj=lineObj||getLine(cm.doc,pos.line);if(!preparedMeasure)preparedMeasure=prepareMeasureForLine(cm,lineObj);function get(ch,right){var m=measureCharPrepared(cm,preparedMeasure,ch,right?"right":"left",varHeight);if(right)m.left=m.right;else m.right=m.left;return intoCoordSystem(cm,lineObj,m,context)}function getBidi(ch,partPos){var part=order[partPos],right=part.level%2;if(ch==bidiLeft(part)&&partPos&&part.level<order[partPos-1].level){part=order[--partPos];ch=bidiRight(part)-(part.level%2?0:1);right=true}else if(ch==bidiRight(part)&&partPos<order.length-1&&part.level<order[partPos+1].level){part=order[++partPos];ch=bidiLeft(part)-part.level%2;right=false}if(right&&ch==part.to&&ch>part.from)return get(ch-1);return get(ch,right)}var order=getOrder(lineObj),ch=pos.ch;if(!order)return get(ch);var partPos=getBidiPartAt(order,ch);var val=getBidi(ch,partPos);if(bidiOther!=null)val.other=getBidi(ch,bidiOther);return val} // Used to cheaply estimate the coordinates for a position. Used for
	// intermediate scroll updates.
	function estimateCoords(cm,pos){var left=0,pos=clipPos(cm.doc,pos);if(!cm.options.lineWrapping)left=charWidth(cm.display)*pos.ch;var lineObj=getLine(cm.doc,pos.line);var top=heightAtLine(lineObj)+paddingTop(cm.display);return {left:left,right:left,top:top,bottom:top+lineObj.height}} // Positions returned by coordsChar contain some extra information.
	// xRel is the relative x position of the input coordinates compared
	// to the found position (so xRel > 0 means the coordinates are to
	// the right of the character position, for example). When outside
	// is true, that means the coordinates lie outside the line's
	// vertical range.
	function PosWithInfo(line,ch,outside,xRel){var pos=Pos(line,ch);pos.xRel=xRel;if(outside)pos.outside=true;return pos} // Compute the character position closest to the given coordinates.
	// Input must be lineSpace-local ("div" coordinate system).
	function coordsChar(cm,x,y){var doc=cm.doc;y+=cm.display.viewOffset;if(y<0)return PosWithInfo(doc.first,0,true,-1);var lineN=lineAtHeight(doc,y),last=doc.first+doc.size-1;if(lineN>last)return PosWithInfo(doc.first+doc.size-1,getLine(doc,last).text.length,true,1);if(x<0)x=0;var lineObj=getLine(doc,lineN);for(;;){var found=coordsCharInner(cm,lineObj,lineN,x,y);var merged=collapsedSpanAtEnd(lineObj);var mergedPos=merged&&merged.find(0,true);if(merged&&(found.ch>mergedPos.from.ch||found.ch==mergedPos.from.ch&&found.xRel>0))lineN=lineNo(lineObj=mergedPos.to.line);else return found}}function coordsCharInner(cm,lineObj,lineNo,x,y){var innerOff=y-heightAtLine(lineObj);var wrongLine=false,adjust=2*cm.display.wrapper.clientWidth;var preparedMeasure=prepareMeasureForLine(cm,lineObj);function getX(ch){var sp=cursorCoords(cm,Pos(lineNo,ch),"line",lineObj,preparedMeasure);wrongLine=true;if(innerOff>sp.bottom)return sp.left-adjust;else if(innerOff<sp.top)return sp.left+adjust;else wrongLine=false;return sp.left}var bidi=getOrder(lineObj),dist=lineObj.text.length;var from=lineLeft(lineObj),to=lineRight(lineObj);var fromX=getX(from),fromOutside=wrongLine,toX=getX(to),toOutside=wrongLine;if(x>toX)return PosWithInfo(lineNo,to,toOutside,1); // Do a binary search between these bounds.
	for(;;){if(bidi?to==from||to==moveVisually(lineObj,from,1):to-from<=1){var ch=x<fromX||x-fromX<=toX-x?from:to;var xDiff=x-(ch==from?fromX:toX);while(isExtendingChar(lineObj.text.charAt(ch)))++ch;var pos=PosWithInfo(lineNo,ch,ch==from?fromOutside:toOutside,xDiff<-1?-1:xDiff>1?1:0);return pos}var step=Math.ceil(dist/2),middle=from+step;if(bidi){middle=from;for(var i=0;i<step;++i)middle=moveVisually(lineObj,middle,1)}var middleX=getX(middle);if(middleX>x){to=middle;toX=middleX;if(toOutside=wrongLine)toX+=1000;dist=step}else {from=middle;fromX=middleX;fromOutside=wrongLine;dist-=step}}}var measureText; // Compute the default text height.
	function textHeight(display){if(display.cachedTextHeight!=null)return display.cachedTextHeight;if(measureText==null){measureText=elt("pre"); // Measure a bunch of lines, for browsers that compute
	// fractional heights.
	for(var i=0;i<49;++i){measureText.appendChild(document.createTextNode("x"));measureText.appendChild(elt("br"))}measureText.appendChild(document.createTextNode("x"))}removeChildrenAndAdd(display.measure,measureText);var height=measureText.offsetHeight/50;if(height>3)display.cachedTextHeight=height;removeChildren(display.measure);return height||1} // Compute the default character width.
	function charWidth(display){if(display.cachedCharWidth!=null)return display.cachedCharWidth;var anchor=elt("span","xxxxxxxxxx");var pre=elt("pre",[anchor]);removeChildrenAndAdd(display.measure,pre);var rect=anchor.getBoundingClientRect(),width=(rect.right-rect.left)/10;if(width>2)display.cachedCharWidth=width;return width||10} // OPERATIONS
	// Operations are used to wrap a series of changes to the editor
	// state in such a way that each change won't have to update the
	// cursor and display (which would be awkward, slow, and
	// error-prone). Instead, display updates are batched and then all
	// combined and executed at once.
	var operationGroup=null;var nextOpId=0; // Start a new operation.
	function startOperation(cm){cm.curOp={cm:cm,viewChanged:false, // Flag that indicates that lines might need to be redrawn
	startHeight:cm.doc.height, // Used to detect need to update scrollbar
	forceUpdate:false, // Used to force a redraw
	updateInput:null, // Whether to reset the input textarea
	typing:false, // Whether this reset should be careful to leave existing text (for compositing)
	changeObjs:null, // Accumulated changes, for firing change events
	cursorActivityHandlers:null, // Set of handlers to fire cursorActivity on
	cursorActivityCalled:0, // Tracks which cursorActivity handlers have been called already
	selectionChanged:false, // Whether the selection needs to be redrawn
	updateMaxLine:false, // Set when the widest line needs to be determined anew
	scrollLeft:null,scrollTop:null, // Intermediate scroll position, not pushed to DOM yet
	scrollToPos:null, // Used to scroll to a specific position
	focus:false,id:++nextOpId // Unique ID
	};if(operationGroup){operationGroup.ops.push(cm.curOp)}else {cm.curOp.ownsGroup=operationGroup={ops:[cm.curOp],delayedCallbacks:[]}}}function fireCallbacksForOps(group){ // Calls delayed callbacks and cursorActivity handlers until no
	// new ones appear
	var callbacks=group.delayedCallbacks,i=0;do {for(;i<callbacks.length;i++)callbacks[i].call(null);for(var j=0;j<group.ops.length;j++){var op=group.ops[j];if(op.cursorActivityHandlers)while(op.cursorActivityCalled<op.cursorActivityHandlers.length)op.cursorActivityHandlers[op.cursorActivityCalled++].call(null,op.cm)}}while(i<callbacks.length)} // Finish an operation, updating the display and signalling delayed events
	function endOperation(cm){var op=cm.curOp,group=op.ownsGroup;if(!group)return;try{fireCallbacksForOps(group)}finally {operationGroup=null;for(var i=0;i<group.ops.length;i++)group.ops[i].cm.curOp=null;endOperations(group)}} // The DOM updates done when an operation finishes are batched so
	// that the minimum number of relayouts are required.
	function endOperations(group){var ops=group.ops;for(var i=0;i<ops.length;i++) // Read DOM
	endOperation_R1(ops[i]);for(var i=0;i<ops.length;i++) // Write DOM (maybe)
	endOperation_W1(ops[i]);for(var i=0;i<ops.length;i++) // Read DOM
	endOperation_R2(ops[i]);for(var i=0;i<ops.length;i++) // Write DOM (maybe)
	endOperation_W2(ops[i]);for(var i=0;i<ops.length;i++) // Read DOM
	endOperation_finish(ops[i])}function endOperation_R1(op){var cm=op.cm,display=cm.display;maybeClipScrollbars(cm);if(op.updateMaxLine)findMaxLine(cm);op.mustUpdate=op.viewChanged||op.forceUpdate||op.scrollTop!=null||op.scrollToPos&&(op.scrollToPos.from.line<display.viewFrom||op.scrollToPos.to.line>=display.viewTo)||display.maxLineChanged&&cm.options.lineWrapping;op.update=op.mustUpdate&&new DisplayUpdate(cm,op.mustUpdate&&{top:op.scrollTop,ensure:op.scrollToPos},op.forceUpdate)}function endOperation_W1(op){op.updatedDisplay=op.mustUpdate&&updateDisplayIfNeeded(op.cm,op.update)}function endOperation_R2(op){var cm=op.cm,display=cm.display;if(op.updatedDisplay)updateHeightsInViewport(cm);op.barMeasure=measureForScrollbars(cm); // If the max line changed since it was last measured, measure it,
	// and ensure the document's width matches it.
	// updateDisplay_W2 will use these properties to do the actual resizing
	if(display.maxLineChanged&&!cm.options.lineWrapping){op.adjustWidthTo=measureChar(cm,display.maxLine,display.maxLine.text.length).left+3;cm.display.sizerWidth=op.adjustWidthTo;op.barMeasure.scrollWidth=Math.max(display.scroller.clientWidth,display.sizer.offsetLeft+op.adjustWidthTo+scrollGap(cm)+cm.display.barWidth);op.maxScrollLeft=Math.max(0,display.sizer.offsetLeft+op.adjustWidthTo-displayWidth(cm))}if(op.updatedDisplay||op.selectionChanged)op.preparedSelection=display.input.prepareSelection()}function endOperation_W2(op){var cm=op.cm;if(op.adjustWidthTo!=null){cm.display.sizer.style.minWidth=op.adjustWidthTo+"px";if(op.maxScrollLeft<cm.doc.scrollLeft)setScrollLeft(cm,Math.min(cm.display.scroller.scrollLeft,op.maxScrollLeft),true);cm.display.maxLineChanged=false}if(op.preparedSelection)cm.display.input.showSelection(op.preparedSelection);if(op.updatedDisplay)setDocumentHeight(cm,op.barMeasure);if(op.updatedDisplay||op.startHeight!=cm.doc.height)updateScrollbars(cm,op.barMeasure);if(op.selectionChanged)restartBlink(cm);if(cm.state.focused&&op.updateInput)cm.display.input.reset(op.typing);if(op.focus&&op.focus==activeElt()&&(!document.hasFocus||document.hasFocus()))ensureFocus(op.cm)}function endOperation_finish(op){var cm=op.cm,display=cm.display,doc=cm.doc;if(op.updatedDisplay)postUpdateDisplay(cm,op.update); // Abort mouse wheel delta measurement, when scrolling explicitly
	if(display.wheelStartX!=null&&(op.scrollTop!=null||op.scrollLeft!=null||op.scrollToPos))display.wheelStartX=display.wheelStartY=null; // Propagate the scroll position to the actual DOM scroller
	if(op.scrollTop!=null&&(display.scroller.scrollTop!=op.scrollTop||op.forceScroll)){doc.scrollTop=Math.max(0,Math.min(display.scroller.scrollHeight-display.scroller.clientHeight,op.scrollTop));display.scrollbars.setScrollTop(doc.scrollTop);display.scroller.scrollTop=doc.scrollTop}if(op.scrollLeft!=null&&(display.scroller.scrollLeft!=op.scrollLeft||op.forceScroll)){doc.scrollLeft=Math.max(0,Math.min(display.scroller.scrollWidth-displayWidth(cm),op.scrollLeft));display.scrollbars.setScrollLeft(doc.scrollLeft);display.scroller.scrollLeft=doc.scrollLeft;alignHorizontally(cm)} // If we need to scroll a specific position into view, do so.
	if(op.scrollToPos){var coords=scrollPosIntoView(cm,clipPos(doc,op.scrollToPos.from),clipPos(doc,op.scrollToPos.to),op.scrollToPos.margin);if(op.scrollToPos.isCursor&&cm.state.focused)maybeScrollWindow(cm,coords)} // Fire events for markers that are hidden/unidden by editing or
	// undoing
	var hidden=op.maybeHiddenMarkers,unhidden=op.maybeUnhiddenMarkers;if(hidden)for(var i=0;i<hidden.length;++i)if(!hidden[i].lines.length)signal(hidden[i],"hide");if(unhidden)for(var i=0;i<unhidden.length;++i)if(unhidden[i].lines.length)signal(unhidden[i],"unhide");if(display.wrapper.offsetHeight)doc.scrollTop=cm.display.scroller.scrollTop; // Fire change events, and delayed event handlers
	if(op.changeObjs)signal(cm,"changes",cm,op.changeObjs);if(op.update)op.update.finish()} // Run the given function in an operation
	function runInOp(cm,f){if(cm.curOp)return f();startOperation(cm);try{return f()}finally {endOperation(cm)}} // Wraps a function in an operation. Returns the wrapped function.
	function operation(cm,f){return function(){if(cm.curOp)return f.apply(cm,arguments);startOperation(cm);try{return f.apply(cm,arguments)}finally {endOperation(cm)}}} // Used to add methods to editor and doc instances, wrapping them in
	// operations.
	function methodOp(f){return function(){if(this.curOp)return f.apply(this,arguments);startOperation(this);try{return f.apply(this,arguments)}finally {endOperation(this)}}}function docMethodOp(f){return function(){var cm=this.cm;if(!cm||cm.curOp)return f.apply(this,arguments);startOperation(cm);try{return f.apply(this,arguments)}finally {endOperation(cm)}}} // VIEW TRACKING
	// These objects are used to represent the visible (currently drawn)
	// part of the document. A LineView may correspond to multiple
	// logical lines, if those are connected by collapsed ranges.
	function LineView(doc,line,lineN){ // The starting line
	this.line=line; // Continuing lines, if any
	this.rest=visualLineContinued(line); // Number of logical lines in this visual line
	this.size=this.rest?lineNo(lst(this.rest))-lineN+1:1;this.node=this.text=null;this.hidden=lineIsHidden(doc,line)} // Create a range of LineView objects for the given lines.
	function buildViewArray(cm,from,to){var array=[],nextPos;for(var pos=from;pos<to;pos=nextPos){var view=new LineView(cm.doc,getLine(cm.doc,pos),pos);nextPos=pos+view.size;array.push(view)}return array} // Updates the display.view data structure for a given change to the
	// document. From and to are in pre-change coordinates. Lendiff is
	// the amount of lines added or subtracted by the change. This is
	// used for changes that span multiple lines, or change the way
	// lines are divided into visual lines. regLineChange (below)
	// registers single-line changes.
	function regChange(cm,from,to,lendiff){if(from==null)from=cm.doc.first;if(to==null)to=cm.doc.first+cm.doc.size;if(!lendiff)lendiff=0;var display=cm.display;if(lendiff&&to<display.viewTo&&(display.updateLineNumbers==null||display.updateLineNumbers>from))display.updateLineNumbers=from;cm.curOp.viewChanged=true;if(from>=display.viewTo){ // Change after
	if(sawCollapsedSpans&&visualLineNo(cm.doc,from)<display.viewTo)resetView(cm)}else if(to<=display.viewFrom){ // Change before
	if(sawCollapsedSpans&&visualLineEndNo(cm.doc,to+lendiff)>display.viewFrom){resetView(cm)}else {display.viewFrom+=lendiff;display.viewTo+=lendiff}}else if(from<=display.viewFrom&&to>=display.viewTo){ // Full overlap
	resetView(cm)}else if(from<=display.viewFrom){ // Top overlap
	var cut=viewCuttingPoint(cm,to,to+lendiff,1);if(cut){display.view=display.view.slice(cut.index);display.viewFrom=cut.lineN;display.viewTo+=lendiff}else {resetView(cm)}}else if(to>=display.viewTo){ // Bottom overlap
	var cut=viewCuttingPoint(cm,from,from,-1);if(cut){display.view=display.view.slice(0,cut.index);display.viewTo=cut.lineN}else {resetView(cm)}}else { // Gap in the middle
	var cutTop=viewCuttingPoint(cm,from,from,-1);var cutBot=viewCuttingPoint(cm,to,to+lendiff,1);if(cutTop&&cutBot){display.view=display.view.slice(0,cutTop.index).concat(buildViewArray(cm,cutTop.lineN,cutBot.lineN)).concat(display.view.slice(cutBot.index));display.viewTo+=lendiff}else {resetView(cm)}}var ext=display.externalMeasured;if(ext){if(to<ext.lineN)ext.lineN+=lendiff;else if(from<ext.lineN+ext.size)display.externalMeasured=null}} // Register a change to a single line. Type must be one of "text",
	// "gutter", "class", "widget"
	function regLineChange(cm,line,type){cm.curOp.viewChanged=true;var display=cm.display,ext=cm.display.externalMeasured;if(ext&&line>=ext.lineN&&line<ext.lineN+ext.size)display.externalMeasured=null;if(line<display.viewFrom||line>=display.viewTo)return;var lineView=display.view[findViewIndex(cm,line)];if(lineView.node==null)return;var arr=lineView.changes||(lineView.changes=[]);if(indexOf(arr,type)==-1)arr.push(type)} // Clear the view.
	function resetView(cm){cm.display.viewFrom=cm.display.viewTo=cm.doc.first;cm.display.view=[];cm.display.viewOffset=0} // Find the view element corresponding to a given line. Return null
	// when the line isn't visible.
	function findViewIndex(cm,n){if(n>=cm.display.viewTo)return null;n-=cm.display.viewFrom;if(n<0)return null;var view=cm.display.view;for(var i=0;i<view.length;i++){n-=view[i].size;if(n<0)return i}}function viewCuttingPoint(cm,oldN,newN,dir){var index=findViewIndex(cm,oldN),diff,view=cm.display.view;if(!sawCollapsedSpans||newN==cm.doc.first+cm.doc.size)return {index:index,lineN:newN};for(var i=0,n=cm.display.viewFrom;i<index;i++)n+=view[i].size;if(n!=oldN){if(dir>0){if(index==view.length-1)return null;diff=n+view[index].size-oldN;index++}else {diff=n-oldN}oldN+=diff;newN+=diff}while(visualLineNo(cm.doc,newN)!=newN){if(index==(dir<0?0:view.length-1))return null;newN+=dir*view[index-(dir<0?1:0)].size;index+=dir}return {index:index,lineN:newN}} // Force the view to cover a given range, adding empty view element
	// or clipping off existing ones as needed.
	function adjustView(cm,from,to){var display=cm.display,view=display.view;if(view.length==0||from>=display.viewTo||to<=display.viewFrom){display.view=buildViewArray(cm,from,to);display.viewFrom=from}else {if(display.viewFrom>from)display.view=buildViewArray(cm,from,display.viewFrom).concat(display.view);else if(display.viewFrom<from)display.view=display.view.slice(findViewIndex(cm,from));display.viewFrom=from;if(display.viewTo<to)display.view=display.view.concat(buildViewArray(cm,display.viewTo,to));else if(display.viewTo>to)display.view=display.view.slice(0,findViewIndex(cm,to))}display.viewTo=to} // Count the number of lines in the view whose DOM representation is
	// out of date (or nonexistent).
	function countDirtyView(cm){var view=cm.display.view,dirty=0;for(var i=0;i<view.length;i++){var lineView=view[i];if(!lineView.hidden&&(!lineView.node||lineView.changes))++dirty}return dirty} // EVENT HANDLERS
	// Attach the necessary event handlers when initializing the editor
	function registerEventHandlers(cm){var d=cm.display;on(d.scroller,"mousedown",operation(cm,onMouseDown)); // Older IE's will not fire a second mousedown for a double click
	if(ie&&ie_version<11)on(d.scroller,"dblclick",operation(cm,function(e){if(signalDOMEvent(cm,e))return;var pos=posFromMouse(cm,e);if(!pos||clickInGutter(cm,e)||eventInWidget(cm.display,e))return;e_preventDefault(e);var word=cm.findWordAt(pos);extendSelection(cm.doc,word.anchor,word.head)}));else on(d.scroller,"dblclick",function(e){signalDOMEvent(cm,e)||e_preventDefault(e)}); // Some browsers fire contextmenu *after* opening the menu, at
	// which point we can't mess with it anymore. Context menu is
	// handled in onMouseDown for these browsers.
	if(!captureRightClick)on(d.scroller,"contextmenu",function(e){onContextMenu(cm,e)}); // Used to suppress mouse event handling when a touch happens
	var touchFinished,prevTouch={end:0};function finishTouch(){if(d.activeTouch){touchFinished=setTimeout(function(){d.activeTouch=null},1000);prevTouch=d.activeTouch;prevTouch.end=+new Date}};function isMouseLikeTouchEvent(e){if(e.touches.length!=1)return false;var touch=e.touches[0];return touch.radiusX<=1&&touch.radiusY<=1}function farAway(touch,other){if(other.left==null)return true;var dx=other.left-touch.left,dy=other.top-touch.top;return dx*dx+dy*dy>20*20}on(d.scroller,"touchstart",function(e){if(!isMouseLikeTouchEvent(e)){clearTimeout(touchFinished);var now=+new Date;d.activeTouch={start:now,moved:false,prev:now-prevTouch.end<=300?prevTouch:null};if(e.touches.length==1){d.activeTouch.left=e.touches[0].pageX;d.activeTouch.top=e.touches[0].pageY}}});on(d.scroller,"touchmove",function(){if(d.activeTouch)d.activeTouch.moved=true});on(d.scroller,"touchend",function(e){var touch=d.activeTouch;if(touch&&!eventInWidget(d,e)&&touch.left!=null&&!touch.moved&&new Date-touch.start<300){var pos=cm.coordsChar(d.activeTouch,"page"),range;if(!touch.prev||farAway(touch,touch.prev)) // Single tap
	range=new Range(pos,pos);else if(!touch.prev.prev||farAway(touch,touch.prev.prev)) // Double tap
	range=cm.findWordAt(pos);else  // Triple tap
	range=new Range(Pos(pos.line,0),clipPos(cm.doc,Pos(pos.line+1,0)));cm.setSelection(range.anchor,range.head);cm.focus();e_preventDefault(e)}finishTouch()});on(d.scroller,"touchcancel",finishTouch); // Sync scrolling between fake scrollbars and real scrollable
	// area, ensure viewport is updated when scrolling.
	on(d.scroller,"scroll",function(){if(d.scroller.clientHeight){setScrollTop(cm,d.scroller.scrollTop);setScrollLeft(cm,d.scroller.scrollLeft,true);signal(cm,"scroll",cm)}}); // Listen to wheel events in order to try and update the viewport on time.
	on(d.scroller,"mousewheel",function(e){onScrollWheel(cm,e)});on(d.scroller,"DOMMouseScroll",function(e){onScrollWheel(cm,e)}); // Prevent wrapper from ever scrolling
	on(d.wrapper,"scroll",function(){d.wrapper.scrollTop=d.wrapper.scrollLeft=0});d.dragFunctions={enter:function(e){if(!signalDOMEvent(cm,e))e_stop(e)},over:function(e){if(!signalDOMEvent(cm,e)){onDragOver(cm,e);e_stop(e)}},start:function(e){onDragStart(cm,e)},drop:operation(cm,onDrop),leave:function(){clearDragCursor(cm)}};var inp=d.input.getField();on(inp,"keyup",function(e){onKeyUp.call(cm,e)});on(inp,"keydown",operation(cm,onKeyDown));on(inp,"keypress",operation(cm,onKeyPress));on(inp,"focus",bind(onFocus,cm));on(inp,"blur",bind(onBlur,cm))}function dragDropChanged(cm,value,old){var wasOn=old&&old!=CodeMirror.Init;if(!value!=!wasOn){var funcs=cm.display.dragFunctions;var toggle=value?on:off;toggle(cm.display.scroller,"dragstart",funcs.start);toggle(cm.display.scroller,"dragenter",funcs.enter);toggle(cm.display.scroller,"dragover",funcs.over);toggle(cm.display.scroller,"dragleave",funcs.leave);toggle(cm.display.scroller,"drop",funcs.drop)}} // Called when the window resizes
	function onResize(cm){var d=cm.display;if(d.lastWrapHeight==d.wrapper.clientHeight&&d.lastWrapWidth==d.wrapper.clientWidth)return; // Might be a text scaling operation, clear size caches.
	d.cachedCharWidth=d.cachedTextHeight=d.cachedPaddingH=null;d.scrollbarsClipped=false;cm.setSize()} // MOUSE EVENTS
	// Return true when the given mouse event happened in a widget
	function eventInWidget(display,e){for(var n=e_target(e);n!=display.wrapper;n=n.parentNode){if(!n||n.nodeType==1&&n.getAttribute("cm-ignore-events")=="true"||n.parentNode==display.sizer&&n!=display.mover)return true}} // Given a mouse event, find the corresponding position. If liberal
	// is false, it checks whether a gutter or scrollbar was clicked,
	// and returns null if it was. forRect is used by rectangular
	// selections, and tries to estimate a character position even for
	// coordinates beyond the right of the text.
	function posFromMouse(cm,e,liberal,forRect){var display=cm.display;if(!liberal&&e_target(e).getAttribute("cm-not-content")=="true")return null;var x,y,space=display.lineSpace.getBoundingClientRect(); // Fails unpredictably on IE[67] when mouse is dragged around quickly.
	try{x=e.clientX-space.left;y=e.clientY-space.top}catch(e) {return null}var coords=coordsChar(cm,x,y),line;if(forRect&&coords.xRel==1&&(line=getLine(cm.doc,coords.line).text).length==coords.ch){var colDiff=countColumn(line,line.length,cm.options.tabSize)-line.length;coords=Pos(coords.line,Math.max(0,Math.round((x-paddingH(cm.display).left)/charWidth(cm.display))-colDiff))}return coords} // A mouse down can be a single click, double click, triple click,
	// start of selection drag, start of text drag, new cursor
	// (ctrl-click), rectangle drag (alt-drag), or xwin
	// middle-click-paste. Or it might be a click on something we should
	// not interfere with, such as a scrollbar or widget.
	function onMouseDown(e){var cm=this,display=cm.display;if(display.activeTouch&&display.input.supportsTouch()||signalDOMEvent(cm,e))return;display.shift=e.shiftKey;if(eventInWidget(display,e)){if(!webkit){ // Briefly turn off draggability, to allow widgets to do
	// normal dragging things.
	display.scroller.draggable=false;setTimeout(function(){display.scroller.draggable=true},100)}return}if(clickInGutter(cm,e))return;var start=posFromMouse(cm,e);window.focus();switch(e_button(e)){case 1: // #3261: make sure, that we're not starting a second selection
	if(cm.state.selectingText)cm.state.selectingText(e);else if(start)leftButtonDown(cm,e,start);else if(e_target(e)==display.scroller)e_preventDefault(e);break;case 2:if(webkit)cm.state.lastMiddleDown=+new Date;if(start)extendSelection(cm.doc,start);setTimeout(function(){display.input.focus()},20);e_preventDefault(e);break;case 3:if(captureRightClick)onContextMenu(cm,e);else delayBlurEvent(cm);break;}}var lastClick,lastDoubleClick;function leftButtonDown(cm,e,start){if(ie)setTimeout(bind(ensureFocus,cm),0);else cm.curOp.focus=activeElt();var now=+new Date,type;if(lastDoubleClick&&lastDoubleClick.time>now-400&&cmp(lastDoubleClick.pos,start)==0){type="triple"}else if(lastClick&&lastClick.time>now-400&&cmp(lastClick.pos,start)==0){type="double";lastDoubleClick={time:now,pos:start}}else {type="single";lastClick={time:now,pos:start}}var sel=cm.doc.sel,modifier=mac?e.metaKey:e.ctrlKey,contained;if(cm.options.dragDrop&&dragAndDrop&&!isReadOnly(cm)&&type=="single"&&(contained=sel.contains(start))>-1&&(cmp((contained=sel.ranges[contained]).from(),start)<0||start.xRel>0)&&(cmp(contained.to(),start)>0||start.xRel<0))leftButtonStartDrag(cm,e,start,modifier);else leftButtonSelect(cm,e,start,type,modifier)} // Start a text drag. When it ends, see if any dragging actually
	// happen, and treat as a click if it didn't.
	function leftButtonStartDrag(cm,e,start,modifier){var display=cm.display,startTime=+new Date;var dragEnd=operation(cm,function(e2){if(webkit)display.scroller.draggable=false;cm.state.draggingText=false;off(document,"mouseup",dragEnd);off(display.scroller,"drop",dragEnd);if(Math.abs(e.clientX-e2.clientX)+Math.abs(e.clientY-e2.clientY)<10){e_preventDefault(e2);if(!modifier&&+new Date-200<startTime)extendSelection(cm.doc,start); // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)
	if(webkit||ie&&ie_version==9)setTimeout(function(){document.body.focus();display.input.focus()},20);else display.input.focus()}}); // Let the drag handler handle this.
	if(webkit)display.scroller.draggable=true;cm.state.draggingText=dragEnd; // IE's approach to draggable
	if(display.scroller.dragDrop)display.scroller.dragDrop();on(document,"mouseup",dragEnd);on(display.scroller,"drop",dragEnd)} // Normal selection, as opposed to text dragging.
	function leftButtonSelect(cm,e,start,type,addNew){var display=cm.display,doc=cm.doc;e_preventDefault(e);var ourRange,ourIndex,startSel=doc.sel,ranges=startSel.ranges;if(addNew&&!e.shiftKey){ourIndex=doc.sel.contains(start);if(ourIndex>-1)ourRange=ranges[ourIndex];else ourRange=new Range(start,start)}else {ourRange=doc.sel.primary();ourIndex=doc.sel.primIndex}if(e.altKey){type="rect";if(!addNew)ourRange=new Range(start,start);start=posFromMouse(cm,e,true,true);ourIndex=-1}else if(type=="double"){var word=cm.findWordAt(start);if(cm.display.shift||doc.extend)ourRange=extendRange(doc,ourRange,word.anchor,word.head);else ourRange=word}else if(type=="triple"){var line=new Range(Pos(start.line,0),clipPos(doc,Pos(start.line+1,0)));if(cm.display.shift||doc.extend)ourRange=extendRange(doc,ourRange,line.anchor,line.head);else ourRange=line}else {ourRange=extendRange(doc,ourRange,start)}if(!addNew){ourIndex=0;setSelection(doc,new Selection([ourRange],0),sel_mouse);startSel=doc.sel}else if(ourIndex==-1){ourIndex=ranges.length;setSelection(doc,normalizeSelection(ranges.concat([ourRange]),ourIndex),{scroll:false,origin:"*mouse"})}else if(ranges.length>1&&ranges[ourIndex].empty()&&type=="single"&&!e.shiftKey){setSelection(doc,normalizeSelection(ranges.slice(0,ourIndex).concat(ranges.slice(ourIndex+1)),0),{scroll:false,origin:"*mouse"});startSel=doc.sel}else {replaceOneSelection(doc,ourIndex,ourRange,sel_mouse)}var lastPos=start;function extendTo(pos){if(cmp(lastPos,pos)==0)return;lastPos=pos;if(type=="rect"){var ranges=[],tabSize=cm.options.tabSize;var startCol=countColumn(getLine(doc,start.line).text,start.ch,tabSize);var posCol=countColumn(getLine(doc,pos.line).text,pos.ch,tabSize);var left=Math.min(startCol,posCol),right=Math.max(startCol,posCol);for(var line=Math.min(start.line,pos.line),end=Math.min(cm.lastLine(),Math.max(start.line,pos.line));line<=end;line++){var text=getLine(doc,line).text,leftPos=findColumn(text,left,tabSize);if(left==right)ranges.push(new Range(Pos(line,leftPos),Pos(line,leftPos)));else if(text.length>leftPos)ranges.push(new Range(Pos(line,leftPos),Pos(line,findColumn(text,right,tabSize))))}if(!ranges.length)ranges.push(new Range(start,start));setSelection(doc,normalizeSelection(startSel.ranges.slice(0,ourIndex).concat(ranges),ourIndex),{origin:"*mouse",scroll:false});cm.scrollIntoView(pos)}else {var oldRange=ourRange;var anchor=oldRange.anchor,head=pos;if(type!="single"){if(type=="double")var range=cm.findWordAt(pos);else var range=new Range(Pos(pos.line,0),clipPos(doc,Pos(pos.line+1,0)));if(cmp(range.anchor,anchor)>0){head=range.head;anchor=minPos(oldRange.from(),range.anchor)}else {head=range.anchor;anchor=maxPos(oldRange.to(),range.head)}}var ranges=startSel.ranges.slice(0);ranges[ourIndex]=new Range(clipPos(doc,anchor),head);setSelection(doc,normalizeSelection(ranges,ourIndex),sel_mouse)}}var editorSize=display.wrapper.getBoundingClientRect(); // Used to ensure timeout re-tries don't fire when another extend
	// happened in the meantime (clearTimeout isn't reliable -- at
	// least on Chrome, the timeouts still happen even when cleared,
	// if the clear happens after their scheduled firing time).
	var counter=0;function extend(e){var curCount=++counter;var cur=posFromMouse(cm,e,true,type=="rect");if(!cur)return;if(cmp(cur,lastPos)!=0){cm.curOp.focus=activeElt();extendTo(cur);var visible=visibleLines(display,doc);if(cur.line>=visible.to||cur.line<visible.from)setTimeout(operation(cm,function(){if(counter==curCount)extend(e)}),150)}else {var outside=e.clientY<editorSize.top?-20:e.clientY>editorSize.bottom?20:0;if(outside)setTimeout(operation(cm,function(){if(counter!=curCount)return;display.scroller.scrollTop+=outside;extend(e)}),50)}}function done(e){cm.state.selectingText=false;counter=Infinity;e_preventDefault(e);display.input.focus();off(document,"mousemove",move);off(document,"mouseup",up);doc.history.lastSelOrigin=null}var move=operation(cm,function(e){if(!e_button(e))done(e);else extend(e)});var up=operation(cm,done);cm.state.selectingText=up;on(document,"mousemove",move);on(document,"mouseup",up)} // Determines whether an event happened in the gutter, and fires the
	// handlers for the corresponding event.
	function gutterEvent(cm,e,type,prevent){try{var mX=e.clientX,mY=e.clientY}catch(e) {return false}if(mX>=Math.floor(cm.display.gutters.getBoundingClientRect().right))return false;if(prevent)e_preventDefault(e);var display=cm.display;var lineBox=display.lineDiv.getBoundingClientRect();if(mY>lineBox.bottom||!hasHandler(cm,type))return e_defaultPrevented(e);mY-=lineBox.top-display.viewOffset;for(var i=0;i<cm.options.gutters.length;++i){var g=display.gutters.childNodes[i];if(g&&g.getBoundingClientRect().right>=mX){var line=lineAtHeight(cm.doc,mY);var gutter=cm.options.gutters[i];signal(cm,type,cm,line,gutter,e);return e_defaultPrevented(e)}}}function clickInGutter(cm,e){return gutterEvent(cm,e,"gutterClick",true)} // Kludge to work around strange IE behavior where it'll sometimes
	// re-fire a series of drag-related events right after the drop (#1551)
	var lastDrop=0;function onDrop(e){var cm=this;clearDragCursor(cm);if(signalDOMEvent(cm,e)||eventInWidget(cm.display,e))return;e_preventDefault(e);if(ie)lastDrop=+new Date;var pos=posFromMouse(cm,e,true),files=e.dataTransfer.files;if(!pos||isReadOnly(cm))return; // Might be a file drop, in which case we simply extract the text
	// and insert it.
	if(files&&files.length&&window.FileReader&&window.File){var n=files.length,text=Array(n),read=0;var loadFile=function(file,i){if(cm.options.allowDropFileTypes&&indexOf(cm.options.allowDropFileTypes,file.type)==-1)return;var reader=new FileReader;reader.onload=operation(cm,function(){var content=reader.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(content))content="";text[i]=content;if(++read==n){pos=clipPos(cm.doc,pos);var change={from:pos,to:pos,text:cm.doc.splitLines(text.join(cm.doc.lineSeparator())),origin:"paste"};makeChange(cm.doc,change);setSelectionReplaceHistory(cm.doc,simpleSelection(pos,changeEnd(change)))}});reader.readAsText(file)};for(var i=0;i<n;++i)loadFile(files[i],i)}else { // Normal drop
	// Don't do a replace if the drop happened inside of the selected text.
	if(cm.state.draggingText&&cm.doc.sel.contains(pos)>-1){cm.state.draggingText(e); // Ensure the editor is re-focused
	setTimeout(function(){cm.display.input.focus()},20);return}try{var text=e.dataTransfer.getData("Text");if(text){if(cm.state.draggingText&&!(mac?e.altKey:e.ctrlKey))var selected=cm.listSelections();setSelectionNoUndo(cm.doc,simpleSelection(pos,pos));if(selected)for(var i=0;i<selected.length;++i)replaceRange(cm.doc,"",selected[i].anchor,selected[i].head,"drag");cm.replaceSelection(text,"around","paste");cm.display.input.focus()}}catch(e) {}}}function onDragStart(cm,e){if(ie&&(!cm.state.draggingText||+new Date-lastDrop<100)){e_stop(e);return}if(signalDOMEvent(cm,e)||eventInWidget(cm.display,e))return;e.dataTransfer.setData("Text",cm.getSelection()); // Use dummy image instead of default browsers image.
	// Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.
	if(e.dataTransfer.setDragImage&&!safari){var img=elt("img",null,null,"position: fixed; left: 0; top: 0;");img.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";if(presto){img.width=img.height=1;cm.display.wrapper.appendChild(img); // Force a relayout, or Opera won't use our image for some obscure reason
	img._top=img.offsetTop}e.dataTransfer.setDragImage(img,0,0);if(presto)img.parentNode.removeChild(img)}}function onDragOver(cm,e){var pos=posFromMouse(cm,e);if(!pos)return;var frag=document.createDocumentFragment();drawSelectionCursor(cm,pos,frag);if(!cm.display.dragCursor){cm.display.dragCursor=elt("div",null,"CodeMirror-cursors CodeMirror-dragcursors");cm.display.lineSpace.insertBefore(cm.display.dragCursor,cm.display.cursorDiv)}removeChildrenAndAdd(cm.display.dragCursor,frag)}function clearDragCursor(cm){if(cm.display.dragCursor){cm.display.lineSpace.removeChild(cm.display.dragCursor);cm.display.dragCursor=null}} // SCROLL EVENTS
	// Sync the scrollable area and scrollbars, ensure the viewport
	// covers the visible area.
	function setScrollTop(cm,val){if(Math.abs(cm.doc.scrollTop-val)<2)return;cm.doc.scrollTop=val;if(!gecko)updateDisplaySimple(cm,{top:val});if(cm.display.scroller.scrollTop!=val)cm.display.scroller.scrollTop=val;cm.display.scrollbars.setScrollTop(val);if(gecko)updateDisplaySimple(cm);startWorker(cm,100)} // Sync scroller and scrollbar, ensure the gutter elements are
	// aligned.
	function setScrollLeft(cm,val,isScroller){if(isScroller?val==cm.doc.scrollLeft:Math.abs(cm.doc.scrollLeft-val)<2)return;val=Math.min(val,cm.display.scroller.scrollWidth-cm.display.scroller.clientWidth);cm.doc.scrollLeft=val;alignHorizontally(cm);if(cm.display.scroller.scrollLeft!=val)cm.display.scroller.scrollLeft=val;cm.display.scrollbars.setScrollLeft(val)} // Since the delta values reported on mouse wheel events are
	// unstandardized between browsers and even browser versions, and
	// generally horribly unpredictable, this code starts by measuring
	// the scroll effect that the first few mouse wheel events have,
	// and, from that, detects the way it can convert deltas to pixel
	// offsets afterwards.
	//
	// The reason we want to know the amount a wheel event will scroll
	// is that it gives us a chance to update the display before the
	// actual scrolling happens, reducing flickering.
	var wheelSamples=0,wheelPixelsPerUnit=null; // Fill in a browser-detected starting value on browsers where we
	// know one. These don't have to be accurate -- the result of them
	// being wrong would just be a slight flicker on the first wheel
	// scroll (if it is large enough).
	if(ie)wheelPixelsPerUnit=-.53;else if(gecko)wheelPixelsPerUnit=15;else if(chrome)wheelPixelsPerUnit=-.7;else if(safari)wheelPixelsPerUnit=-1/3;var wheelEventDelta=function(e){var dx=e.wheelDeltaX,dy=e.wheelDeltaY;if(dx==null&&e.detail&&e.axis==e.HORIZONTAL_AXIS)dx=e.detail;if(dy==null&&e.detail&&e.axis==e.VERTICAL_AXIS)dy=e.detail;else if(dy==null)dy=e.wheelDelta;return {x:dx,y:dy}};CodeMirror.wheelEventPixels=function(e){var delta=wheelEventDelta(e);delta.x*=wheelPixelsPerUnit;delta.y*=wheelPixelsPerUnit;return delta};function onScrollWheel(cm,e){var delta=wheelEventDelta(e),dx=delta.x,dy=delta.y;var display=cm.display,scroll=display.scroller; // Quit if there's nothing to scroll here
	var canScrollX=scroll.scrollWidth>scroll.clientWidth;var canScrollY=scroll.scrollHeight>scroll.clientHeight;if(!(dx&&canScrollX||dy&&canScrollY))return; // Webkit browsers on OS X abort momentum scrolls when the target
	// of the scroll event is removed from the scrollable element.
	// This hack (see related code in patchDisplay) makes sure the
	// element is kept around.
	if(dy&&mac&&webkit){outer: for(var cur=e.target,view=display.view;cur!=scroll;cur=cur.parentNode){for(var i=0;i<view.length;i++){if(view[i].node==cur){cm.display.currentWheelTarget=cur;break outer}}}} // On some browsers, horizontal scrolling will cause redraws to
	// happen before the gutter has been realigned, causing it to
	// wriggle around in a most unseemly way. When we have an
	// estimated pixels/delta value, we just handle horizontal
	// scrolling entirely here. It'll be slightly off from native, but
	// better than glitching out.
	if(dx&&!gecko&&!presto&&wheelPixelsPerUnit!=null){if(dy&&canScrollY)setScrollTop(cm,Math.max(0,Math.min(scroll.scrollTop+dy*wheelPixelsPerUnit,scroll.scrollHeight-scroll.clientHeight)));setScrollLeft(cm,Math.max(0,Math.min(scroll.scrollLeft+dx*wheelPixelsPerUnit,scroll.scrollWidth-scroll.clientWidth))); // Only prevent default scrolling if vertical scrolling is
	// actually possible. Otherwise, it causes vertical scroll
	// jitter on OSX trackpads when deltaX is small and deltaY
	// is large (issue #3579)
	if(!dy||dy&&canScrollY)e_preventDefault(e);display.wheelStartX=null; // Abort measurement, if in progress
	return} // 'Project' the visible viewport to cover the area that is being
	// scrolled into view (if we know enough to estimate it).
	if(dy&&wheelPixelsPerUnit!=null){var pixels=dy*wheelPixelsPerUnit;var top=cm.doc.scrollTop,bot=top+display.wrapper.clientHeight;if(pixels<0)top=Math.max(0,top+pixels-50);else bot=Math.min(cm.doc.height,bot+pixels+50);updateDisplaySimple(cm,{top:top,bottom:bot})}if(wheelSamples<20){if(display.wheelStartX==null){display.wheelStartX=scroll.scrollLeft;display.wheelStartY=scroll.scrollTop;display.wheelDX=dx;display.wheelDY=dy;setTimeout(function(){if(display.wheelStartX==null)return;var movedX=scroll.scrollLeft-display.wheelStartX;var movedY=scroll.scrollTop-display.wheelStartY;var sample=movedY&&display.wheelDY&&movedY/display.wheelDY||movedX&&display.wheelDX&&movedX/display.wheelDX;display.wheelStartX=display.wheelStartY=null;if(!sample)return;wheelPixelsPerUnit=(wheelPixelsPerUnit*wheelSamples+sample)/(wheelSamples+1);++wheelSamples},200)}else {display.wheelDX+=dx;display.wheelDY+=dy}}} // KEY EVENTS
	// Run a handler that was bound to a key.
	function doHandleBinding(cm,bound,dropShift){if(typeof bound=="string"){bound=commands[bound];if(!bound)return false} // Ensure previous input has been read, so that the handler sees a
	// consistent view of the document
	cm.display.input.ensurePolled();var prevShift=cm.display.shift,done=false;try{if(isReadOnly(cm))cm.state.suppressEdits=true;if(dropShift)cm.display.shift=false;done=bound(cm)!=Pass}finally {cm.display.shift=prevShift;cm.state.suppressEdits=false}return done}function lookupKeyForEditor(cm,name,handle){for(var i=0;i<cm.state.keyMaps.length;i++){var result=lookupKey(name,cm.state.keyMaps[i],handle,cm);if(result)return result}return cm.options.extraKeys&&lookupKey(name,cm.options.extraKeys,handle,cm)||lookupKey(name,cm.options.keyMap,handle,cm)}var stopSeq=new Delayed;function dispatchKey(cm,name,e,handle){var seq=cm.state.keySeq;if(seq){if(isModifierKey(name))return "handled";stopSeq.set(50,function(){if(cm.state.keySeq==seq){cm.state.keySeq=null;cm.display.input.reset()}});name=seq+" "+name}var result=lookupKeyForEditor(cm,name,handle);if(result=="multi")cm.state.keySeq=name;if(result=="handled")signalLater(cm,"keyHandled",cm,name,e);if(result=="handled"||result=="multi"){e_preventDefault(e);restartBlink(cm)}if(seq&&!result&&/\'$/.test(name)){e_preventDefault(e);return true}return !!result} // Handle a key from the keydown event.
	function handleKeyBinding(cm,e){var name=keyName(e,true);if(!name)return false;if(e.shiftKey&&!cm.state.keySeq){ // First try to resolve full name (including 'Shift-'). Failing
	// that, see if there is a cursor-motion command (starting with
	// 'go') bound to the keyname without 'Shift-'.
	return dispatchKey(cm,"Shift-"+name,e,function(b){return doHandleBinding(cm,b,true)})||dispatchKey(cm,name,e,function(b){if(typeof b=="string"?/^go[A-Z]/.test(b):b.motion)return doHandleBinding(cm,b)})}else {return dispatchKey(cm,name,e,function(b){return doHandleBinding(cm,b)})}} // Handle a key from the keypress event
	function handleCharBinding(cm,e,ch){return dispatchKey(cm,"'"+ch+"'",e,function(b){return doHandleBinding(cm,b,true)})}var lastStoppedKey=null;function onKeyDown(e){var cm=this;cm.curOp.focus=activeElt();if(signalDOMEvent(cm,e))return; // IE does strange things with escape.
	if(ie&&ie_version<11&&e.keyCode==27)e.returnValue=false;var code=e.keyCode;cm.display.shift=code==16||e.shiftKey;var handled=handleKeyBinding(cm,e);if(presto){lastStoppedKey=handled?code:null; // Opera has no cut event... we try to at least catch the key combo
	if(!handled&&code==88&&!hasCopyEvent&&(mac?e.metaKey:e.ctrlKey))cm.replaceSelection("",null,"cut")} // Turn mouse into crosshair when Alt is held on Mac.
	if(code==18&&!/\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className))showCrossHair(cm)}function showCrossHair(cm){var lineDiv=cm.display.lineDiv;addClass(lineDiv,"CodeMirror-crosshair");function up(e){if(e.keyCode==18||!e.altKey){rmClass(lineDiv,"CodeMirror-crosshair");off(document,"keyup",up);off(document,"mouseover",up)}}on(document,"keyup",up);on(document,"mouseover",up)}function onKeyUp(e){if(e.keyCode==16)this.doc.sel.shift=false;signalDOMEvent(this,e)}function onKeyPress(e){var cm=this;if(eventInWidget(cm.display,e)||signalDOMEvent(cm,e)||e.ctrlKey&&!e.altKey||mac&&e.metaKey)return;var keyCode=e.keyCode,charCode=e.charCode;if(presto&&keyCode==lastStoppedKey){lastStoppedKey=null;e_preventDefault(e);return}if(presto&&(!e.which||e.which<10)&&handleKeyBinding(cm,e))return;var ch=String.fromCharCode(charCode==null?keyCode:charCode);if(handleCharBinding(cm,e,ch))return;cm.display.input.onKeyPress(e)} // FOCUS/BLUR EVENTS
	function delayBlurEvent(cm){cm.state.delayingBlurEvent=true;setTimeout(function(){if(cm.state.delayingBlurEvent){cm.state.delayingBlurEvent=false;onBlur(cm)}},100)}function onFocus(cm){if(cm.state.delayingBlurEvent)cm.state.delayingBlurEvent=false;if(cm.options.readOnly=="nocursor")return;if(!cm.state.focused){signal(cm,"focus",cm);cm.state.focused=true;addClass(cm.display.wrapper,"CodeMirror-focused"); // This test prevents this from firing when a context
	// menu is closed (since the input reset would kill the
	// select-all detection hack)
	if(!cm.curOp&&cm.display.selForContextMenu!=cm.doc.sel){cm.display.input.reset();if(webkit)setTimeout(function(){cm.display.input.reset(true)},20); // Issue #1730
	}cm.display.input.receivedFocus()}restartBlink(cm)}function onBlur(cm){if(cm.state.delayingBlurEvent)return;if(cm.state.focused){signal(cm,"blur",cm);cm.state.focused=false;rmClass(cm.display.wrapper,"CodeMirror-focused")}clearInterval(cm.display.blinker);setTimeout(function(){if(!cm.state.focused)cm.display.shift=false},150)} // CONTEXT MENU HANDLING
	// To make the context menu work, we need to briefly unhide the
	// textarea (making it as unobtrusive as possible) to let the
	// right-click take effect on it.
	function onContextMenu(cm,e){if(eventInWidget(cm.display,e)||contextMenuInGutter(cm,e))return;if(signalDOMEvent(cm,e,"contextmenu"))return;cm.display.input.onContextMenu(e)}function contextMenuInGutter(cm,e){if(!hasHandler(cm,"gutterContextMenu"))return false;return gutterEvent(cm,e,"gutterContextMenu",false)} // UPDATING
	// Compute the position of the end of a change (its 'to' property
	// refers to the pre-change end).
	var changeEnd=CodeMirror.changeEnd=function(change){if(!change.text)return change.to;return Pos(change.from.line+change.text.length-1,lst(change.text).length+(change.text.length==1?change.from.ch:0))}; // Adjust a position to refer to the post-change position of the
	// same text, or the end of the change if the change covers it.
	function adjustForChange(pos,change){if(cmp(pos,change.from)<0)return pos;if(cmp(pos,change.to)<=0)return changeEnd(change);var line=pos.line+change.text.length-(change.to.line-change.from.line)-1,ch=pos.ch;if(pos.line==change.to.line)ch+=changeEnd(change).ch-change.to.ch;return Pos(line,ch)}function computeSelAfterChange(doc,change){var out=[];for(var i=0;i<doc.sel.ranges.length;i++){var range=doc.sel.ranges[i];out.push(new Range(adjustForChange(range.anchor,change),adjustForChange(range.head,change)))}return normalizeSelection(out,doc.sel.primIndex)}function offsetPos(pos,old,nw){if(pos.line==old.line)return Pos(nw.line,pos.ch-old.ch+nw.ch);else return Pos(nw.line+(pos.line-old.line),pos.ch)} // Used by replaceSelections to allow moving the selection to the
	// start or around the replaced test. Hint may be "start" or "around".
	function computeReplacedSel(doc,changes,hint){var out=[];var oldPrev=Pos(doc.first,0),newPrev=oldPrev;for(var i=0;i<changes.length;i++){var change=changes[i];var from=offsetPos(change.from,oldPrev,newPrev);var to=offsetPos(changeEnd(change),oldPrev,newPrev);oldPrev=change.to;newPrev=to;if(hint=="around"){var range=doc.sel.ranges[i],inv=cmp(range.head,range.anchor)<0;out[i]=new Range(inv?to:from,inv?from:to)}else {out[i]=new Range(from,from)}}return new Selection(out,doc.sel.primIndex)} // Allow "beforeChange" event handlers to influence a change
	function filterChange(doc,change,update){var obj={canceled:false,from:change.from,to:change.to,text:change.text,origin:change.origin,cancel:function(){this.canceled=true}};if(update)obj.update=function(from,to,text,origin){if(from)this.from=clipPos(doc,from);if(to)this.to=clipPos(doc,to);if(text)this.text=text;if(origin!==undefined)this.origin=origin};signal(doc,"beforeChange",doc,obj);if(doc.cm)signal(doc.cm,"beforeChange",doc.cm,obj);if(obj.canceled)return null;return {from:obj.from,to:obj.to,text:obj.text,origin:obj.origin}} // Apply a change to a document, and add it to the document's
	// history, and propagating it to all linked documents.
	function makeChange(doc,change,ignoreReadOnly){if(doc.cm){if(!doc.cm.curOp)return operation(doc.cm,makeChange)(doc,change,ignoreReadOnly);if(doc.cm.state.suppressEdits)return}if(hasHandler(doc,"beforeChange")||doc.cm&&hasHandler(doc.cm,"beforeChange")){change=filterChange(doc,change,true);if(!change)return} // Possibly split or suppress the update based on the presence
	// of read-only spans in its range.
	var split=sawReadOnlySpans&&!ignoreReadOnly&&removeReadOnlyRanges(doc,change.from,change.to);if(split){for(var i=split.length-1;i>=0;--i)makeChangeInner(doc,{from:split[i].from,to:split[i].to,text:i?[""]:change.text})}else {makeChangeInner(doc,change)}}function makeChangeInner(doc,change){if(change.text.length==1&&change.text[0]==""&&cmp(change.from,change.to)==0)return;var selAfter=computeSelAfterChange(doc,change);addChangeToHistory(doc,change,selAfter,doc.cm?doc.cm.curOp.id:NaN);makeChangeSingleDoc(doc,change,selAfter,stretchSpansOverChange(doc,change));var rebased=[];linkedDocs(doc,function(doc,sharedHist){if(!sharedHist&&indexOf(rebased,doc.history)==-1){rebaseHist(doc.history,change);rebased.push(doc.history)}makeChangeSingleDoc(doc,change,null,stretchSpansOverChange(doc,change))})} // Revert a change stored in a document's history.
	function makeChangeFromHistory(doc,type,allowSelectionOnly){if(doc.cm&&doc.cm.state.suppressEdits)return;var hist=doc.history,event,selAfter=doc.sel;var source=type=="undo"?hist.done:hist.undone,dest=type=="undo"?hist.undone:hist.done; // Verify that there is a useable event (so that ctrl-z won't
	// needlessly clear selection events)
	for(var i=0;i<source.length;i++){event=source[i];if(allowSelectionOnly?event.ranges&&!event.equals(doc.sel):!event.ranges)break}if(i==source.length)return;hist.lastOrigin=hist.lastSelOrigin=null;for(;;){event=source.pop();if(event.ranges){pushSelectionToHistory(event,dest);if(allowSelectionOnly&&!event.equals(doc.sel)){setSelection(doc,event,{clearRedo:false});return}selAfter=event}else break} // Build up a reverse change object to add to the opposite history
	// stack (redo when undoing, and vice versa).
	var antiChanges=[];pushSelectionToHistory(selAfter,dest);dest.push({changes:antiChanges,generation:hist.generation});hist.generation=event.generation||++hist.maxGeneration;var filter=hasHandler(doc,"beforeChange")||doc.cm&&hasHandler(doc.cm,"beforeChange");for(var i=event.changes.length-1;i>=0;--i){var change=event.changes[i];change.origin=type;if(filter&&!filterChange(doc,change,false)){source.length=0;return}antiChanges.push(historyChangeFromChange(doc,change));var after=i?computeSelAfterChange(doc,change):lst(source);makeChangeSingleDoc(doc,change,after,mergeOldSpans(doc,change));if(!i&&doc.cm)doc.cm.scrollIntoView({from:change.from,to:changeEnd(change)});var rebased=[]; // Propagate to the linked documents
	linkedDocs(doc,function(doc,sharedHist){if(!sharedHist&&indexOf(rebased,doc.history)==-1){rebaseHist(doc.history,change);rebased.push(doc.history)}makeChangeSingleDoc(doc,change,null,mergeOldSpans(doc,change))})}} // Sub-views need their line numbers shifted when text is added
	// above or below them in the parent document.
	function shiftDoc(doc,distance){if(distance==0)return;doc.first+=distance;doc.sel=new Selection(map(doc.sel.ranges,function(range){return new Range(Pos(range.anchor.line+distance,range.anchor.ch),Pos(range.head.line+distance,range.head.ch))}),doc.sel.primIndex);if(doc.cm){regChange(doc.cm,doc.first,doc.first-distance,distance);for(var d=doc.cm.display,l=d.viewFrom;l<d.viewTo;l++)regLineChange(doc.cm,l,"gutter")}} // More lower-level change function, handling only a single document
	// (not linked ones).
	function makeChangeSingleDoc(doc,change,selAfter,spans){if(doc.cm&&!doc.cm.curOp)return operation(doc.cm,makeChangeSingleDoc)(doc,change,selAfter,spans);if(change.to.line<doc.first){shiftDoc(doc,change.text.length-1-(change.to.line-change.from.line));return}if(change.from.line>doc.lastLine())return; // Clip the change to the size of this doc
	if(change.from.line<doc.first){var shift=change.text.length-1-(doc.first-change.from.line);shiftDoc(doc,shift);change={from:Pos(doc.first,0),to:Pos(change.to.line+shift,change.to.ch),text:[lst(change.text)],origin:change.origin}}var last=doc.lastLine();if(change.to.line>last){change={from:change.from,to:Pos(last,getLine(doc,last).text.length),text:[change.text[0]],origin:change.origin}}change.removed=getBetween(doc,change.from,change.to);if(!selAfter)selAfter=computeSelAfterChange(doc,change);if(doc.cm)makeChangeSingleDocInEditor(doc.cm,change,spans);else updateDoc(doc,change,spans);setSelectionNoUndo(doc,selAfter,sel_dontScroll)} // Handle the interaction of a change to a document with the editor
	// that this document is part of.
	function makeChangeSingleDocInEditor(cm,change,spans){var doc=cm.doc,display=cm.display,from=change.from,to=change.to;var recomputeMaxLength=false,checkWidthStart=from.line;if(!cm.options.lineWrapping){checkWidthStart=lineNo(visualLine(getLine(doc,from.line)));doc.iter(checkWidthStart,to.line+1,function(line){if(line==display.maxLine){recomputeMaxLength=true;return true}})}if(doc.sel.contains(change.from,change.to)>-1)signalCursorActivity(cm);updateDoc(doc,change,spans,estimateHeight(cm));if(!cm.options.lineWrapping){doc.iter(checkWidthStart,from.line+change.text.length,function(line){var len=lineLength(line);if(len>display.maxLineLength){display.maxLine=line;display.maxLineLength=len;display.maxLineChanged=true;recomputeMaxLength=false}});if(recomputeMaxLength)cm.curOp.updateMaxLine=true} // Adjust frontier, schedule worker
	doc.frontier=Math.min(doc.frontier,from.line);startWorker(cm,400);var lendiff=change.text.length-(to.line-from.line)-1; // Remember that these lines changed, for updating the display
	if(change.full)regChange(cm);else if(from.line==to.line&&change.text.length==1&&!isWholeLineUpdate(cm.doc,change))regLineChange(cm,from.line,"text");else regChange(cm,from.line,to.line+1,lendiff);var changesHandler=hasHandler(cm,"changes"),changeHandler=hasHandler(cm,"change");if(changeHandler||changesHandler){var obj={from:from,to:to,text:change.text,removed:change.removed,origin:change.origin};if(changeHandler)signalLater(cm,"change",cm,obj);if(changesHandler)(cm.curOp.changeObjs||(cm.curOp.changeObjs=[])).push(obj)}cm.display.selForContextMenu=null}function replaceRange(doc,code,from,to,origin){if(!to)to=from;if(cmp(to,from)<0){var tmp=to;to=from;from=tmp}if(typeof code=="string")code=doc.splitLines(code);makeChange(doc,{from:from,to:to,text:code,origin:origin})} // SCROLLING THINGS INTO VIEW
	// If an editor sits on the top or bottom of the window, partially
	// scrolled out of view, this ensures that the cursor is visible.
	function maybeScrollWindow(cm,coords){if(signalDOMEvent(cm,"scrollCursorIntoView"))return;var display=cm.display,box=display.sizer.getBoundingClientRect(),doScroll=null;if(coords.top+box.top<0)doScroll=true;else if(coords.bottom+box.top>(window.innerHeight||document.documentElement.clientHeight))doScroll=false;if(doScroll!=null&&!phantom){var scrollNode=elt("div","\u200b",null,"position: absolute; top: "+(coords.top-display.viewOffset-paddingTop(cm.display))+"px; height: "+(coords.bottom-coords.top+scrollGap(cm)+display.barHeight)+"px; left: "+coords.left+"px; width: 2px;");cm.display.lineSpace.appendChild(scrollNode);scrollNode.scrollIntoView(doScroll);cm.display.lineSpace.removeChild(scrollNode)}} // Scroll a given position into view (immediately), verifying that
	// it actually became visible (as line heights are accurately
	// measured, the position of something may 'drift' during drawing).
	function scrollPosIntoView(cm,pos,end,margin){if(margin==null)margin=0;for(var limit=0;limit<5;limit++){var changed=false,coords=cursorCoords(cm,pos);var endCoords=!end||end==pos?coords:cursorCoords(cm,end);var scrollPos=calculateScrollPos(cm,Math.min(coords.left,endCoords.left),Math.min(coords.top,endCoords.top)-margin,Math.max(coords.left,endCoords.left),Math.max(coords.bottom,endCoords.bottom)+margin);var startTop=cm.doc.scrollTop,startLeft=cm.doc.scrollLeft;if(scrollPos.scrollTop!=null){setScrollTop(cm,scrollPos.scrollTop);if(Math.abs(cm.doc.scrollTop-startTop)>1)changed=true}if(scrollPos.scrollLeft!=null){setScrollLeft(cm,scrollPos.scrollLeft);if(Math.abs(cm.doc.scrollLeft-startLeft)>1)changed=true}if(!changed)break}return coords} // Scroll a given set of coordinates into view (immediately).
	function scrollIntoView(cm,x1,y1,x2,y2){var scrollPos=calculateScrollPos(cm,x1,y1,x2,y2);if(scrollPos.scrollTop!=null)setScrollTop(cm,scrollPos.scrollTop);if(scrollPos.scrollLeft!=null)setScrollLeft(cm,scrollPos.scrollLeft)} // Calculate a new scroll position needed to scroll the given
	// rectangle into view. Returns an object with scrollTop and
	// scrollLeft properties. When these are undefined, the
	// vertical/horizontal position does not need to be adjusted.
	function calculateScrollPos(cm,x1,y1,x2,y2){var display=cm.display,snapMargin=textHeight(cm.display);if(y1<0)y1=0;var screentop=cm.curOp&&cm.curOp.scrollTop!=null?cm.curOp.scrollTop:display.scroller.scrollTop;var screen=displayHeight(cm),result={};if(y2-y1>screen)y2=y1+screen;var docBottom=cm.doc.height+paddingVert(display);var atTop=y1<snapMargin,atBottom=y2>docBottom-snapMargin;if(y1<screentop){result.scrollTop=atTop?0:y1}else if(y2>screentop+screen){var newTop=Math.min(y1,(atBottom?docBottom:y2)-screen);if(newTop!=screentop)result.scrollTop=newTop}var screenleft=cm.curOp&&cm.curOp.scrollLeft!=null?cm.curOp.scrollLeft:display.scroller.scrollLeft;var screenw=displayWidth(cm)-(cm.options.fixedGutter?display.gutters.offsetWidth:0);var tooWide=x2-x1>screenw;if(tooWide)x2=x1+screenw;if(x1<10)result.scrollLeft=0;else if(x1<screenleft)result.scrollLeft=Math.max(0,x1-(tooWide?0:10));else if(x2>screenw+screenleft-3)result.scrollLeft=x2+(tooWide?0:10)-screenw;return result} // Store a relative adjustment to the scroll position in the current
	// operation (to be applied when the operation finishes).
	function addToScrollPos(cm,left,top){if(left!=null||top!=null)resolveScrollToPos(cm);if(left!=null)cm.curOp.scrollLeft=(cm.curOp.scrollLeft==null?cm.doc.scrollLeft:cm.curOp.scrollLeft)+left;if(top!=null)cm.curOp.scrollTop=(cm.curOp.scrollTop==null?cm.doc.scrollTop:cm.curOp.scrollTop)+top} // Make sure that at the end of the operation the current cursor is
	// shown.
	function ensureCursorVisible(cm){resolveScrollToPos(cm);var cur=cm.getCursor(),from=cur,to=cur;if(!cm.options.lineWrapping){from=cur.ch?Pos(cur.line,cur.ch-1):cur;to=Pos(cur.line,cur.ch+1)}cm.curOp.scrollToPos={from:from,to:to,margin:cm.options.cursorScrollMargin,isCursor:true}} // When an operation has its scrollToPos property set, and another
	// scroll action is applied before the end of the operation, this
	// 'simulates' scrolling that position into view in a cheap way, so
	// that the effect of intermediate scroll commands is not ignored.
	function resolveScrollToPos(cm){var range=cm.curOp.scrollToPos;if(range){cm.curOp.scrollToPos=null;var from=estimateCoords(cm,range.from),to=estimateCoords(cm,range.to);var sPos=calculateScrollPos(cm,Math.min(from.left,to.left),Math.min(from.top,to.top)-range.margin,Math.max(from.right,to.right),Math.max(from.bottom,to.bottom)+range.margin);cm.scrollTo(sPos.scrollLeft,sPos.scrollTop)}} // API UTILITIES
	// Indent the given line. The how parameter can be "smart",
	// "add"/null, "subtract", or "prev". When aggressive is false
	// (typically set to true for forced single-line indents), empty
	// lines are not indented, and places where the mode returns Pass
	// are left alone.
	function indentLine(cm,n,how,aggressive){var doc=cm.doc,state;if(how==null)how="add";if(how=="smart"){ // Fall back to "prev" when the mode doesn't have an indentation
	// method.
	if(!doc.mode.indent)how="prev";else state=getStateBefore(cm,n)}var tabSize=cm.options.tabSize;var line=getLine(doc,n),curSpace=countColumn(line.text,null,tabSize);if(line.stateAfter)line.stateAfter=null;var curSpaceString=line.text.match(/^\s*/)[0],indentation;if(!aggressive&&!/\S/.test(line.text)){indentation=0;how="not"}else if(how=="smart"){indentation=doc.mode.indent(state,line.text.slice(curSpaceString.length),line.text);if(indentation==Pass||indentation>150){if(!aggressive)return;how="prev"}}if(how=="prev"){if(n>doc.first)indentation=countColumn(getLine(doc,n-1).text,null,tabSize);else indentation=0}else if(how=="add"){indentation=curSpace+cm.options.indentUnit}else if(how=="subtract"){indentation=curSpace-cm.options.indentUnit}else if(typeof how=="number"){indentation=curSpace+how}indentation=Math.max(0,indentation);var indentString="",pos=0;if(cm.options.indentWithTabs)for(var i=Math.floor(indentation/tabSize);i;--i){pos+=tabSize;indentString+="\t"}if(pos<indentation)indentString+=spaceStr(indentation-pos);if(indentString!=curSpaceString){replaceRange(doc,indentString,Pos(n,0),Pos(n,curSpaceString.length),"+input");line.stateAfter=null;return true}else { // Ensure that, if the cursor was in the whitespace at the start
	// of the line, it is moved to the end of that space.
	for(var i=0;i<doc.sel.ranges.length;i++){var range=doc.sel.ranges[i];if(range.head.line==n&&range.head.ch<curSpaceString.length){var pos=Pos(n,curSpaceString.length);replaceOneSelection(doc,i,new Range(pos,pos));break}}}} // Utility for applying a change to a line by handle or number,
	// returning the number and optionally registering the line as
	// changed.
	function changeLine(doc,handle,changeType,op){var no=handle,line=handle;if(typeof handle=="number")line=getLine(doc,clipLine(doc,handle));else no=lineNo(handle);if(no==null)return null;if(op(line,no)&&doc.cm)regLineChange(doc.cm,no,changeType);return line} // Helper for deleting text near the selection(s), used to implement
	// backspace, delete, and similar functionality.
	function deleteNearSelection(cm,compute){var ranges=cm.doc.sel.ranges,kill=[]; // Build up a set of ranges to kill first, merging overlapping
	// ranges.
	for(var i=0;i<ranges.length;i++){var toKill=compute(ranges[i]);while(kill.length&&cmp(toKill.from,lst(kill).to)<=0){var replaced=kill.pop();if(cmp(replaced.from,toKill.from)<0){toKill.from=replaced.from;break}}kill.push(toKill)} // Next, remove those actual ranges.
	runInOp(cm,function(){for(var i=kill.length-1;i>=0;i--)replaceRange(cm.doc,"",kill[i].from,kill[i].to,"+delete");ensureCursorVisible(cm)})} // Used for horizontal relative motion. Dir is -1 or 1 (left or
	// right), unit can be "char", "column" (like char, but doesn't
	// cross line boundaries), "word" (across next word), or "group" (to
	// the start of next group of word or non-word-non-whitespace
	// chars). The visually param controls whether, in right-to-left
	// text, direction 1 means to move towards the next index in the
	// string, or towards the character to the right of the current
	// position. The resulting position will have a hitSide=true
	// property if it reached the end of the document.
	function findPosH(doc,pos,dir,unit,visually){var line=pos.line,ch=pos.ch,origDir=dir;var lineObj=getLine(doc,line);var possible=true;function findNextLine(){var l=line+dir;if(l<doc.first||l>=doc.first+doc.size)return possible=false;line=l;return lineObj=getLine(doc,l)}function moveOnce(boundToLine){var next=(visually?moveVisually:moveLogically)(lineObj,ch,dir,true);if(next==null){if(!boundToLine&&findNextLine()){if(visually)ch=(dir<0?lineRight:lineLeft)(lineObj);else ch=dir<0?lineObj.text.length:0}else return possible=false}else ch=next;return true}if(unit=="char")moveOnce();else if(unit=="column")moveOnce(true);else if(unit=="word"||unit=="group"){var sawType=null,group=unit=="group";var helper=doc.cm&&doc.cm.getHelper(pos,"wordChars");for(var first=true;;first=false){if(dir<0&&!moveOnce(!first))break;var cur=lineObj.text.charAt(ch)||"\n";var type=isWordChar(cur,helper)?"w":group&&cur=="\n"?"n":!group||/\s/.test(cur)?null:"p";if(group&&!first&&!type)type="s";if(sawType&&sawType!=type){if(dir<0){dir=1;moveOnce()}break}if(type)sawType=type;if(dir>0&&!moveOnce(!first))break}}var result=skipAtomic(doc,Pos(line,ch),origDir,true);if(!possible)result.hitSide=true;return result} // For relative vertical movement. Dir may be -1 or 1. Unit can be
	// "page" or "line". The resulting position will have a hitSide=true
	// property if it reached the end of the document.
	function findPosV(cm,pos,dir,unit){var doc=cm.doc,x=pos.left,y;if(unit=="page"){var pageSize=Math.min(cm.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight);y=pos.top+dir*(pageSize-(dir<0?1.5:.5)*textHeight(cm.display))}else if(unit=="line"){y=dir>0?pos.bottom+3:pos.top-3}for(;;){var target=coordsChar(cm,x,y);if(!target.outside)break;if(dir<0?y<=0:y>=doc.height){target.hitSide=true;break}y+=dir*5}return target} // EDITOR METHODS
	// The publicly visible API. Note that methodOp(f) means
	// 'wrap f in an operation, performed on its `this` parameter'.
	// This is not the complete set of editor methods. Most of the
	// methods defined on the Doc type are also injected into
	// CodeMirror.prototype, for backwards compatibility and
	// convenience.
	CodeMirror.prototype={constructor:CodeMirror,focus:function(){window.focus();this.display.input.focus()},setOption:function(option,value){var options=this.options,old=options[option];if(options[option]==value&&option!="mode")return;options[option]=value;if(optionHandlers.hasOwnProperty(option))operation(this,optionHandlers[option])(this,value,old)},getOption:function(option){return this.options[option]},getDoc:function(){return this.doc},addKeyMap:function(map,bottom){this.state.keyMaps[bottom?"push":"unshift"](getKeyMap(map))},removeKeyMap:function(map){var maps=this.state.keyMaps;for(var i=0;i<maps.length;++i)if(maps[i]==map||maps[i].name==map){maps.splice(i,1);return true}},addOverlay:methodOp(function(spec,options){var mode=spec.token?spec:CodeMirror.getMode(this.options,spec);if(mode.startState)throw new Error("Overlays may not be stateful.");this.state.overlays.push({mode:mode,modeSpec:spec,opaque:options&&options.opaque});this.state.modeGen++;regChange(this)}),removeOverlay:methodOp(function(spec){var overlays=this.state.overlays;for(var i=0;i<overlays.length;++i){var cur=overlays[i].modeSpec;if(cur==spec||typeof spec=="string"&&cur.name==spec){overlays.splice(i,1);this.state.modeGen++;regChange(this);return}}}),indentLine:methodOp(function(n,dir,aggressive){if(typeof dir!="string"&&typeof dir!="number"){if(dir==null)dir=this.options.smartIndent?"smart":"prev";else dir=dir?"add":"subtract"}if(isLine(this.doc,n))indentLine(this,n,dir,aggressive)}),indentSelection:methodOp(function(how){var ranges=this.doc.sel.ranges,end=-1;for(var i=0;i<ranges.length;i++){var range=ranges[i];if(!range.empty()){var from=range.from(),to=range.to();var start=Math.max(end,from.line);end=Math.min(this.lastLine(),to.line-(to.ch?0:1))+1;for(var j=start;j<end;++j)indentLine(this,j,how);var newRanges=this.doc.sel.ranges;if(from.ch==0&&ranges.length==newRanges.length&&newRanges[i].from().ch>0)replaceOneSelection(this.doc,i,new Range(from,newRanges[i].to()),sel_dontScroll)}else if(range.head.line>end){indentLine(this,range.head.line,how,true);end=range.head.line;if(i==this.doc.sel.primIndex)ensureCursorVisible(this)}}}), // Fetch the parser token for a given character. Useful for hacks
	// that want to inspect the mode state (say, for completion).
	getTokenAt:function(pos,precise){return takeToken(this,pos,precise)},getLineTokens:function(line,precise){return takeToken(this,Pos(line),precise,true)},getTokenTypeAt:function(pos){pos=clipPos(this.doc,pos);var styles=getLineStyles(this,getLine(this.doc,pos.line));var before=0,after=(styles.length-1)/2,ch=pos.ch;var type;if(ch==0)type=styles[2];else for(;;){var mid=before+after>>1;if((mid?styles[mid*2-1]:0)>=ch)after=mid;else if(styles[mid*2+1]<ch)before=mid+1;else {type=styles[mid*2+2];break}}var cut=type?type.indexOf("cm-overlay "):-1;return cut<0?type:cut==0?null:type.slice(0,cut-1)},getModeAt:function(pos){var mode=this.doc.mode;if(!mode.innerMode)return mode;return CodeMirror.innerMode(mode,this.getTokenAt(pos).state).mode},getHelper:function(pos,type){return this.getHelpers(pos,type)[0]},getHelpers:function(pos,type){var found=[];if(!helpers.hasOwnProperty(type))return found;var help=helpers[type],mode=this.getModeAt(pos);if(typeof mode[type]=="string"){if(help[mode[type]])found.push(help[mode[type]])}else if(mode[type]){for(var i=0;i<mode[type].length;i++){var val=help[mode[type][i]];if(val)found.push(val)}}else if(mode.helperType&&help[mode.helperType]){found.push(help[mode.helperType])}else if(help[mode.name]){found.push(help[mode.name])}for(var i=0;i<help._global.length;i++){var cur=help._global[i];if(cur.pred(mode,this)&&indexOf(found,cur.val)==-1)found.push(cur.val)}return found},getStateAfter:function(line,precise){var doc=this.doc;line=clipLine(doc,line==null?doc.first+doc.size-1:line);return getStateBefore(this,line+1,precise)},cursorCoords:function(start,mode){var pos,range=this.doc.sel.primary();if(start==null)pos=range.head;else if(typeof start=="object")pos=clipPos(this.doc,start);else pos=start?range.from():range.to();return cursorCoords(this,pos,mode||"page")},charCoords:function(pos,mode){return charCoords(this,clipPos(this.doc,pos),mode||"page")},coordsChar:function(coords,mode){coords=fromCoordSystem(this,coords,mode||"page");return coordsChar(this,coords.left,coords.top)},lineAtHeight:function(height,mode){height=fromCoordSystem(this,{top:height,left:0},mode||"page").top;return lineAtHeight(this.doc,height+this.display.viewOffset)},heightAtLine:function(line,mode){var end=false,lineObj;if(typeof line=="number"){var last=this.doc.first+this.doc.size-1;if(line<this.doc.first)line=this.doc.first;else if(line>last){line=last;end=true}lineObj=getLine(this.doc,line)}else {lineObj=line}return intoCoordSystem(this,lineObj,{top:0,left:0},mode||"page").top+(end?this.doc.height-heightAtLine(lineObj):0)},defaultTextHeight:function(){return textHeight(this.display)},defaultCharWidth:function(){return charWidth(this.display)},setGutterMarker:methodOp(function(line,gutterID,value){return changeLine(this.doc,line,"gutter",function(line){var markers=line.gutterMarkers||(line.gutterMarkers={});markers[gutterID]=value;if(!value&&isEmpty(markers))line.gutterMarkers=null;return true})}),clearGutter:methodOp(function(gutterID){var cm=this,doc=cm.doc,i=doc.first;doc.iter(function(line){if(line.gutterMarkers&&line.gutterMarkers[gutterID]){line.gutterMarkers[gutterID]=null;regLineChange(cm,i,"gutter");if(isEmpty(line.gutterMarkers))line.gutterMarkers=null}++i})}),lineInfo:function(line){if(typeof line=="number"){if(!isLine(this.doc,line))return null;var n=line;line=getLine(this.doc,line);if(!line)return null}else {var n=lineNo(line);if(n==null)return null}return {line:n,handle:line,text:line.text,gutterMarkers:line.gutterMarkers,textClass:line.textClass,bgClass:line.bgClass,wrapClass:line.wrapClass,widgets:line.widgets}},getViewport:function(){return {from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(pos,node,scroll,vert,horiz){var display=this.display;pos=cursorCoords(this,clipPos(this.doc,pos));var top=pos.bottom,left=pos.left;node.style.position="absolute";node.setAttribute("cm-ignore-events","true");this.display.input.setUneditable(node);display.sizer.appendChild(node);if(vert=="over"){top=pos.top}else if(vert=="above"||vert=="near"){var vspace=Math.max(display.wrapper.clientHeight,this.doc.height),hspace=Math.max(display.sizer.clientWidth,display.lineSpace.clientWidth); // Default to positioning above (if specified and possible); otherwise default to positioning below
	if((vert=='above'||pos.bottom+node.offsetHeight>vspace)&&pos.top>node.offsetHeight)top=pos.top-node.offsetHeight;else if(pos.bottom+node.offsetHeight<=vspace)top=pos.bottom;if(left+node.offsetWidth>hspace)left=hspace-node.offsetWidth}node.style.top=top+"px";node.style.left=node.style.right="";if(horiz=="right"){left=display.sizer.clientWidth-node.offsetWidth;node.style.right="0px"}else {if(horiz=="left")left=0;else if(horiz=="middle")left=(display.sizer.clientWidth-node.offsetWidth)/2;node.style.left=left+"px"}if(scroll)scrollIntoView(this,left,top,left+node.offsetWidth,top+node.offsetHeight)},triggerOnKeyDown:methodOp(onKeyDown),triggerOnKeyPress:methodOp(onKeyPress),triggerOnKeyUp:onKeyUp,execCommand:function(cmd){if(commands.hasOwnProperty(cmd))return commands[cmd].call(null,this)},triggerElectric:methodOp(function(text){triggerElectric(this,text)}),findPosH:function(from,amount,unit,visually){var dir=1;if(amount<0){dir=-1;amount=-amount}for(var i=0,cur=clipPos(this.doc,from);i<amount;++i){cur=findPosH(this.doc,cur,dir,unit,visually);if(cur.hitSide)break}return cur},moveH:methodOp(function(dir,unit){var cm=this;cm.extendSelectionsBy(function(range){if(cm.display.shift||cm.doc.extend||range.empty())return findPosH(cm.doc,range.head,dir,unit,cm.options.rtlMoveVisually);else return dir<0?range.from():range.to()},sel_move)}),deleteH:methodOp(function(dir,unit){var sel=this.doc.sel,doc=this.doc;if(sel.somethingSelected())doc.replaceSelection("",null,"+delete");else deleteNearSelection(this,function(range){var other=findPosH(doc,range.head,dir,unit,false);return dir<0?{from:other,to:range.head}:{from:range.head,to:other}})}),findPosV:function(from,amount,unit,goalColumn){var dir=1,x=goalColumn;if(amount<0){dir=-1;amount=-amount}for(var i=0,cur=clipPos(this.doc,from);i<amount;++i){var coords=cursorCoords(this,cur,"div");if(x==null)x=coords.left;else coords.left=x;cur=findPosV(this,coords,dir,unit);if(cur.hitSide)break}return cur},moveV:methodOp(function(dir,unit){var cm=this,doc=this.doc,goals=[];var collapse=!cm.display.shift&&!doc.extend&&doc.sel.somethingSelected();doc.extendSelectionsBy(function(range){if(collapse)return dir<0?range.from():range.to();var headPos=cursorCoords(cm,range.head,"div");if(range.goalColumn!=null)headPos.left=range.goalColumn;goals.push(headPos.left);var pos=findPosV(cm,headPos,dir,unit);if(unit=="page"&&range==doc.sel.primary())addToScrollPos(cm,null,charCoords(cm,pos,"div").top-headPos.top);return pos},sel_move);if(goals.length)for(var i=0;i<doc.sel.ranges.length;i++)doc.sel.ranges[i].goalColumn=goals[i]}), // Find the word at the given position (as returned by coordsChar).
	findWordAt:function(pos){var doc=this.doc,line=getLine(doc,pos.line).text;var start=pos.ch,end=pos.ch;if(line){var helper=this.getHelper(pos,"wordChars");if((pos.xRel<0||end==line.length)&&start)--start;else ++end;var startChar=line.charAt(start);var check=isWordChar(startChar,helper)?function(ch){return isWordChar(ch,helper)}:/\s/.test(startChar)?function(ch){return (/\s/.test(ch))}:function(ch){return !/\s/.test(ch)&&!isWordChar(ch)};while(start>0&&check(line.charAt(start-1)))--start;while(end<line.length&&check(line.charAt(end)))++end}return new Range(Pos(pos.line,start),Pos(pos.line,end))},toggleOverwrite:function(value){if(value!=null&&value==this.state.overwrite)return;if(this.state.overwrite=!this.state.overwrite)addClass(this.display.cursorDiv,"CodeMirror-overwrite");else rmClass(this.display.cursorDiv,"CodeMirror-overwrite");signal(this,"overwriteToggle",this,this.state.overwrite)},hasFocus:function(){return this.display.input.getField()==activeElt()},scrollTo:methodOp(function(x,y){if(x!=null||y!=null)resolveScrollToPos(this);if(x!=null)this.curOp.scrollLeft=x;if(y!=null)this.curOp.scrollTop=y}),getScrollInfo:function(){var scroller=this.display.scroller;return {left:scroller.scrollLeft,top:scroller.scrollTop,height:scroller.scrollHeight-scrollGap(this)-this.display.barHeight,width:scroller.scrollWidth-scrollGap(this)-this.display.barWidth,clientHeight:displayHeight(this),clientWidth:displayWidth(this)}},scrollIntoView:methodOp(function(range,margin){if(range==null){range={from:this.doc.sel.primary().head,to:null};if(margin==null)margin=this.options.cursorScrollMargin}else if(typeof range=="number"){range={from:Pos(range,0),to:null}}else if(range.from==null){range={from:range,to:null}}if(!range.to)range.to=range.from;range.margin=margin||0;if(range.from.line!=null){resolveScrollToPos(this);this.curOp.scrollToPos=range}else {var sPos=calculateScrollPos(this,Math.min(range.from.left,range.to.left),Math.min(range.from.top,range.to.top)-range.margin,Math.max(range.from.right,range.to.right),Math.max(range.from.bottom,range.to.bottom)+range.margin);this.scrollTo(sPos.scrollLeft,sPos.scrollTop)}}),setSize:methodOp(function(width,height){var cm=this;function interpret(val){return typeof val=="number"||/^\d+$/.test(String(val))?val+"px":val}if(width!=null)cm.display.wrapper.style.width=interpret(width);if(height!=null)cm.display.wrapper.style.height=interpret(height);if(cm.options.lineWrapping)clearLineMeasurementCache(this);var lineNo=cm.display.viewFrom;cm.doc.iter(lineNo,cm.display.viewTo,function(line){if(line.widgets)for(var i=0;i<line.widgets.length;i++)if(line.widgets[i].noHScroll){regLineChange(cm,lineNo,"widget");break}++lineNo});cm.curOp.forceUpdate=true;signal(cm,"refresh",this)}),operation:function(f){return runInOp(this,f)},refresh:methodOp(function(){var oldHeight=this.display.cachedTextHeight;regChange(this);this.curOp.forceUpdate=true;clearCaches(this);this.scrollTo(this.doc.scrollLeft,this.doc.scrollTop);updateGutterSpace(this);if(oldHeight==null||Math.abs(oldHeight-textHeight(this.display))>.5)estimateLineHeights(this);signal(this,"refresh",this)}),swapDoc:methodOp(function(doc){var old=this.doc;old.cm=null;attachDoc(this,doc);clearCaches(this);this.display.input.reset();this.scrollTo(doc.scrollLeft,doc.scrollTop);this.curOp.forceScroll=true;signalLater(this,"swapDoc",this,old);return old}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}};eventMixin(CodeMirror); // OPTION DEFAULTS
	// The default configuration options.
	var defaults=CodeMirror.defaults={}; // Functions to run when options are changed.
	var optionHandlers=CodeMirror.optionHandlers={};function option(name,deflt,handle,notOnInit){CodeMirror.defaults[name]=deflt;if(handle)optionHandlers[name]=notOnInit?function(cm,val,old){if(old!=Init)handle(cm,val,old)}:handle} // Passed to option handlers when there is no old value.
	var Init=CodeMirror.Init={toString:function(){return "CodeMirror.Init"}}; // These two are, on init, called from the constructor because they
	// have to be initialized before the editor can start at all.
	option("value","",function(cm,val){cm.setValue(val)},true);option("mode",null,function(cm,val){cm.doc.modeOption=val;loadMode(cm)},true);option("indentUnit",2,loadMode,true);option("indentWithTabs",false);option("smartIndent",true);option("tabSize",4,function(cm){resetModeState(cm);clearCaches(cm);regChange(cm)},true);option("lineSeparator",null,function(cm,val){cm.doc.lineSep=val;if(!val)return;var newBreaks=[],lineNo=cm.doc.first;cm.doc.iter(function(line){for(var pos=0;;){var found=line.text.indexOf(val,pos);if(found==-1)break;pos=found+val.length;newBreaks.push(Pos(lineNo,found))}lineNo++});for(var i=newBreaks.length-1;i>=0;i--)replaceRange(cm.doc,val,newBreaks[i],Pos(newBreaks[i].line,newBreaks[i].ch+val.length))});option("specialChars",/[\t\u0000-\u0019\u00ad\u200b-\u200f\u2028\u2029\ufeff]/g,function(cm,val,old){cm.state.specialChars=new RegExp(val.source+(val.test("\t")?"":"|\t"),"g");if(old!=CodeMirror.Init)cm.refresh()});option("specialCharPlaceholder",defaultSpecialCharPlaceholder,function(cm){cm.refresh()},true);option("electricChars",true);option("inputStyle",mobile?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor"); // FIXME
	},true);option("rtlMoveVisually",!windows);option("wholeLineUpdateBefore",true);option("theme","default",function(cm){themeChanged(cm);guttersChanged(cm)},true);option("keyMap","default",function(cm,val,old){var next=getKeyMap(val);var prev=old!=CodeMirror.Init&&getKeyMap(old);if(prev&&prev.detach)prev.detach(cm,next);if(next.attach)next.attach(cm,prev||null)});option("extraKeys",null);option("lineWrapping",false,wrappingChanged,true);option("gutters",[],function(cm){setGuttersForLineNumbers(cm.options);guttersChanged(cm)},true);option("fixedGutter",true,function(cm,val){cm.display.gutters.style.left=val?compensateForHScroll(cm.display)+"px":"0";cm.refresh()},true);option("coverGutterNextToScrollbar",false,function(cm){updateScrollbars(cm)},true);option("scrollbarStyle","native",function(cm){initScrollbars(cm);updateScrollbars(cm);cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft)},true);option("lineNumbers",false,function(cm){setGuttersForLineNumbers(cm.options);guttersChanged(cm)},true);option("firstLineNumber",1,guttersChanged,true);option("lineNumberFormatter",function(integer){return integer},guttersChanged,true);option("showCursorWhenSelecting",false,updateSelection,true);option("resetSelectionOnContextMenu",true);option("lineWiseCopyCut",true);option("readOnly",false,function(cm,val){if(val=="nocursor"){onBlur(cm);cm.display.input.blur();cm.display.disabled=true}else {cm.display.disabled=false}cm.display.input.readOnlyChanged(val)});option("disableInput",false,function(cm,val){if(!val)cm.display.input.reset()},true);option("dragDrop",true,dragDropChanged);option("allowDropFileTypes",null);option("cursorBlinkRate",530);option("cursorScrollMargin",0);option("cursorHeight",1,updateSelection,true);option("singleCursorHeightPerLine",true,updateSelection,true);option("workTime",100);option("workDelay",100);option("flattenSpans",true,resetModeState,true);option("addModeClass",false,resetModeState,true);option("pollInterval",100);option("undoDepth",200,function(cm,val){cm.doc.history.undoDepth=val});option("historyEventDelay",1250);option("viewportMargin",10,function(cm){cm.refresh()},true);option("maxHighlightLength",10000,resetModeState,true);option("moveInputWithCursor",true,function(cm,val){if(!val)cm.display.input.resetPosition()});option("tabindex",null,function(cm,val){cm.display.input.getField().tabIndex=val||""});option("autofocus",null); // MODE DEFINITION AND QUERYING
	// Known modes, by name and by MIME
	var modes=CodeMirror.modes={},mimeModes=CodeMirror.mimeModes={}; // Extra arguments are stored as the mode's dependencies, which is
	// used by (legacy) mechanisms like loadmode.js to automatically
	// load a mode. (Preferred mechanism is the require/define calls.)
	CodeMirror.defineMode=function(name,mode){if(!CodeMirror.defaults.mode&&name!="null")CodeMirror.defaults.mode=name;if(arguments.length>2)mode.dependencies=Array.prototype.slice.call(arguments,2);modes[name]=mode};CodeMirror.defineMIME=function(mime,spec){mimeModes[mime]=spec}; // Given a MIME type, a {name, ...options} config object, or a name
	// string, return a mode config object.
	CodeMirror.resolveMode=function(spec){if(typeof spec=="string"&&mimeModes.hasOwnProperty(spec)){spec=mimeModes[spec]}else if(spec&&typeof spec.name=="string"&&mimeModes.hasOwnProperty(spec.name)){var found=mimeModes[spec.name];if(typeof found=="string")found={name:found};spec=createObj(found,spec);spec.name=found.name}else if(typeof spec=="string"&&/^[\w\-]+\/[\w\-]+\+xml$/.test(spec)){return CodeMirror.resolveMode("application/xml")}if(typeof spec=="string")return {name:spec};else return spec||{name:"null"}}; // Given a mode spec (anything that resolveMode accepts), find and
	// initialize an actual mode object.
	CodeMirror.getMode=function(options,spec){var spec=CodeMirror.resolveMode(spec);var mfactory=modes[spec.name];if(!mfactory)return CodeMirror.getMode(options,"text/plain");var modeObj=mfactory(options,spec);if(modeExtensions.hasOwnProperty(spec.name)){var exts=modeExtensions[spec.name];for(var prop in exts){if(!exts.hasOwnProperty(prop))continue;if(modeObj.hasOwnProperty(prop))modeObj["_"+prop]=modeObj[prop];modeObj[prop]=exts[prop]}}modeObj.name=spec.name;if(spec.helperType)modeObj.helperType=spec.helperType;if(spec.modeProps)for(var prop in spec.modeProps)modeObj[prop]=spec.modeProps[prop];return modeObj}; // Minimal default mode.
	CodeMirror.defineMode("null",function(){return {token:function(stream){stream.skipToEnd()}}});CodeMirror.defineMIME("text/plain","null"); // This can be used to attach properties to mode objects from
	// outside the actual mode definition.
	var modeExtensions=CodeMirror.modeExtensions={};CodeMirror.extendMode=function(mode,properties){var exts=modeExtensions.hasOwnProperty(mode)?modeExtensions[mode]:modeExtensions[mode]={};copyObj(properties,exts)}; // EXTENSIONS
	CodeMirror.defineExtension=function(name,func){CodeMirror.prototype[name]=func};CodeMirror.defineDocExtension=function(name,func){Doc.prototype[name]=func};CodeMirror.defineOption=option;var initHooks=[];CodeMirror.defineInitHook=function(f){initHooks.push(f)};var helpers=CodeMirror.helpers={};CodeMirror.registerHelper=function(type,name,value){if(!helpers.hasOwnProperty(type))helpers[type]=CodeMirror[type]={_global:[]};helpers[type][name]=value};CodeMirror.registerGlobalHelper=function(type,name,predicate,value){CodeMirror.registerHelper(type,name,value);helpers[type]._global.push({pred:predicate,val:value})}; // MODE STATE HANDLING
	// Utility functions for working with state. Exported because nested
	// modes need to do this for their inner modes.
	var copyState=CodeMirror.copyState=function(mode,state){if(state===true)return state;if(mode.copyState)return mode.copyState(state);var nstate={};for(var n in state){var val=state[n];if(val instanceof Array)val=val.concat([]);nstate[n]=val}return nstate};var startState=CodeMirror.startState=function(mode,a1,a2){return mode.startState?mode.startState(a1,a2):true}; // Given a mode and a state (for that mode), find the inner mode and
	// state at the position that the state refers to.
	CodeMirror.innerMode=function(mode,state){while(mode.innerMode){var info=mode.innerMode(state);if(!info||info.mode==mode)break;state=info.state;mode=info.mode}return info||{mode:mode,state:state}}; // STANDARD COMMANDS
	// Commands are parameter-less actions that can be performed on an
	// editor, mostly used for keybindings.
	var commands=CodeMirror.commands={selectAll:function(cm){cm.setSelection(Pos(cm.firstLine(),0),Pos(cm.lastLine()),sel_dontScroll)},singleSelection:function(cm){cm.setSelection(cm.getCursor("anchor"),cm.getCursor("head"),sel_dontScroll)},killLine:function(cm){deleteNearSelection(cm,function(range){if(range.empty()){var len=getLine(cm.doc,range.head.line).text.length;if(range.head.ch==len&&range.head.line<cm.lastLine())return {from:range.head,to:Pos(range.head.line+1,0)};else return {from:range.head,to:Pos(range.head.line,len)}}else {return {from:range.from(),to:range.to()}}})},deleteLine:function(cm){deleteNearSelection(cm,function(range){return {from:Pos(range.from().line,0),to:clipPos(cm.doc,Pos(range.to().line+1,0))}})},delLineLeft:function(cm){deleteNearSelection(cm,function(range){return {from:Pos(range.from().line,0),to:range.from()}})},delWrappedLineLeft:function(cm){deleteNearSelection(cm,function(range){var top=cm.charCoords(range.head,"div").top+5;var leftPos=cm.coordsChar({left:0,top:top},"div");return {from:leftPos,to:range.from()}})},delWrappedLineRight:function(cm){deleteNearSelection(cm,function(range){var top=cm.charCoords(range.head,"div").top+5;var rightPos=cm.coordsChar({left:cm.display.lineDiv.offsetWidth+100,top:top},"div");return {from:range.from(),to:rightPos}})},undo:function(cm){cm.undo()},redo:function(cm){cm.redo()},undoSelection:function(cm){cm.undoSelection()},redoSelection:function(cm){cm.redoSelection()},goDocStart:function(cm){cm.extendSelection(Pos(cm.firstLine(),0))},goDocEnd:function(cm){cm.extendSelection(Pos(cm.lastLine()))},goLineStart:function(cm){cm.extendSelectionsBy(function(range){return lineStart(cm,range.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(cm){cm.extendSelectionsBy(function(range){return lineStartSmart(cm,range.head)},{origin:"+move",bias:1})},goLineEnd:function(cm){cm.extendSelectionsBy(function(range){return lineEnd(cm,range.head.line)},{origin:"+move",bias:-1})},goLineRight:function(cm){cm.extendSelectionsBy(function(range){var top=cm.charCoords(range.head,"div").top+5;return cm.coordsChar({left:cm.display.lineDiv.offsetWidth+100,top:top},"div")},sel_move)},goLineLeft:function(cm){cm.extendSelectionsBy(function(range){var top=cm.charCoords(range.head,"div").top+5;return cm.coordsChar({left:0,top:top},"div")},sel_move)},goLineLeftSmart:function(cm){cm.extendSelectionsBy(function(range){var top=cm.charCoords(range.head,"div").top+5;var pos=cm.coordsChar({left:0,top:top},"div");if(pos.ch<cm.getLine(pos.line).search(/\S/))return lineStartSmart(cm,range.head);return pos},sel_move)},goLineUp:function(cm){cm.moveV(-1,"line")},goLineDown:function(cm){cm.moveV(1,"line")},goPageUp:function(cm){cm.moveV(-1,"page")},goPageDown:function(cm){cm.moveV(1,"page")},goCharLeft:function(cm){cm.moveH(-1,"char")},goCharRight:function(cm){cm.moveH(1,"char")},goColumnLeft:function(cm){cm.moveH(-1,"column")},goColumnRight:function(cm){cm.moveH(1,"column")},goWordLeft:function(cm){cm.moveH(-1,"word")},goGroupRight:function(cm){cm.moveH(1,"group")},goGroupLeft:function(cm){cm.moveH(-1,"group")},goWordRight:function(cm){cm.moveH(1,"word")},delCharBefore:function(cm){cm.deleteH(-1,"char")},delCharAfter:function(cm){cm.deleteH(1,"char")},delWordBefore:function(cm){cm.deleteH(-1,"word")},delWordAfter:function(cm){cm.deleteH(1,"word")},delGroupBefore:function(cm){cm.deleteH(-1,"group")},delGroupAfter:function(cm){cm.deleteH(1,"group")},indentAuto:function(cm){cm.indentSelection("smart")},indentMore:function(cm){cm.indentSelection("add")},indentLess:function(cm){cm.indentSelection("subtract")},insertTab:function(cm){cm.replaceSelection("\t")},insertSoftTab:function(cm){var spaces=[],ranges=cm.listSelections(),tabSize=cm.options.tabSize;for(var i=0;i<ranges.length;i++){var pos=ranges[i].from();var col=countColumn(cm.getLine(pos.line),pos.ch,tabSize);spaces.push(new Array(tabSize-col%tabSize+1).join(" "))}cm.replaceSelections(spaces)},defaultTab:function(cm){if(cm.somethingSelected())cm.indentSelection("add");else cm.execCommand("insertTab")},transposeChars:function(cm){runInOp(cm,function(){var ranges=cm.listSelections(),newSel=[];for(var i=0;i<ranges.length;i++){var cur=ranges[i].head,line=getLine(cm.doc,cur.line).text;if(line){if(cur.ch==line.length)cur=new Pos(cur.line,cur.ch-1);if(cur.ch>0){cur=new Pos(cur.line,cur.ch+1);cm.replaceRange(line.charAt(cur.ch-1)+line.charAt(cur.ch-2),Pos(cur.line,cur.ch-2),cur,"+transpose")}else if(cur.line>cm.doc.first){var prev=getLine(cm.doc,cur.line-1).text;if(prev)cm.replaceRange(line.charAt(0)+cm.doc.lineSeparator()+prev.charAt(prev.length-1),Pos(cur.line-1,prev.length-1),Pos(cur.line,1),"+transpose")}}newSel.push(new Range(cur,cur))}cm.setSelections(newSel)})},newlineAndIndent:function(cm){runInOp(cm,function(){var len=cm.listSelections().length;for(var i=0;i<len;i++){var range=cm.listSelections()[i];cm.replaceRange(cm.doc.lineSeparator(),range.anchor,range.head,"+input");cm.indentLine(range.from().line+1,null,true)}ensureCursorVisible(cm)})},toggleOverwrite:function(cm){cm.toggleOverwrite()}}; // STANDARD KEYMAPS
	var keyMap=CodeMirror.keyMap={};keyMap.basic={"Left":"goCharLeft","Right":"goCharRight","Up":"goLineUp","Down":"goLineDown","End":"goLineEnd","Home":"goLineStartSmart","PageUp":"goPageUp","PageDown":"goPageDown","Delete":"delCharAfter","Backspace":"delCharBefore","Shift-Backspace":"delCharBefore","Tab":"defaultTab","Shift-Tab":"indentAuto","Enter":"newlineAndIndent","Insert":"toggleOverwrite","Esc":"singleSelection"}; // Note that the save and find-related commands aren't defined by
	// default. User code or addons can define them. Unknown commands
	// are simply ignored.
	keyMap.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"}; // Very basic readline/emacs-style bindings, which are standard on Mac.
	keyMap.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars"};keyMap.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]};keyMap["default"]=mac?keyMap.macDefault:keyMap.pcDefault; // KEYMAP DISPATCH
	function normalizeKeyName(name){var parts=name.split(/-(?!$)/),name=parts[parts.length-1];var alt,ctrl,shift,cmd;for(var i=0;i<parts.length-1;i++){var mod=parts[i];if(/^(cmd|meta|m)$/i.test(mod))cmd=true;else if(/^a(lt)?$/i.test(mod))alt=true;else if(/^(c|ctrl|control)$/i.test(mod))ctrl=true;else if(/^s(hift)$/i.test(mod))shift=true;else throw new Error("Unrecognized modifier name: "+mod)}if(alt)name="Alt-"+name;if(ctrl)name="Ctrl-"+name;if(cmd)name="Cmd-"+name;if(shift)name="Shift-"+name;return name} // This is a kludge to keep keymaps mostly working as raw objects
	// (backwards compatibility) while at the same time support features
	// like normalization and multi-stroke key bindings. It compiles a
	// new normalized keymap, and then updates the old object to reflect
	// this.
	CodeMirror.normalizeKeyMap=function(keymap){var copy={};for(var keyname in keymap)if(keymap.hasOwnProperty(keyname)){var value=keymap[keyname];if(/^(name|fallthrough|(de|at)tach)$/.test(keyname))continue;if(value=="..."){delete keymap[keyname];continue}var keys=map(keyname.split(" "),normalizeKeyName);for(var i=0;i<keys.length;i++){var val,name;if(i==keys.length-1){name=keys.join(" ");val=value}else {name=keys.slice(0,i+1).join(" ");val="..."}var prev=copy[name];if(!prev)copy[name]=val;else if(prev!=val)throw new Error("Inconsistent bindings for "+name)}delete keymap[keyname]}for(var prop in copy)keymap[prop]=copy[prop];return keymap};var lookupKey=CodeMirror.lookupKey=function(key,map,handle,context){map=getKeyMap(map);var found=map.call?map.call(key,context):map[key];if(found===false)return "nothing";if(found==="...")return "multi";if(found!=null&&handle(found))return "handled";if(map.fallthrough){if(Object.prototype.toString.call(map.fallthrough)!="[object Array]")return lookupKey(key,map.fallthrough,handle,context);for(var i=0;i<map.fallthrough.length;i++){var result=lookupKey(key,map.fallthrough[i],handle,context);if(result)return result}}}; // Modifier key presses don't count as 'real' key presses for the
	// purpose of keymap fallthrough.
	var isModifierKey=CodeMirror.isModifierKey=function(value){var name=typeof value=="string"?value:keyNames[value.keyCode];return name=="Ctrl"||name=="Alt"||name=="Shift"||name=="Mod"}; // Look up the name of a key as indicated by an event object.
	var keyName=CodeMirror.keyName=function(event,noShift){if(presto&&event.keyCode==34&&event["char"])return false;var base=keyNames[event.keyCode],name=base;if(name==null||event.altGraphKey)return false;if(event.altKey&&base!="Alt")name="Alt-"+name;if((flipCtrlCmd?event.metaKey:event.ctrlKey)&&base!="Ctrl")name="Ctrl-"+name;if((flipCtrlCmd?event.ctrlKey:event.metaKey)&&base!="Cmd")name="Cmd-"+name;if(!noShift&&event.shiftKey&&base!="Shift")name="Shift-"+name;return name};function getKeyMap(val){return typeof val=="string"?keyMap[val]:val} // FROMTEXTAREA
	CodeMirror.fromTextArea=function(textarea,options){options=options?copyObj(options):{};options.value=textarea.value;if(!options.tabindex&&textarea.tabIndex)options.tabindex=textarea.tabIndex;if(!options.placeholder&&textarea.placeholder)options.placeholder=textarea.placeholder; // Set autofocus to true if this textarea is focused, or if it has
	// autofocus and no other element is focused.
	if(options.autofocus==null){var hasFocus=activeElt();options.autofocus=hasFocus==textarea||textarea.getAttribute("autofocus")!=null&&hasFocus==document.body}function save(){textarea.value=cm.getValue()}if(textarea.form){on(textarea.form,"submit",save); // Deplorable hack to make the submit method do the right thing.
	if(!options.leaveSubmitMethodAlone){var form=textarea.form,realSubmit=form.submit;try{var wrappedSubmit=form.submit=function(){save();form.submit=realSubmit;form.submit();form.submit=wrappedSubmit}}catch(e) {}}}options.finishInit=function(cm){cm.save=save;cm.getTextArea=function(){return textarea};cm.toTextArea=function(){cm.toTextArea=isNaN; // Prevent this from being ran twice
	save();textarea.parentNode.removeChild(cm.getWrapperElement());textarea.style.display="";if(textarea.form){off(textarea.form,"submit",save);if(typeof textarea.form.submit=="function")textarea.form.submit=realSubmit}}};textarea.style.display="none";var cm=CodeMirror(function(node){textarea.parentNode.insertBefore(node,textarea.nextSibling)},options);return cm}; // STRING STREAM
	// Fed to the mode parsers, provides helper functions to make
	// parsers more succinct.
	var StringStream=CodeMirror.StringStream=function(string,tabSize){this.pos=this.start=0;this.string=string;this.tabSize=tabSize||8;this.lastColumnPos=this.lastColumnValue=0;this.lineStart=0};StringStream.prototype={eol:function(){return this.pos>=this.string.length},sol:function(){return this.pos==this.lineStart},peek:function(){return this.string.charAt(this.pos)||undefined},next:function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},eat:function(match){var ch=this.string.charAt(this.pos);if(typeof match=="string")var ok=ch==match;else var ok=ch&&(match.test?match.test(ch):match(ch));if(ok){++this.pos;return ch}},eatWhile:function(match){var start=this.pos;while(this.eat(match)){}return this.pos>start},eatSpace:function(){var start=this.pos;while(/[\s\u00a0]/.test(this.string.charAt(this.pos)))++this.pos;return this.pos>start},skipToEnd:function(){this.pos=this.string.length},skipTo:function(ch){var found=this.string.indexOf(ch,this.pos);if(found>-1){this.pos=found;return true}},backUp:function(n){this.pos-=n},column:function(){if(this.lastColumnPos<this.start){this.lastColumnValue=countColumn(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue);this.lastColumnPos=this.start}return this.lastColumnValue-(this.lineStart?countColumn(this.string,this.lineStart,this.tabSize):0)},indentation:function(){return countColumn(this.string,null,this.tabSize)-(this.lineStart?countColumn(this.string,this.lineStart,this.tabSize):0)},match:function(pattern,consume,caseInsensitive){if(typeof pattern=="string"){var cased=function(str){return caseInsensitive?str.toLowerCase():str};var substr=this.string.substr(this.pos,pattern.length);if(cased(substr)==cased(pattern)){if(consume!==false)this.pos+=pattern.length;return true}}else {var match=this.string.slice(this.pos).match(pattern);if(match&&match.index>0)return null;if(match&&consume!==false)this.pos+=match[0].length;return match}},current:function(){return this.string.slice(this.start,this.pos)},hideFirstChars:function(n,inner){this.lineStart+=n;try{return inner()}finally {this.lineStart-=n}}}; // TEXTMARKERS
	// Created with markText and setBookmark methods. A TextMarker is a
	// handle that can be used to clear or find a marked position in the
	// document. Line objects hold arrays (markedSpans) containing
	// {from, to, marker} object pointing to such marker objects, and
	// indicating that such a marker is present on that line. Multiple
	// lines may point to the same marker when it spans across lines.
	// The spans will have null for their from/to properties when the
	// marker continues beyond the start/end of the line. Markers have
	// links back to the lines they currently touch.
	var nextMarkerId=0;var TextMarker=CodeMirror.TextMarker=function(doc,type){this.lines=[];this.type=type;this.doc=doc;this.id=++nextMarkerId};eventMixin(TextMarker); // Clear the marker.
	TextMarker.prototype.clear=function(){if(this.explicitlyCleared)return;var cm=this.doc.cm,withOp=cm&&!cm.curOp;if(withOp)startOperation(cm);if(hasHandler(this,"clear")){var found=this.find();if(found)signalLater(this,"clear",found.from,found.to)}var min=null,max=null;for(var i=0;i<this.lines.length;++i){var line=this.lines[i];var span=getMarkedSpanFor(line.markedSpans,this);if(cm&&!this.collapsed)regLineChange(cm,lineNo(line),"text");else if(cm){if(span.to!=null)max=lineNo(line);if(span.from!=null)min=lineNo(line)}line.markedSpans=removeMarkedSpan(line.markedSpans,span);if(span.from==null&&this.collapsed&&!lineIsHidden(this.doc,line)&&cm)updateLineHeight(line,textHeight(cm.display))}if(cm&&this.collapsed&&!cm.options.lineWrapping)for(var i=0;i<this.lines.length;++i){var visual=visualLine(this.lines[i]),len=lineLength(visual);if(len>cm.display.maxLineLength){cm.display.maxLine=visual;cm.display.maxLineLength=len;cm.display.maxLineChanged=true}}if(min!=null&&cm&&this.collapsed)regChange(cm,min,max+1);this.lines.length=0;this.explicitlyCleared=true;if(this.atomic&&this.doc.cantEdit){this.doc.cantEdit=false;if(cm)reCheckSelection(cm.doc)}if(cm)signalLater(cm,"markerCleared",cm,this);if(withOp)endOperation(cm);if(this.parent)this.parent.clear()}; // Find the position of the marker in the document. Returns a {from,
	// to} object by default. Side can be passed to get a specific side
	// -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the
	// Pos objects returned contain a line object, rather than a line
	// number (used to prevent looking up the same line twice).
	TextMarker.prototype.find=function(side,lineObj){if(side==null&&this.type=="bookmark")side=1;var from,to;for(var i=0;i<this.lines.length;++i){var line=this.lines[i];var span=getMarkedSpanFor(line.markedSpans,this);if(span.from!=null){from=Pos(lineObj?line:lineNo(line),span.from);if(side==-1)return from}if(span.to!=null){to=Pos(lineObj?line:lineNo(line),span.to);if(side==1)return to}}return from&&{from:from,to:to}}; // Signals that the marker's widget changed, and surrounding layout
	// should be recomputed.
	TextMarker.prototype.changed=function(){var pos=this.find(-1,true),widget=this,cm=this.doc.cm;if(!pos||!cm)return;runInOp(cm,function(){var line=pos.line,lineN=lineNo(pos.line);var view=findViewForLine(cm,lineN);if(view){clearLineMeasurementCacheFor(view);cm.curOp.selectionChanged=cm.curOp.forceUpdate=true}cm.curOp.updateMaxLine=true;if(!lineIsHidden(widget.doc,line)&&widget.height!=null){var oldHeight=widget.height;widget.height=null;var dHeight=widgetHeight(widget)-oldHeight;if(dHeight)updateLineHeight(line,line.height+dHeight)}})};TextMarker.prototype.attachLine=function(line){if(!this.lines.length&&this.doc.cm){var op=this.doc.cm.curOp;if(!op.maybeHiddenMarkers||indexOf(op.maybeHiddenMarkers,this)==-1)(op.maybeUnhiddenMarkers||(op.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(line)};TextMarker.prototype.detachLine=function(line){this.lines.splice(indexOf(this.lines,line),1);if(!this.lines.length&&this.doc.cm){var op=this.doc.cm.curOp;(op.maybeHiddenMarkers||(op.maybeHiddenMarkers=[])).push(this)}}; // Collapsed markers have unique ids, in order to be able to order
	// them, which is needed for uniquely determining an outer marker
	// when they overlap (they may nest, but not partially overlap).
	var nextMarkerId=0; // Create a marker, wire it up to the right lines, and
	function markText(doc,from,to,options,type){ // Shared markers (across linked documents) are handled separately
	// (markTextShared will call out to this again, once per
	// document).
	if(options&&options.shared)return markTextShared(doc,from,to,options,type); // Ensure we are in an operation.
	if(doc.cm&&!doc.cm.curOp)return operation(doc.cm,markText)(doc,from,to,options,type);var marker=new TextMarker(doc,type),diff=cmp(from,to);if(options)copyObj(options,marker,false); // Don't connect empty markers unless clearWhenEmpty is false
	if(diff>0||diff==0&&marker.clearWhenEmpty!==false)return marker;if(marker.replacedWith){ // Showing up as a widget implies collapsed (widget replaces text)
	marker.collapsed=true;marker.widgetNode=elt("span",[marker.replacedWith],"CodeMirror-widget");if(!options.handleMouseEvents)marker.widgetNode.setAttribute("cm-ignore-events","true");if(options.insertLeft)marker.widgetNode.insertLeft=true}if(marker.collapsed){if(conflictingCollapsedRange(doc,from.line,from,to,marker)||from.line!=to.line&&conflictingCollapsedRange(doc,to.line,from,to,marker))throw new Error("Inserting collapsed marker partially overlapping an existing one");sawCollapsedSpans=true}if(marker.addToHistory)addChangeToHistory(doc,{from:from,to:to,origin:"markText"},doc.sel,NaN);var curLine=from.line,cm=doc.cm,updateMaxLine;doc.iter(curLine,to.line+1,function(line){if(cm&&marker.collapsed&&!cm.options.lineWrapping&&visualLine(line)==cm.display.maxLine)updateMaxLine=true;if(marker.collapsed&&curLine!=from.line)updateLineHeight(line,0);addMarkedSpan(line,new MarkedSpan(marker,curLine==from.line?from.ch:null,curLine==to.line?to.ch:null));++curLine}); // lineIsHidden depends on the presence of the spans, so needs a second pass
	if(marker.collapsed)doc.iter(from.line,to.line+1,function(line){if(lineIsHidden(doc,line))updateLineHeight(line,0)});if(marker.clearOnEnter)on(marker,"beforeCursorEnter",function(){marker.clear()});if(marker.readOnly){sawReadOnlySpans=true;if(doc.history.done.length||doc.history.undone.length)doc.clearHistory()}if(marker.collapsed){marker.id=++nextMarkerId;marker.atomic=true}if(cm){ // Sync editor state
	if(updateMaxLine)cm.curOp.updateMaxLine=true;if(marker.collapsed)regChange(cm,from.line,to.line+1);else if(marker.className||marker.title||marker.startStyle||marker.endStyle||marker.css)for(var i=from.line;i<=to.line;i++)regLineChange(cm,i,"text");if(marker.atomic)reCheckSelection(cm.doc);signalLater(cm,"markerAdded",cm,marker)}return marker} // SHARED TEXTMARKERS
	// A shared marker spans multiple linked documents. It is
	// implemented as a meta-marker-object controlling multiple normal
	// markers.
	var SharedTextMarker=CodeMirror.SharedTextMarker=function(markers,primary){this.markers=markers;this.primary=primary;for(var i=0;i<markers.length;++i)markers[i].parent=this};eventMixin(SharedTextMarker);SharedTextMarker.prototype.clear=function(){if(this.explicitlyCleared)return;this.explicitlyCleared=true;for(var i=0;i<this.markers.length;++i)this.markers[i].clear();signalLater(this,"clear")};SharedTextMarker.prototype.find=function(side,lineObj){return this.primary.find(side,lineObj)};function markTextShared(doc,from,to,options,type){options=copyObj(options);options.shared=false;var markers=[markText(doc,from,to,options,type)],primary=markers[0];var widget=options.widgetNode;linkedDocs(doc,function(doc){if(widget)options.widgetNode=widget.cloneNode(true);markers.push(markText(doc,clipPos(doc,from),clipPos(doc,to),options,type));for(var i=0;i<doc.linked.length;++i)if(doc.linked[i].isParent)return;primary=lst(markers)});return new SharedTextMarker(markers,primary)}function findSharedMarkers(doc){return doc.findMarks(Pos(doc.first,0),doc.clipPos(Pos(doc.lastLine())),function(m){return m.parent})}function copySharedMarkers(doc,markers){for(var i=0;i<markers.length;i++){var marker=markers[i],pos=marker.find();var mFrom=doc.clipPos(pos.from),mTo=doc.clipPos(pos.to);if(cmp(mFrom,mTo)){var subMark=markText(doc,mFrom,mTo,marker.primary,marker.primary.type);marker.markers.push(subMark);subMark.parent=marker}}}function detachSharedMarkers(markers){for(var i=0;i<markers.length;i++){var marker=markers[i],linked=[marker.primary.doc];;linkedDocs(marker.primary.doc,function(d){linked.push(d)});for(var j=0;j<marker.markers.length;j++){var subMarker=marker.markers[j];if(indexOf(linked,subMarker.doc)==-1){subMarker.parent=null;marker.markers.splice(j--,1)}}}} // TEXTMARKER SPANS
	function MarkedSpan(marker,from,to){this.marker=marker;this.from=from;this.to=to} // Search an array of spans for a span matching the given marker.
	function getMarkedSpanFor(spans,marker){if(spans)for(var i=0;i<spans.length;++i){var span=spans[i];if(span.marker==marker)return span}} // Remove a span from an array, returning undefined if no spans are
	// left (we don't store arrays for lines without spans).
	function removeMarkedSpan(spans,span){for(var r,i=0;i<spans.length;++i)if(spans[i]!=span)(r||(r=[])).push(spans[i]);return r} // Add a span to a line.
	function addMarkedSpan(line,span){line.markedSpans=line.markedSpans?line.markedSpans.concat([span]):[span];span.marker.attachLine(line)} // Used for the algorithm that adjusts markers for a change in the
	// document. These functions cut an array of spans at a given
	// character position, returning an array of remaining chunks (or
	// undefined if nothing remains).
	function markedSpansBefore(old,startCh,isInsert){if(old)for(var i=0,nw;i<old.length;++i){var span=old[i],marker=span.marker;var startsBefore=span.from==null||(marker.inclusiveLeft?span.from<=startCh:span.from<startCh);if(startsBefore||span.from==startCh&&marker.type=="bookmark"&&(!isInsert||!span.marker.insertLeft)){var endsAfter=span.to==null||(marker.inclusiveRight?span.to>=startCh:span.to>startCh);(nw||(nw=[])).push(new MarkedSpan(marker,span.from,endsAfter?null:span.to))}}return nw}function markedSpansAfter(old,endCh,isInsert){if(old)for(var i=0,nw;i<old.length;++i){var span=old[i],marker=span.marker;var endsAfter=span.to==null||(marker.inclusiveRight?span.to>=endCh:span.to>endCh);if(endsAfter||span.from==endCh&&marker.type=="bookmark"&&(!isInsert||span.marker.insertLeft)){var startsBefore=span.from==null||(marker.inclusiveLeft?span.from<=endCh:span.from<endCh);(nw||(nw=[])).push(new MarkedSpan(marker,startsBefore?null:span.from-endCh,span.to==null?null:span.to-endCh))}}return nw} // Given a change object, compute the new set of marker spans that
	// cover the line in which the change took place. Removes spans
	// entirely within the change, reconnects spans belonging to the
	// same marker that appear on both sides of the change, and cuts off
	// spans partially within the change. Returns an array of span
	// arrays with one element for each line in (after) the change.
	function stretchSpansOverChange(doc,change){if(change.full)return null;var oldFirst=isLine(doc,change.from.line)&&getLine(doc,change.from.line).markedSpans;var oldLast=isLine(doc,change.to.line)&&getLine(doc,change.to.line).markedSpans;if(!oldFirst&&!oldLast)return null;var startCh=change.from.ch,endCh=change.to.ch,isInsert=cmp(change.from,change.to)==0; // Get the spans that 'stick out' on both sides
	var first=markedSpansBefore(oldFirst,startCh,isInsert);var last=markedSpansAfter(oldLast,endCh,isInsert); // Next, merge those two ends
	var sameLine=change.text.length==1,offset=lst(change.text).length+(sameLine?startCh:0);if(first){ // Fix up .to properties of first
	for(var i=0;i<first.length;++i){var span=first[i];if(span.to==null){var found=getMarkedSpanFor(last,span.marker);if(!found)span.to=startCh;else if(sameLine)span.to=found.to==null?null:found.to+offset}}}if(last){ // Fix up .from in last (or move them into first in case of sameLine)
	for(var i=0;i<last.length;++i){var span=last[i];if(span.to!=null)span.to+=offset;if(span.from==null){var found=getMarkedSpanFor(first,span.marker);if(!found){span.from=offset;if(sameLine)(first||(first=[])).push(span)}}else {span.from+=offset;if(sameLine)(first||(first=[])).push(span)}}} // Make sure we didn't create any zero-length spans
	if(first)first=clearEmptySpans(first);if(last&&last!=first)last=clearEmptySpans(last);var newMarkers=[first];if(!sameLine){ // Fill gap with whole-line-spans
	var gap=change.text.length-2,gapMarkers;if(gap>0&&first)for(var i=0;i<first.length;++i)if(first[i].to==null)(gapMarkers||(gapMarkers=[])).push(new MarkedSpan(first[i].marker,null,null));for(var i=0;i<gap;++i)newMarkers.push(gapMarkers);newMarkers.push(last)}return newMarkers} // Remove spans that are empty and don't have a clearWhenEmpty
	// option of false.
	function clearEmptySpans(spans){for(var i=0;i<spans.length;++i){var span=spans[i];if(span.from!=null&&span.from==span.to&&span.marker.clearWhenEmpty!==false)spans.splice(i--,1)}if(!spans.length)return null;return spans} // Used for un/re-doing changes from the history. Combines the
	// result of computing the existing spans with the set of spans that
	// existed in the history (so that deleting around a span and then
	// undoing brings back the span).
	function mergeOldSpans(doc,change){var old=getOldSpans(doc,change);var stretched=stretchSpansOverChange(doc,change);if(!old)return stretched;if(!stretched)return old;for(var i=0;i<old.length;++i){var oldCur=old[i],stretchCur=stretched[i];if(oldCur&&stretchCur){spans: for(var j=0;j<stretchCur.length;++j){var span=stretchCur[j];for(var k=0;k<oldCur.length;++k)if(oldCur[k].marker==span.marker)continue spans;oldCur.push(span)}}else if(stretchCur){old[i]=stretchCur}}return old} // Used to 'clip' out readOnly ranges when making a change.
	function removeReadOnlyRanges(doc,from,to){var markers=null;doc.iter(from.line,to.line+1,function(line){if(line.markedSpans)for(var i=0;i<line.markedSpans.length;++i){var mark=line.markedSpans[i].marker;if(mark.readOnly&&(!markers||indexOf(markers,mark)==-1))(markers||(markers=[])).push(mark)}});if(!markers)return null;var parts=[{from:from,to:to}];for(var i=0;i<markers.length;++i){var mk=markers[i],m=mk.find(0);for(var j=0;j<parts.length;++j){var p=parts[j];if(cmp(p.to,m.from)<0||cmp(p.from,m.to)>0)continue;var newParts=[j,1],dfrom=cmp(p.from,m.from),dto=cmp(p.to,m.to);if(dfrom<0||!mk.inclusiveLeft&&!dfrom)newParts.push({from:p.from,to:m.from});if(dto>0||!mk.inclusiveRight&&!dto)newParts.push({from:m.to,to:p.to});parts.splice.apply(parts,newParts);j+=newParts.length-1}}return parts} // Connect or disconnect spans from a line.
	function detachMarkedSpans(line){var spans=line.markedSpans;if(!spans)return;for(var i=0;i<spans.length;++i)spans[i].marker.detachLine(line);line.markedSpans=null}function attachMarkedSpans(line,spans){if(!spans)return;for(var i=0;i<spans.length;++i)spans[i].marker.attachLine(line);line.markedSpans=spans} // Helpers used when computing which overlapping collapsed span
	// counts as the larger one.
	function extraLeft(marker){return marker.inclusiveLeft?-1:0}function extraRight(marker){return marker.inclusiveRight?1:0} // Returns a number indicating which of two overlapping collapsed
	// spans is larger (and thus includes the other). Falls back to
	// comparing ids when the spans cover exactly the same range.
	function compareCollapsedMarkers(a,b){var lenDiff=a.lines.length-b.lines.length;if(lenDiff!=0)return lenDiff;var aPos=a.find(),bPos=b.find();var fromCmp=cmp(aPos.from,bPos.from)||extraLeft(a)-extraLeft(b);if(fromCmp)return -fromCmp;var toCmp=cmp(aPos.to,bPos.to)||extraRight(a)-extraRight(b);if(toCmp)return toCmp;return b.id-a.id} // Find out whether a line ends or starts in a collapsed span. If
	// so, return the marker for that span.
	function collapsedSpanAtSide(line,start){var sps=sawCollapsedSpans&&line.markedSpans,found;if(sps)for(var sp,i=0;i<sps.length;++i){sp=sps[i];if(sp.marker.collapsed&&(start?sp.from:sp.to)==null&&(!found||compareCollapsedMarkers(found,sp.marker)<0))found=sp.marker}return found}function collapsedSpanAtStart(line){return collapsedSpanAtSide(line,true)}function collapsedSpanAtEnd(line){return collapsedSpanAtSide(line,false)} // Test whether there exists a collapsed span that partially
	// overlaps (covers the start or end, but not both) of a new span.
	// Such overlap is not allowed.
	function conflictingCollapsedRange(doc,lineNo,from,to,marker){var line=getLine(doc,lineNo);var sps=sawCollapsedSpans&&line.markedSpans;if(sps)for(var i=0;i<sps.length;++i){var sp=sps[i];if(!sp.marker.collapsed)continue;var found=sp.marker.find(0);var fromCmp=cmp(found.from,from)||extraLeft(sp.marker)-extraLeft(marker);var toCmp=cmp(found.to,to)||extraRight(sp.marker)-extraRight(marker);if(fromCmp>=0&&toCmp<=0||fromCmp<=0&&toCmp>=0)continue;if(fromCmp<=0&&(cmp(found.to,from)>0||sp.marker.inclusiveRight&&marker.inclusiveLeft)||fromCmp>=0&&(cmp(found.from,to)<0||sp.marker.inclusiveLeft&&marker.inclusiveRight))return true}} // A visual line is a line as drawn on the screen. Folding, for
	// example, can cause multiple logical lines to appear on the same
	// visual line. This finds the start of the visual line that the
	// given line is part of (usually that is the line itself).
	function visualLine(line){var merged;while(merged=collapsedSpanAtStart(line))line=merged.find(-1,true).line;return line} // Returns an array of logical lines that continue the visual line
	// started by the argument, or undefined if there are no such lines.
	function visualLineContinued(line){var merged,lines;while(merged=collapsedSpanAtEnd(line)){line=merged.find(1,true).line;(lines||(lines=[])).push(line)}return lines} // Get the line number of the start of the visual line that the
	// given line number is part of.
	function visualLineNo(doc,lineN){var line=getLine(doc,lineN),vis=visualLine(line);if(line==vis)return lineN;return lineNo(vis)} // Get the line number of the start of the next visual line after
	// the given line.
	function visualLineEndNo(doc,lineN){if(lineN>doc.lastLine())return lineN;var line=getLine(doc,lineN),merged;if(!lineIsHidden(doc,line))return lineN;while(merged=collapsedSpanAtEnd(line))line=merged.find(1,true).line;return lineNo(line)+1} // Compute whether a line is hidden. Lines count as hidden when they
	// are part of a visual line that starts with another line, or when
	// they are entirely covered by collapsed, non-widget span.
	function lineIsHidden(doc,line){var sps=sawCollapsedSpans&&line.markedSpans;if(sps)for(var sp,i=0;i<sps.length;++i){sp=sps[i];if(!sp.marker.collapsed)continue;if(sp.from==null)return true;if(sp.marker.widgetNode)continue;if(sp.from==0&&sp.marker.inclusiveLeft&&lineIsHiddenInner(doc,line,sp))return true}}function lineIsHiddenInner(doc,line,span){if(span.to==null){var end=span.marker.find(1,true);return lineIsHiddenInner(doc,end.line,getMarkedSpanFor(end.line.markedSpans,span.marker))}if(span.marker.inclusiveRight&&span.to==line.text.length)return true;for(var sp,i=0;i<line.markedSpans.length;++i){sp=line.markedSpans[i];if(sp.marker.collapsed&&!sp.marker.widgetNode&&sp.from==span.to&&(sp.to==null||sp.to!=span.from)&&(sp.marker.inclusiveLeft||span.marker.inclusiveRight)&&lineIsHiddenInner(doc,line,sp))return true}} // LINE WIDGETS
	// Line widgets are block elements displayed above or below a line.
	var LineWidget=CodeMirror.LineWidget=function(doc,node,options){if(options)for(var opt in options)if(options.hasOwnProperty(opt))this[opt]=options[opt];this.doc=doc;this.node=node};eventMixin(LineWidget);function adjustScrollWhenAboveVisible(cm,line,diff){if(heightAtLine(line)<(cm.curOp&&cm.curOp.scrollTop||cm.doc.scrollTop))addToScrollPos(cm,null,diff)}LineWidget.prototype.clear=function(){var cm=this.doc.cm,ws=this.line.widgets,line=this.line,no=lineNo(line);if(no==null||!ws)return;for(var i=0;i<ws.length;++i)if(ws[i]==this)ws.splice(i--,1);if(!ws.length)line.widgets=null;var height=widgetHeight(this);updateLineHeight(line,Math.max(0,line.height-height));if(cm)runInOp(cm,function(){adjustScrollWhenAboveVisible(cm,line,-height);regLineChange(cm,no,"widget")})};LineWidget.prototype.changed=function(){var oldH=this.height,cm=this.doc.cm,line=this.line;this.height=null;var diff=widgetHeight(this)-oldH;if(!diff)return;updateLineHeight(line,line.height+diff);if(cm)runInOp(cm,function(){cm.curOp.forceUpdate=true;adjustScrollWhenAboveVisible(cm,line,diff)})};function widgetHeight(widget){if(widget.height!=null)return widget.height;var cm=widget.doc.cm;if(!cm)return 0;if(!contains(document.body,widget.node)){var parentStyle="position: relative;";if(widget.coverGutter)parentStyle+="margin-left: -"+cm.display.gutters.offsetWidth+"px;";if(widget.noHScroll)parentStyle+="width: "+cm.display.wrapper.clientWidth+"px;";removeChildrenAndAdd(cm.display.measure,elt("div",[widget.node],null,parentStyle))}return widget.height=widget.node.offsetHeight}function addLineWidget(doc,handle,node,options){var widget=new LineWidget(doc,node,options);var cm=doc.cm;if(cm&&widget.noHScroll)cm.display.alignWidgets=true;changeLine(doc,handle,"widget",function(line){var widgets=line.widgets||(line.widgets=[]);if(widget.insertAt==null)widgets.push(widget);else widgets.splice(Math.min(widgets.length-1,Math.max(0,widget.insertAt)),0,widget);widget.line=line;if(cm&&!lineIsHidden(doc,line)){var aboveVisible=heightAtLine(line)<doc.scrollTop;updateLineHeight(line,line.height+widgetHeight(widget));if(aboveVisible)addToScrollPos(cm,null,widget.height);cm.curOp.forceUpdate=true}return true});return widget} // LINE DATA STRUCTURE
	// Line objects. These hold state related to a line, including
	// highlighting info (the styles array).
	var Line=CodeMirror.Line=function(text,markedSpans,estimateHeight){this.text=text;attachMarkedSpans(this,markedSpans);this.height=estimateHeight?estimateHeight(this):1};eventMixin(Line);Line.prototype.lineNo=function(){return lineNo(this)}; // Change the content (text, markers) of a line. Automatically
	// invalidates cached information and tries to re-estimate the
	// line's height.
	function updateLine(line,text,markedSpans,estimateHeight){line.text=text;if(line.stateAfter)line.stateAfter=null;if(line.styles)line.styles=null;if(line.order!=null)line.order=null;detachMarkedSpans(line);attachMarkedSpans(line,markedSpans);var estHeight=estimateHeight?estimateHeight(line):1;if(estHeight!=line.height)updateLineHeight(line,estHeight)} // Detach a line from the document tree and its markers.
	function cleanUpLine(line){line.parent=null;detachMarkedSpans(line)}function extractLineClasses(type,output){if(type)for(;;){var lineClass=type.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!lineClass)break;type=type.slice(0,lineClass.index)+type.slice(lineClass.index+lineClass[0].length);var prop=lineClass[1]?"bgClass":"textClass";if(output[prop]==null)output[prop]=lineClass[2];else if(!new RegExp("(?:^|\s)"+lineClass[2]+"(?:$|\s)").test(output[prop]))output[prop]+=" "+lineClass[2]}return type}function callBlankLine(mode,state){if(mode.blankLine)return mode.blankLine(state);if(!mode.innerMode)return;var inner=CodeMirror.innerMode(mode,state);if(inner.mode.blankLine)return inner.mode.blankLine(inner.state)}function readToken(mode,stream,state,inner){for(var i=0;i<10;i++){if(inner)inner[0]=CodeMirror.innerMode(mode,state).mode;var style=mode.token(stream,state);if(stream.pos>stream.start)return style}throw new Error("Mode "+mode.name+" failed to advance stream.")} // Utility for getTokenAt and getLineTokens
	function takeToken(cm,pos,precise,asArray){function getObj(copy){return {start:stream.start,end:stream.pos,string:stream.current(),type:style||null,state:copy?copyState(doc.mode,state):state}}var doc=cm.doc,mode=doc.mode,style;pos=clipPos(doc,pos);var line=getLine(doc,pos.line),state=getStateBefore(cm,pos.line,precise);var stream=new StringStream(line.text,cm.options.tabSize),tokens;if(asArray)tokens=[];while((asArray||stream.pos<pos.ch)&&!stream.eol()){stream.start=stream.pos;style=readToken(mode,stream,state);if(asArray)tokens.push(getObj(true))}return asArray?tokens:getObj()} // Run the given mode's parser over a line, calling f for each token.
	function runMode(cm,text,mode,state,f,lineClasses,forceToEnd){var flattenSpans=mode.flattenSpans;if(flattenSpans==null)flattenSpans=cm.options.flattenSpans;var curStart=0,curStyle=null;var stream=new StringStream(text,cm.options.tabSize),style;var inner=cm.options.addModeClass&&[null];if(text=="")extractLineClasses(callBlankLine(mode,state),lineClasses);while(!stream.eol()){if(stream.pos>cm.options.maxHighlightLength){flattenSpans=false;if(forceToEnd)processLine(cm,text,state,stream.pos);stream.pos=text.length;style=null}else {style=extractLineClasses(readToken(mode,stream,state,inner),lineClasses)}if(inner){var mName=inner[0].name;if(mName)style="m-"+(style?mName+" "+style:mName)}if(!flattenSpans||curStyle!=style){while(curStart<stream.start){curStart=Math.min(stream.start,curStart+50000);f(curStart,curStyle)}curStyle=style}stream.start=stream.pos}while(curStart<stream.pos){ // Webkit seems to refuse to render text nodes longer than 57444 characters
	var pos=Math.min(stream.pos,curStart+50000);f(pos,curStyle);curStart=pos}} // Compute a style array (an array starting with a mode generation
	// -- for invalidation -- followed by pairs of end positions and
	// style strings), which is used to highlight the tokens on the
	// line.
	function highlightLine(cm,line,state,forceToEnd){ // A styles array always starts with a number identifying the
	// mode/overlays that it is based on (for easy invalidation).
	var st=[cm.state.modeGen],lineClasses={}; // Compute the base array of styles
	runMode(cm,line.text,cm.doc.mode,state,function(end,style){st.push(end,style)},lineClasses,forceToEnd); // Run overlays, adjust style array.
	for(var o=0;o<cm.state.overlays.length;++o){var overlay=cm.state.overlays[o],i=1,at=0;runMode(cm,line.text,overlay.mode,true,function(end,style){var start=i; // Ensure there's a token end at the current position, and that i points at it
	while(at<end){var i_end=st[i];if(i_end>end)st.splice(i,1,end,st[i+1],i_end);i+=2;at=Math.min(end,i_end)}if(!style)return;if(overlay.opaque){st.splice(start,i-start,end,"cm-overlay "+style);i=start+2}else {for(;start<i;start+=2){var cur=st[start+1];st[start+1]=(cur?cur+" ":"")+"cm-overlay "+style}}},lineClasses)}return {styles:st,classes:lineClasses.bgClass||lineClasses.textClass?lineClasses:null}}function getLineStyles(cm,line,updateFrontier){if(!line.styles||line.styles[0]!=cm.state.modeGen){var state=getStateBefore(cm,lineNo(line));var result=highlightLine(cm,line,line.text.length>cm.options.maxHighlightLength?copyState(cm.doc.mode,state):state);line.stateAfter=state;line.styles=result.styles;if(result.classes)line.styleClasses=result.classes;else if(line.styleClasses)line.styleClasses=null;if(updateFrontier===cm.doc.frontier)cm.doc.frontier++}return line.styles} // Lightweight form of highlight -- proceed over this line and
	// update state, but don't save a style array. Used for lines that
	// aren't currently visible.
	function processLine(cm,text,state,startAt){var mode=cm.doc.mode;var stream=new StringStream(text,cm.options.tabSize);stream.start=stream.pos=startAt||0;if(text=="")callBlankLine(mode,state);while(!stream.eol()){readToken(mode,stream,state);stream.start=stream.pos}} // Convert a style as returned by a mode (either null, or a string
	// containing one or more styles) to a CSS style. This is cached,
	// and also looks for line-wide styles.
	var styleToClassCache={},styleToClassCacheWithMode={};function interpretTokenStyle(style,options){if(!style||/^\s*$/.test(style))return null;var cache=options.addModeClass?styleToClassCacheWithMode:styleToClassCache;return cache[style]||(cache[style]=style.replace(/\S+/g,"cm-$&"))} // Render the DOM representation of the text of a line. Also builds
	// up a 'line map', which points at the DOM nodes that represent
	// specific stretches of text, and is used by the measuring code.
	// The returned object contains the DOM node, this map, and
	// information about line-wide styles that were set by the mode.
	function buildLineContent(cm,lineView){ // The padding-right forces the element to have a 'border', which
	// is needed on Webkit to be able to get line-level bounding
	// rectangles for it (in measureChar).
	var content=elt("span",null,null,webkit?"padding-right: .1px":null);var builder={pre:elt("pre",[content],"CodeMirror-line"),content:content,col:0,pos:0,cm:cm,splitSpaces:(ie||webkit)&&cm.getOption("lineWrapping")};lineView.measure={}; // Iterate over the logical lines that make up this visual line.
	for(var i=0;i<=(lineView.rest?lineView.rest.length:0);i++){var line=i?lineView.rest[i-1]:lineView.line,order;builder.pos=0;builder.addToken=buildToken; // Optionally wire in some hacks into the token-rendering
	// algorithm, to deal with browser quirks.
	if(hasBadBidiRects(cm.display.measure)&&(order=getOrder(line)))builder.addToken=buildTokenBadBidi(builder.addToken,order);builder.map=[];var allowFrontierUpdate=lineView!=cm.display.externalMeasured&&lineNo(line);insertLineContent(line,builder,getLineStyles(cm,line,allowFrontierUpdate));if(line.styleClasses){if(line.styleClasses.bgClass)builder.bgClass=joinClasses(line.styleClasses.bgClass,builder.bgClass||"");if(line.styleClasses.textClass)builder.textClass=joinClasses(line.styleClasses.textClass,builder.textClass||"")} // Ensure at least a single node is present, for measuring.
	if(builder.map.length==0)builder.map.push(0,0,builder.content.appendChild(zeroWidthElement(cm.display.measure))); // Store the map and a cache object for the current logical line
	if(i==0){lineView.measure.map=builder.map;lineView.measure.cache={}}else {(lineView.measure.maps||(lineView.measure.maps=[])).push(builder.map);(lineView.measure.caches||(lineView.measure.caches=[])).push({})}} // See issue #2901
	if(webkit&&/\bcm-tab\b/.test(builder.content.lastChild.className))builder.content.className="cm-tab-wrap-hack";signal(cm,"renderLine",cm,lineView.line,builder.pre);if(builder.pre.className)builder.textClass=joinClasses(builder.pre.className,builder.textClass||"");return builder}function defaultSpecialCharPlaceholder(ch){var token=elt("span","\u2022","cm-invalidchar");token.title="\\u"+ch.charCodeAt(0).toString(16);token.setAttribute("aria-label",token.title);return token} // Build up the DOM representation for a single token, and add it to
	// the line map. Takes care to render special characters separately.
	function buildToken(builder,text,style,startStyle,endStyle,title,css){if(!text)return;var displayText=builder.splitSpaces?text.replace(/ {3,}/g,splitSpaces):text;var special=builder.cm.state.specialChars,mustWrap=false;if(!special.test(text)){builder.col+=text.length;var content=document.createTextNode(displayText);builder.map.push(builder.pos,builder.pos+text.length,content);if(ie&&ie_version<9)mustWrap=true;builder.pos+=text.length}else {var content=document.createDocumentFragment(),pos=0;while(true){special.lastIndex=pos;var m=special.exec(text);var skipped=m?m.index-pos:text.length-pos;if(skipped){var txt=document.createTextNode(displayText.slice(pos,pos+skipped));if(ie&&ie_version<9)content.appendChild(elt("span",[txt]));else content.appendChild(txt);builder.map.push(builder.pos,builder.pos+skipped,txt);builder.col+=skipped;builder.pos+=skipped}if(!m)break;pos+=skipped+1;if(m[0]=="\t"){var tabSize=builder.cm.options.tabSize,tabWidth=tabSize-builder.col%tabSize;var txt=content.appendChild(elt("span",spaceStr(tabWidth),"cm-tab"));txt.setAttribute("role","presentation");txt.setAttribute("cm-text","\t");builder.col+=tabWidth}else if(m[0]=="\r"||m[0]=="\n"){var txt=content.appendChild(elt("span",m[0]=="\r"?"\u240d":"\u2424","cm-invalidchar"));txt.setAttribute("cm-text",m[0]);builder.col+=1}else {var txt=builder.cm.options.specialCharPlaceholder(m[0]);txt.setAttribute("cm-text",m[0]);if(ie&&ie_version<9)content.appendChild(elt("span",[txt]));else content.appendChild(txt);builder.col+=1}builder.map.push(builder.pos,builder.pos+1,txt);builder.pos++}}if(style||startStyle||endStyle||mustWrap||css){var fullStyle=style||"";if(startStyle)fullStyle+=startStyle;if(endStyle)fullStyle+=endStyle;var token=elt("span",[content],fullStyle,css);if(title)token.title=title;return builder.content.appendChild(token)}builder.content.appendChild(content)}function splitSpaces(old){var out=" ";for(var i=0;i<old.length-2;++i)out+=i%2?" ":"\u00a0";out+=" ";return out} // Work around nonsense dimensions being reported for stretches of
	// right-to-left text.
	function buildTokenBadBidi(inner,order){return function(builder,text,style,startStyle,endStyle,title,css){style=style?style+" cm-force-border":"cm-force-border";var start=builder.pos,end=start+text.length;for(;;){ // Find the part that overlaps with the start of this text
	for(var i=0;i<order.length;i++){var part=order[i];if(part.to>start&&part.from<=start)break}if(part.to>=end)return inner(builder,text,style,startStyle,endStyle,title,css);inner(builder,text.slice(0,part.to-start),style,startStyle,null,title,css);startStyle=null;text=text.slice(part.to-start);start=part.to}}}function buildCollapsedSpan(builder,size,marker,ignoreWidget){var widget=!ignoreWidget&&marker.widgetNode;if(widget)builder.map.push(builder.pos,builder.pos+size,widget);if(!ignoreWidget&&builder.cm.display.input.needsContentAttribute){if(!widget)widget=builder.content.appendChild(document.createElement("span"));widget.setAttribute("cm-marker",marker.id)}if(widget){builder.cm.display.input.setUneditable(widget);builder.content.appendChild(widget)}builder.pos+=size} // Outputs a number of spans to make up a line, taking highlighting
	// and marked text into account.
	function insertLineContent(line,builder,styles){var spans=line.markedSpans,allText=line.text,at=0;if(!spans){for(var i=1;i<styles.length;i+=2)builder.addToken(builder,allText.slice(at,at=styles[i]),interpretTokenStyle(styles[i+1],builder.cm.options));return}var len=allText.length,pos=0,i=1,text="",style,css;var nextChange=0,spanStyle,spanEndStyle,spanStartStyle,title,collapsed;for(;;){if(nextChange==pos){ // Update current marker set
	spanStyle=spanEndStyle=spanStartStyle=title=css="";collapsed=null;nextChange=Infinity;var foundBookmarks=[];for(var j=0;j<spans.length;++j){var sp=spans[j],m=sp.marker;if(m.type=="bookmark"&&sp.from==pos&&m.widgetNode){foundBookmarks.push(m)}else if(sp.from<=pos&&(sp.to==null||sp.to>pos||m.collapsed&&sp.to==pos&&sp.from==pos)){if(sp.to!=null&&sp.to!=pos&&nextChange>sp.to){nextChange=sp.to;spanEndStyle=""}if(m.className)spanStyle+=" "+m.className;if(m.css)css=(css?css+";":"")+m.css;if(m.startStyle&&sp.from==pos)spanStartStyle+=" "+m.startStyle;if(m.endStyle&&sp.to==nextChange)spanEndStyle+=" "+m.endStyle;if(m.title&&!title)title=m.title;if(m.collapsed&&(!collapsed||compareCollapsedMarkers(collapsed.marker,m)<0))collapsed=sp}else if(sp.from>pos&&nextChange>sp.from){nextChange=sp.from}}if(collapsed&&(collapsed.from||0)==pos){buildCollapsedSpan(builder,(collapsed.to==null?len+1:collapsed.to)-pos,collapsed.marker,collapsed.from==null);if(collapsed.to==null)return;if(collapsed.to==pos)collapsed=false}if(!collapsed&&foundBookmarks.length)for(var j=0;j<foundBookmarks.length;++j)buildCollapsedSpan(builder,0,foundBookmarks[j])}if(pos>=len)break;var upto=Math.min(len,nextChange);while(true){if(text){var end=pos+text.length;if(!collapsed){var tokenText=end>upto?text.slice(0,upto-pos):text;builder.addToken(builder,tokenText,style?style+spanStyle:spanStyle,spanStartStyle,pos+tokenText.length==nextChange?spanEndStyle:"",title,css)}if(end>=upto){text=text.slice(upto-pos);pos=upto;break}pos=end;spanStartStyle=""}text=allText.slice(at,at=styles[i++]);style=interpretTokenStyle(styles[i++],builder.cm.options)}}} // DOCUMENT DATA STRUCTURE
	// By default, updates that start and end at the beginning of a line
	// are treated specially, in order to make the association of line
	// widgets and marker elements with the text behave more intuitive.
	function isWholeLineUpdate(doc,change){return change.from.ch==0&&change.to.ch==0&&lst(change.text)==""&&(!doc.cm||doc.cm.options.wholeLineUpdateBefore)} // Perform a change on the document data structure.
	function updateDoc(doc,change,markedSpans,estimateHeight){function spansFor(n){return markedSpans?markedSpans[n]:null}function update(line,text,spans){updateLine(line,text,spans,estimateHeight);signalLater(line,"change",line,change)}function linesFor(start,end){for(var i=start,result=[];i<end;++i)result.push(new Line(text[i],spansFor(i),estimateHeight));return result}var from=change.from,to=change.to,text=change.text;var firstLine=getLine(doc,from.line),lastLine=getLine(doc,to.line);var lastText=lst(text),lastSpans=spansFor(text.length-1),nlines=to.line-from.line; // Adjust the line structure
	if(change.full){doc.insert(0,linesFor(0,text.length));doc.remove(text.length,doc.size-text.length)}else if(isWholeLineUpdate(doc,change)){ // This is a whole-line replace. Treated specially to make
	// sure line objects move the way they are supposed to.
	var added=linesFor(0,text.length-1);update(lastLine,lastLine.text,lastSpans);if(nlines)doc.remove(from.line,nlines);if(added.length)doc.insert(from.line,added)}else if(firstLine==lastLine){if(text.length==1){update(firstLine,firstLine.text.slice(0,from.ch)+lastText+firstLine.text.slice(to.ch),lastSpans)}else {var added=linesFor(1,text.length-1);added.push(new Line(lastText+firstLine.text.slice(to.ch),lastSpans,estimateHeight));update(firstLine,firstLine.text.slice(0,from.ch)+text[0],spansFor(0));doc.insert(from.line+1,added)}}else if(text.length==1){update(firstLine,firstLine.text.slice(0,from.ch)+text[0]+lastLine.text.slice(to.ch),spansFor(0));doc.remove(from.line+1,nlines)}else {update(firstLine,firstLine.text.slice(0,from.ch)+text[0],spansFor(0));update(lastLine,lastText+lastLine.text.slice(to.ch),lastSpans);var added=linesFor(1,text.length-1);if(nlines>1)doc.remove(from.line+1,nlines-1);doc.insert(from.line+1,added)}signalLater(doc,"change",doc,change)} // The document is represented as a BTree consisting of leaves, with
	// chunk of lines in them, and branches, with up to ten leaves or
	// other branch nodes below them. The top node is always a branch
	// node, and is the document object itself (meaning it has
	// additional methods and properties).
	//
	// All nodes have parent links. The tree is used both to go from
	// line numbers to line objects, and to go from objects to numbers.
	// It also indexes by height, and is used to convert between height
	// and line object, and to find the total height of the document.
	//
	// See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html
	function LeafChunk(lines){this.lines=lines;this.parent=null;for(var i=0,height=0;i<lines.length;++i){lines[i].parent=this;height+=lines[i].height}this.height=height}LeafChunk.prototype={chunkSize:function(){return this.lines.length}, // Remove the n lines at offset 'at'.
	removeInner:function(at,n){for(var i=at,e=at+n;i<e;++i){var line=this.lines[i];this.height-=line.height;cleanUpLine(line);signalLater(line,"delete")}this.lines.splice(at,n)}, // Helper used to collapse a small branch into a single leaf.
	collapse:function(lines){lines.push.apply(lines,this.lines)}, // Insert the given array of lines at offset 'at', count them as
	// having the given height.
	insertInner:function(at,lines,height){this.height+=height;this.lines=this.lines.slice(0,at).concat(lines).concat(this.lines.slice(at));for(var i=0;i<lines.length;++i)lines[i].parent=this}, // Used to iterate over a part of the tree.
	iterN:function(at,n,op){for(var e=at+n;at<e;++at)if(op(this.lines[at]))return true}};function BranchChunk(children){this.children=children;var size=0,height=0;for(var i=0;i<children.length;++i){var ch=children[i];size+=ch.chunkSize();height+=ch.height;ch.parent=this}this.size=size;this.height=height;this.parent=null}BranchChunk.prototype={chunkSize:function(){return this.size},removeInner:function(at,n){this.size-=n;for(var i=0;i<this.children.length;++i){var child=this.children[i],sz=child.chunkSize();if(at<sz){var rm=Math.min(n,sz-at),oldHeight=child.height;child.removeInner(at,rm);this.height-=oldHeight-child.height;if(sz==rm){this.children.splice(i--,1);child.parent=null}if((n-=rm)==0)break;at=0}else at-=sz} // If the result is smaller than 25 lines, ensure that it is a
	// single leaf node.
	if(this.size-n<25&&(this.children.length>1||!(this.children[0] instanceof LeafChunk))){var lines=[];this.collapse(lines);this.children=[new LeafChunk(lines)];this.children[0].parent=this}},collapse:function(lines){for(var i=0;i<this.children.length;++i)this.children[i].collapse(lines)},insertInner:function(at,lines,height){this.size+=lines.length;this.height+=height;for(var i=0;i<this.children.length;++i){var child=this.children[i],sz=child.chunkSize();if(at<=sz){child.insertInner(at,lines,height);if(child.lines&&child.lines.length>50){while(child.lines.length>50){var spilled=child.lines.splice(child.lines.length-25,25);var newleaf=new LeafChunk(spilled);child.height-=newleaf.height;this.children.splice(i+1,0,newleaf);newleaf.parent=this}this.maybeSpill()}break}at-=sz}}, // When a node has grown, check whether it should be split.
	maybeSpill:function(){if(this.children.length<=10)return;var me=this;do {var spilled=me.children.splice(me.children.length-5,5);var sibling=new BranchChunk(spilled);if(!me.parent){ // Become the parent node
	var copy=new BranchChunk(me.children);copy.parent=me;me.children=[copy,sibling];me=copy}else {me.size-=sibling.size;me.height-=sibling.height;var myIndex=indexOf(me.parent.children,me);me.parent.children.splice(myIndex+1,0,sibling)}sibling.parent=me.parent}while(me.children.length>10);me.parent.maybeSpill()},iterN:function(at,n,op){for(var i=0;i<this.children.length;++i){var child=this.children[i],sz=child.chunkSize();if(at<sz){var used=Math.min(n,sz-at);if(child.iterN(at,used,op))return true;if((n-=used)==0)break;at=0}else at-=sz}}};var nextDocId=0;var Doc=CodeMirror.Doc=function(text,mode,firstLine,lineSep){if(!(this instanceof Doc))return new Doc(text,mode,firstLine,lineSep);if(firstLine==null)firstLine=0;BranchChunk.call(this,[new LeafChunk([new Line("",null)])]);this.first=firstLine;this.scrollTop=this.scrollLeft=0;this.cantEdit=false;this.cleanGeneration=1;this.frontier=firstLine;var start=Pos(firstLine,0);this.sel=simpleSelection(start);this.history=new History(null);this.id=++nextDocId;this.modeOption=mode;this.lineSep=lineSep;this.extend=false;if(typeof text=="string")text=this.splitLines(text);updateDoc(this,{from:start,to:start,text:text});setSelection(this,simpleSelection(start),sel_dontScroll)};Doc.prototype=createObj(BranchChunk.prototype,{constructor:Doc, // Iterate over the document. Supports two forms -- with only one
	// argument, it calls that for each line in the document. With
	// three, it iterates over the range given by the first two (with
	// the second being non-inclusive).
	iter:function(from,to,op){if(op)this.iterN(from-this.first,to-from,op);else this.iterN(this.first,this.first+this.size,from)}, // Non-public interface for adding and removing lines.
	insert:function(at,lines){var height=0;for(var i=0;i<lines.length;++i)height+=lines[i].height;this.insertInner(at-this.first,lines,height)},remove:function(at,n){this.removeInner(at-this.first,n)}, // From here, the methods are part of the public interface. Most
	// are also available from CodeMirror (editor) instances.
	getValue:function(lineSep){var lines=getLines(this,this.first,this.first+this.size);if(lineSep===false)return lines;return lines.join(lineSep||this.lineSeparator())},setValue:docMethodOp(function(code){var top=Pos(this.first,0),last=this.first+this.size-1;makeChange(this,{from:top,to:Pos(last,getLine(this,last).text.length),text:this.splitLines(code),origin:"setValue",full:true},true);setSelection(this,simpleSelection(top))}),replaceRange:function(code,from,to,origin){from=clipPos(this,from);to=to?clipPos(this,to):from;replaceRange(this,code,from,to,origin)},getRange:function(from,to,lineSep){var lines=getBetween(this,clipPos(this,from),clipPos(this,to));if(lineSep===false)return lines;return lines.join(lineSep||this.lineSeparator())},getLine:function(line){var l=this.getLineHandle(line);return l&&l.text},getLineHandle:function(line){if(isLine(this,line))return getLine(this,line)},getLineNumber:function(line){return lineNo(line)},getLineHandleVisualStart:function(line){if(typeof line=="number")line=getLine(this,line);return visualLine(line)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(pos){return clipPos(this,pos)},getCursor:function(start){var range=this.sel.primary(),pos;if(start==null||start=="head")pos=range.head;else if(start=="anchor")pos=range.anchor;else if(start=="end"||start=="to"||start===false)pos=range.to();else pos=range.from();return pos},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:docMethodOp(function(line,ch,options){setSimpleSelection(this,clipPos(this,typeof line=="number"?Pos(line,ch||0):line),null,options)}),setSelection:docMethodOp(function(anchor,head,options){setSimpleSelection(this,clipPos(this,anchor),clipPos(this,head||anchor),options)}),extendSelection:docMethodOp(function(head,other,options){extendSelection(this,clipPos(this,head),other&&clipPos(this,other),options)}),extendSelections:docMethodOp(function(heads,options){extendSelections(this,clipPosArray(this,heads,options))}),extendSelectionsBy:docMethodOp(function(f,options){extendSelections(this,map(this.sel.ranges,f),options)}),setSelections:docMethodOp(function(ranges,primary,options){if(!ranges.length)return;for(var i=0,out=[];i<ranges.length;i++)out[i]=new Range(clipPos(this,ranges[i].anchor),clipPos(this,ranges[i].head));if(primary==null)primary=Math.min(ranges.length-1,this.sel.primIndex);setSelection(this,normalizeSelection(out,primary),options)}),addSelection:docMethodOp(function(anchor,head,options){var ranges=this.sel.ranges.slice(0);ranges.push(new Range(clipPos(this,anchor),clipPos(this,head||anchor)));setSelection(this,normalizeSelection(ranges,ranges.length-1),options)}),getSelection:function(lineSep){var ranges=this.sel.ranges,lines;for(var i=0;i<ranges.length;i++){var sel=getBetween(this,ranges[i].from(),ranges[i].to());lines=lines?lines.concat(sel):sel}if(lineSep===false)return lines;else return lines.join(lineSep||this.lineSeparator())},getSelections:function(lineSep){var parts=[],ranges=this.sel.ranges;for(var i=0;i<ranges.length;i++){var sel=getBetween(this,ranges[i].from(),ranges[i].to());if(lineSep!==false)sel=sel.join(lineSep||this.lineSeparator());parts[i]=sel}return parts},replaceSelection:function(code,collapse,origin){var dup=[];for(var i=0;i<this.sel.ranges.length;i++)dup[i]=code;this.replaceSelections(dup,collapse,origin||"+input")},replaceSelections:docMethodOp(function(code,collapse,origin){var changes=[],sel=this.sel;for(var i=0;i<sel.ranges.length;i++){var range=sel.ranges[i];changes[i]={from:range.from(),to:range.to(),text:this.splitLines(code[i]),origin:origin}}var newSel=collapse&&collapse!="end"&&computeReplacedSel(this,changes,collapse);for(var i=changes.length-1;i>=0;i--)makeChange(this,changes[i]);if(newSel)setSelectionReplaceHistory(this,newSel);else if(this.cm)ensureCursorVisible(this.cm)}),undo:docMethodOp(function(){makeChangeFromHistory(this,"undo")}),redo:docMethodOp(function(){makeChangeFromHistory(this,"redo")}),undoSelection:docMethodOp(function(){makeChangeFromHistory(this,"undo",true)}),redoSelection:docMethodOp(function(){makeChangeFromHistory(this,"redo",true)}),setExtending:function(val){this.extend=val},getExtending:function(){return this.extend},historySize:function(){var hist=this.history,done=0,undone=0;for(var i=0;i<hist.done.length;i++)if(!hist.done[i].ranges)++done;for(var i=0;i<hist.undone.length;i++)if(!hist.undone[i].ranges)++undone;return {undo:done,redo:undone}},clearHistory:function(){this.history=new History(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(true)},changeGeneration:function(forceSplit){if(forceSplit)this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null;return this.history.generation},isClean:function(gen){return this.history.generation==(gen||this.cleanGeneration)},getHistory:function(){return {done:copyHistoryArray(this.history.done),undone:copyHistoryArray(this.history.undone)}},setHistory:function(histData){var hist=this.history=new History(this.history.maxGeneration);hist.done=copyHistoryArray(histData.done.slice(0),null,true);hist.undone=copyHistoryArray(histData.undone.slice(0),null,true)},addLineClass:docMethodOp(function(handle,where,cls){return changeLine(this,handle,where=="gutter"?"gutter":"class",function(line){var prop=where=="text"?"textClass":where=="background"?"bgClass":where=="gutter"?"gutterClass":"wrapClass";if(!line[prop])line[prop]=cls;else if(classTest(cls).test(line[prop]))return false;else line[prop]+=" "+cls;return true})}),removeLineClass:docMethodOp(function(handle,where,cls){return changeLine(this,handle,where=="gutter"?"gutter":"class",function(line){var prop=where=="text"?"textClass":where=="background"?"bgClass":where=="gutter"?"gutterClass":"wrapClass";var cur=line[prop];if(!cur)return false;else if(cls==null)line[prop]=null;else {var found=cur.match(classTest(cls));if(!found)return false;var end=found.index+found[0].length;line[prop]=cur.slice(0,found.index)+(!found.index||end==cur.length?"":" ")+cur.slice(end)||null}return true})}),addLineWidget:docMethodOp(function(handle,node,options){return addLineWidget(this,handle,node,options)}),removeLineWidget:function(widget){widget.clear()},markText:function(from,to,options){return markText(this,clipPos(this,from),clipPos(this,to),options,options&&options.type||"range")},setBookmark:function(pos,options){var realOpts={replacedWith:options&&(options.nodeType==null?options.widget:options),insertLeft:options&&options.insertLeft,clearWhenEmpty:false,shared:options&&options.shared,handleMouseEvents:options&&options.handleMouseEvents};pos=clipPos(this,pos);return markText(this,pos,pos,realOpts,"bookmark")},findMarksAt:function(pos){pos=clipPos(this,pos);var markers=[],spans=getLine(this,pos.line).markedSpans;if(spans)for(var i=0;i<spans.length;++i){var span=spans[i];if((span.from==null||span.from<=pos.ch)&&(span.to==null||span.to>=pos.ch))markers.push(span.marker.parent||span.marker)}return markers},findMarks:function(from,to,filter){from=clipPos(this,from);to=clipPos(this,to);var found=[],lineNo=from.line;this.iter(from.line,to.line+1,function(line){var spans=line.markedSpans;if(spans)for(var i=0;i<spans.length;i++){var span=spans[i];if(!(lineNo==from.line&&from.ch>span.to||span.from==null&&lineNo!=from.line||lineNo==to.line&&span.from>to.ch)&&(!filter||filter(span.marker)))found.push(span.marker.parent||span.marker)}++lineNo});return found},getAllMarks:function(){var markers=[];this.iter(function(line){var sps=line.markedSpans;if(sps)for(var i=0;i<sps.length;++i)if(sps[i].from!=null)markers.push(sps[i].marker)});return markers},posFromIndex:function(off){var ch,lineNo=this.first;this.iter(function(line){var sz=line.text.length+1;if(sz>off){ch=off;return true}off-=sz;++lineNo});return clipPos(this,Pos(lineNo,ch))},indexFromPos:function(coords){coords=clipPos(this,coords);var index=coords.ch;if(coords.line<this.first||coords.ch<0)return 0;this.iter(this.first,coords.line,function(line){index+=line.text.length+1});return index},copy:function(copyHistory){var doc=new Doc(getLines(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep);doc.scrollTop=this.scrollTop;doc.scrollLeft=this.scrollLeft;doc.sel=this.sel;doc.extend=false;if(copyHistory){doc.history.undoDepth=this.history.undoDepth;doc.setHistory(this.getHistory())}return doc},linkedDoc:function(options){if(!options)options={};var from=this.first,to=this.first+this.size;if(options.from!=null&&options.from>from)from=options.from;if(options.to!=null&&options.to<to)to=options.to;var copy=new Doc(getLines(this,from,to),options.mode||this.modeOption,from,this.lineSep);if(options.sharedHist)copy.history=this.history;(this.linked||(this.linked=[])).push({doc:copy,sharedHist:options.sharedHist});copy.linked=[{doc:this,isParent:true,sharedHist:options.sharedHist}];copySharedMarkers(copy,findSharedMarkers(this));return copy},unlinkDoc:function(other){if(other instanceof CodeMirror)other=other.doc;if(this.linked)for(var i=0;i<this.linked.length;++i){var link=this.linked[i];if(link.doc!=other)continue;this.linked.splice(i,1);other.unlinkDoc(this);detachSharedMarkers(findSharedMarkers(this));break} // If the histories were shared, split them again
	if(other.history==this.history){var splitIds=[other.id];linkedDocs(other,function(doc){splitIds.push(doc.id)},true);other.history=new History(null);other.history.done=copyHistoryArray(this.history.done,splitIds);other.history.undone=copyHistoryArray(this.history.undone,splitIds)}},iterLinkedDocs:function(f){linkedDocs(this,f)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(str){if(this.lineSep)return str.split(this.lineSep);return splitLinesAuto(str)},lineSeparator:function(){return this.lineSep||"\n"}}); // Public alias.
	Doc.prototype.eachLine=Doc.prototype.iter; // Set up methods on CodeMirror's prototype to redirect to the editor's document.
	var dontDelegate="iter insert remove copy getEditor constructor".split(" ");for(var prop in Doc.prototype)if(Doc.prototype.hasOwnProperty(prop)&&indexOf(dontDelegate,prop)<0)CodeMirror.prototype[prop]=(function(method){return function(){return method.apply(this.doc,arguments)}})(Doc.prototype[prop]);eventMixin(Doc); // Call f for all linked documents.
	function linkedDocs(doc,f,sharedHistOnly){function propagate(doc,skip,sharedHist){if(doc.linked)for(var i=0;i<doc.linked.length;++i){var rel=doc.linked[i];if(rel.doc==skip)continue;var shared=sharedHist&&rel.sharedHist;if(sharedHistOnly&&!shared)continue;f(rel.doc,shared);propagate(rel.doc,doc,shared)}}propagate(doc,null,true)} // Attach a document to an editor.
	function attachDoc(cm,doc){if(doc.cm)throw new Error("This document is already in use.");cm.doc=doc;doc.cm=cm;estimateLineHeights(cm);loadMode(cm);if(!cm.options.lineWrapping)findMaxLine(cm);cm.options.mode=doc.modeOption;regChange(cm)} // LINE UTILITIES
	// Find the line object corresponding to the given line number.
	function getLine(doc,n){n-=doc.first;if(n<0||n>=doc.size)throw new Error("There is no line "+(n+doc.first)+" in the document.");for(var chunk=doc;!chunk.lines;){for(var i=0;;++i){var child=chunk.children[i],sz=child.chunkSize();if(n<sz){chunk=child;break}n-=sz}}return chunk.lines[n]} // Get the part of a document between two positions, as an array of
	// strings.
	function getBetween(doc,start,end){var out=[],n=start.line;doc.iter(start.line,end.line+1,function(line){var text=line.text;if(n==end.line)text=text.slice(0,end.ch);if(n==start.line)text=text.slice(start.ch);out.push(text);++n});return out} // Get the lines between from and to, as array of strings.
	function getLines(doc,from,to){var out=[];doc.iter(from,to,function(line){out.push(line.text)});return out} // Update the height of a line, propagating the height change
	// upwards to parent nodes.
	function updateLineHeight(line,height){var diff=height-line.height;if(diff)for(var n=line;n;n=n.parent)n.height+=diff} // Given a line object, find its line number by walking up through
	// its parent links.
	function lineNo(line){if(line.parent==null)return null;var cur=line.parent,no=indexOf(cur.lines,line);for(var chunk=cur.parent;chunk;cur=chunk,chunk=chunk.parent){for(var i=0;;++i){if(chunk.children[i]==cur)break;no+=chunk.children[i].chunkSize()}}return no+cur.first} // Find the line at the given vertical position, using the height
	// information in the document tree.
	function lineAtHeight(chunk,h){var n=chunk.first;outer: do {for(var i=0;i<chunk.children.length;++i){var child=chunk.children[i],ch=child.height;if(h<ch){chunk=child;continue outer}h-=ch;n+=child.chunkSize()}return n}while(!chunk.lines);for(var i=0;i<chunk.lines.length;++i){var line=chunk.lines[i],lh=line.height;if(h<lh)break;h-=lh}return n+i} // Find the height above the given line.
	function heightAtLine(lineObj){lineObj=visualLine(lineObj);var h=0,chunk=lineObj.parent;for(var i=0;i<chunk.lines.length;++i){var line=chunk.lines[i];if(line==lineObj)break;else h+=line.height}for(var p=chunk.parent;p;chunk=p,p=chunk.parent){for(var i=0;i<p.children.length;++i){var cur=p.children[i];if(cur==chunk)break;else h+=cur.height}}return h} // Get the bidi ordering for the given line (and cache it). Returns
	// false for lines that are fully left-to-right, and an array of
	// BidiSpan objects otherwise.
	function getOrder(line){var order=line.order;if(order==null)order=line.order=bidiOrdering(line.text);return order} // HISTORY
	function History(startGen){ // Arrays of change events and selections. Doing something adds an
	// event to done and clears undo. Undoing moves events from done
	// to undone, redoing moves them in the other direction.
	this.done=[];this.undone=[];this.undoDepth=Infinity; // Used to track when changes can be merged into a single undo
	// event
	this.lastModTime=this.lastSelTime=0;this.lastOp=this.lastSelOp=null;this.lastOrigin=this.lastSelOrigin=null; // Used by the isClean() method
	this.generation=this.maxGeneration=startGen||1} // Create a history change event from an updateDoc-style change
	// object.
	function historyChangeFromChange(doc,change){var histChange={from:copyPos(change.from),to:changeEnd(change),text:getBetween(doc,change.from,change.to)};attachLocalSpans(doc,histChange,change.from.line,change.to.line+1);linkedDocs(doc,function(doc){attachLocalSpans(doc,histChange,change.from.line,change.to.line+1)},true);return histChange} // Pop all selection events off the end of a history array. Stop at
	// a change event.
	function clearSelectionEvents(array){while(array.length){var last=lst(array);if(last.ranges)array.pop();else break}} // Find the top change event in the history. Pop off selection
	// events that are in the way.
	function lastChangeEvent(hist,force){if(force){clearSelectionEvents(hist.done);return lst(hist.done)}else if(hist.done.length&&!lst(hist.done).ranges){return lst(hist.done)}else if(hist.done.length>1&&!hist.done[hist.done.length-2].ranges){hist.done.pop();return lst(hist.done)}} // Register a change in the history. Merges changes that are within
	// a single operation, ore are close together with an origin that
	// allows merging (starting with "+") into a single event.
	function addChangeToHistory(doc,change,selAfter,opId){var hist=doc.history;hist.undone.length=0;var time=+new Date,cur;if((hist.lastOp==opId||hist.lastOrigin==change.origin&&change.origin&&(change.origin.charAt(0)=="+"&&doc.cm&&hist.lastModTime>time-doc.cm.options.historyEventDelay||change.origin.charAt(0)=="*"))&&(cur=lastChangeEvent(hist,hist.lastOp==opId))){ // Merge this change into the last event
	var last=lst(cur.changes);if(cmp(change.from,change.to)==0&&cmp(change.from,last.to)==0){ // Optimized case for simple insertion -- don't want to add
	// new changesets for every character typed
	last.to=changeEnd(change)}else { // Add new sub-event
	cur.changes.push(historyChangeFromChange(doc,change))}}else { // Can not be merged, start a new event.
	var before=lst(hist.done);if(!before||!before.ranges)pushSelectionToHistory(doc.sel,hist.done);cur={changes:[historyChangeFromChange(doc,change)],generation:hist.generation};hist.done.push(cur);while(hist.done.length>hist.undoDepth){hist.done.shift();if(!hist.done[0].ranges)hist.done.shift()}}hist.done.push(selAfter);hist.generation=++hist.maxGeneration;hist.lastModTime=hist.lastSelTime=time;hist.lastOp=hist.lastSelOp=opId;hist.lastOrigin=hist.lastSelOrigin=change.origin;if(!last)signal(doc,"historyAdded")}function selectionEventCanBeMerged(doc,origin,prev,sel){var ch=origin.charAt(0);return ch=="*"||ch=="+"&&prev.ranges.length==sel.ranges.length&&prev.somethingSelected()==sel.somethingSelected()&&new Date-doc.history.lastSelTime<=(doc.cm?doc.cm.options.historyEventDelay:500)} // Called whenever the selection changes, sets the new selection as
	// the pending selection in the history, and pushes the old pending
	// selection into the 'done' array when it was significantly
	// different (in number of selected ranges, emptiness, or time).
	function addSelectionToHistory(doc,sel,opId,options){var hist=doc.history,origin=options&&options.origin; // A new event is started when the previous origin does not match
	// the current, or the origins don't allow matching. Origins
	// starting with * are always merged, those starting with + are
	// merged when similar and close together in time.
	if(opId==hist.lastSelOp||origin&&hist.lastSelOrigin==origin&&(hist.lastModTime==hist.lastSelTime&&hist.lastOrigin==origin||selectionEventCanBeMerged(doc,origin,lst(hist.done),sel)))hist.done[hist.done.length-1]=sel;else pushSelectionToHistory(sel,hist.done);hist.lastSelTime=+new Date;hist.lastSelOrigin=origin;hist.lastSelOp=opId;if(options&&options.clearRedo!==false)clearSelectionEvents(hist.undone)}function pushSelectionToHistory(sel,dest){var top=lst(dest);if(!(top&&top.ranges&&top.equals(sel)))dest.push(sel)} // Used to store marked span information in the history.
	function attachLocalSpans(doc,change,from,to){var existing=change["spans_"+doc.id],n=0;doc.iter(Math.max(doc.first,from),Math.min(doc.first+doc.size,to),function(line){if(line.markedSpans)(existing||(existing=change["spans_"+doc.id]={}))[n]=line.markedSpans;++n})} // When un/re-doing restores text containing marked spans, those
	// that have been explicitly cleared should not be restored.
	function removeClearedSpans(spans){if(!spans)return null;for(var i=0,out;i<spans.length;++i){if(spans[i].marker.explicitlyCleared){if(!out)out=spans.slice(0,i)}else if(out)out.push(spans[i])}return !out?spans:out.length?out:null} // Retrieve and filter the old marked spans stored in a change event.
	function getOldSpans(doc,change){var found=change["spans_"+doc.id];if(!found)return null;for(var i=0,nw=[];i<change.text.length;++i)nw.push(removeClearedSpans(found[i]));return nw} // Used both to provide a JSON-safe object in .getHistory, and, when
	// detaching a document, to split the history in two
	function copyHistoryArray(events,newGroup,instantiateSel){for(var i=0,copy=[];i<events.length;++i){var event=events[i];if(event.ranges){copy.push(instantiateSel?Selection.prototype.deepCopy.call(event):event);continue}var changes=event.changes,newChanges=[];copy.push({changes:newChanges});for(var j=0;j<changes.length;++j){var change=changes[j],m;newChanges.push({from:change.from,to:change.to,text:change.text});if(newGroup)for(var prop in change)if(m=prop.match(/^spans_(\d+)$/)){if(indexOf(newGroup,Number(m[1]))>-1){lst(newChanges)[prop]=change[prop];delete change[prop]}}}}return copy} // Rebasing/resetting history to deal with externally-sourced changes
	function rebaseHistSelSingle(pos,from,to,diff){if(to<pos.line){pos.line+=diff}else if(from<pos.line){pos.line=from;pos.ch=0}} // Tries to rebase an array of history events given a change in the
	// document. If the change touches the same lines as the event, the
	// event, and everything 'behind' it, is discarded. If the change is
	// before the event, the event's positions are updated. Uses a
	// copy-on-write scheme for the positions, to avoid having to
	// reallocate them all on every rebase, but also avoid problems with
	// shared position objects being unsafely updated.
	function rebaseHistArray(array,from,to,diff){for(var i=0;i<array.length;++i){var sub=array[i],ok=true;if(sub.ranges){if(!sub.copied){sub=array[i]=sub.deepCopy();sub.copied=true}for(var j=0;j<sub.ranges.length;j++){rebaseHistSelSingle(sub.ranges[j].anchor,from,to,diff);rebaseHistSelSingle(sub.ranges[j].head,from,to,diff)}continue}for(var j=0;j<sub.changes.length;++j){var cur=sub.changes[j];if(to<cur.from.line){cur.from=Pos(cur.from.line+diff,cur.from.ch);cur.to=Pos(cur.to.line+diff,cur.to.ch)}else if(from<=cur.to.line){ok=false;break}}if(!ok){array.splice(0,i+1);i=0}}}function rebaseHist(hist,change){var from=change.from.line,to=change.to.line,diff=change.text.length-(to-from)-1;rebaseHistArray(hist.done,from,to,diff);rebaseHistArray(hist.undone,from,to,diff)} // EVENT UTILITIES
	// Due to the fact that we still support jurassic IE versions, some
	// compatibility wrappers are needed.
	var e_preventDefault=CodeMirror.e_preventDefault=function(e){if(e.preventDefault)e.preventDefault();else e.returnValue=false};var e_stopPropagation=CodeMirror.e_stopPropagation=function(e){if(e.stopPropagation)e.stopPropagation();else e.cancelBubble=true};function e_defaultPrevented(e){return e.defaultPrevented!=null?e.defaultPrevented:e.returnValue==false}var e_stop=CodeMirror.e_stop=function(e){e_preventDefault(e);e_stopPropagation(e)};function e_target(e){return e.target||e.srcElement}function e_button(e){var b=e.which;if(b==null){if(e.button&1)b=1;else if(e.button&2)b=3;else if(e.button&4)b=2}if(mac&&e.ctrlKey&&b==1)b=3;return b} // EVENT HANDLING
	// Lightweight event framework. on/off also work on DOM nodes,
	// registering native DOM handlers.
	var on=CodeMirror.on=function(emitter,type,f){if(emitter.addEventListener)emitter.addEventListener(type,f,false);else if(emitter.attachEvent)emitter.attachEvent("on"+type,f);else {var map=emitter._handlers||(emitter._handlers={});var arr=map[type]||(map[type]=[]);arr.push(f)}};var noHandlers=[];function getHandlers(emitter,type,copy){var arr=emitter._handlers&&emitter._handlers[type];if(copy)return arr&&arr.length>0?arr.slice():noHandlers;else return arr||noHandlers}var off=CodeMirror.off=function(emitter,type,f){if(emitter.removeEventListener)emitter.removeEventListener(type,f,false);else if(emitter.detachEvent)emitter.detachEvent("on"+type,f);else {var handlers=getHandlers(emitter,type,false);for(var i=0;i<handlers.length;++i)if(handlers[i]==f){handlers.splice(i,1);break}}};var signal=CodeMirror.signal=function(emitter,type /*, values...*/){var handlers=getHandlers(emitter,type,true);if(!handlers.length)return;var args=Array.prototype.slice.call(arguments,2);for(var i=0;i<handlers.length;++i)handlers[i].apply(null,args)};var orphanDelayedCallbacks=null; // Often, we want to signal events at a point where we are in the
	// middle of some work, but don't want the handler to start calling
	// other methods on the editor, which might be in an inconsistent
	// state or simply not expect any other events to happen.
	// signalLater looks whether there are any handlers, and schedules
	// them to be executed when the last operation ends, or, if no
	// operation is active, when a timeout fires.
	function signalLater(emitter,type /*, values...*/){var arr=getHandlers(emitter,type,false);if(!arr.length)return;var args=Array.prototype.slice.call(arguments,2),list;if(operationGroup){list=operationGroup.delayedCallbacks}else if(orphanDelayedCallbacks){list=orphanDelayedCallbacks}else {list=orphanDelayedCallbacks=[];setTimeout(fireOrphanDelayed,0)}function bnd(f){return function(){f.apply(null,args)}};for(var i=0;i<arr.length;++i)list.push(bnd(arr[i]))}function fireOrphanDelayed(){var delayed=orphanDelayedCallbacks;orphanDelayedCallbacks=null;for(var i=0;i<delayed.length;++i)delayed[i]()} // The DOM events that CodeMirror handles can be overridden by
	// registering a (non-DOM) handler on the editor for the event name,
	// and preventDefault-ing the event in that handler.
	function signalDOMEvent(cm,e,override){if(typeof e=="string")e={type:e,preventDefault:function(){this.defaultPrevented=true}};signal(cm,override||e.type,cm,e);return e_defaultPrevented(e)||e.codemirrorIgnore}function signalCursorActivity(cm){var arr=cm._handlers&&cm._handlers.cursorActivity;if(!arr)return;var set=cm.curOp.cursorActivityHandlers||(cm.curOp.cursorActivityHandlers=[]);for(var i=0;i<arr.length;++i)if(indexOf(set,arr[i])==-1)set.push(arr[i])}function hasHandler(emitter,type){return getHandlers(emitter,type).length>0} // Add on and off methods to a constructor's prototype, to make
	// registering events on such objects more convenient.
	function eventMixin(ctor){ctor.prototype.on=function(type,f){on(this,type,f)};ctor.prototype.off=function(type,f){off(this,type,f)}} // MISC UTILITIES
	// Number of pixels added to scroller and sizer to hide scrollbar
	var scrollerGap=30; // Returned or thrown by various protocols to signal 'I'm not
	// handling this'.
	var Pass=CodeMirror.Pass={toString:function(){return "CodeMirror.Pass"}}; // Reused option objects for setSelection & friends
	var sel_dontScroll={scroll:false},sel_mouse={origin:"*mouse"},sel_move={origin:"+move"};function Delayed(){this.id=null}Delayed.prototype.set=function(ms,f){clearTimeout(this.id);this.id=setTimeout(f,ms)}; // Counts the column offset in a string, taking tabs into account.
	// Used mostly to find indentation.
	var countColumn=CodeMirror.countColumn=function(string,end,tabSize,startIndex,startValue){if(end==null){end=string.search(/[^\s\u00a0]/);if(end==-1)end=string.length}for(var i=startIndex||0,n=startValue||0;;){var nextTab=string.indexOf("\t",i);if(nextTab<0||nextTab>=end)return n+(end-i);n+=nextTab-i;n+=tabSize-n%tabSize;i=nextTab+1}}; // The inverse of countColumn -- find the offset that corresponds to
	// a particular column.
	var findColumn=CodeMirror.findColumn=function(string,goal,tabSize){for(var pos=0,col=0;;){var nextTab=string.indexOf("\t",pos);if(nextTab==-1)nextTab=string.length;var skipped=nextTab-pos;if(nextTab==string.length||col+skipped>=goal)return pos+Math.min(skipped,goal-col);col+=nextTab-pos;col+=tabSize-col%tabSize;pos=nextTab+1;if(col>=goal)return pos}};var spaceStrs=[""];function spaceStr(n){while(spaceStrs.length<=n)spaceStrs.push(lst(spaceStrs)+" ");return spaceStrs[n]}function lst(arr){return arr[arr.length-1]}var selectInput=function(node){node.select()};if(ios) // Mobile Safari apparently has a bug where select() is broken.
	selectInput=function(node){node.selectionStart=0;node.selectionEnd=node.value.length};else if(ie) // Suppress mysterious IE10 errors
	selectInput=function(node){try{node.select()}catch(_e) {}};function indexOf(array,elt){for(var i=0;i<array.length;++i)if(array[i]==elt)return i;return -1}function map(array,f){var out=[];for(var i=0;i<array.length;i++)out[i]=f(array[i],i);return out}function nothing(){}function createObj(base,props){var inst;if(Object.create){inst=Object.create(base)}else {nothing.prototype=base;inst=new nothing}if(props)copyObj(props,inst);return inst};function copyObj(obj,target,overwrite){if(!target)target={};for(var prop in obj)if(obj.hasOwnProperty(prop)&&(overwrite!==false||!target.hasOwnProperty(prop)))target[prop]=obj[prop];return target}function bind(f){var args=Array.prototype.slice.call(arguments,1);return function(){return f.apply(null,args)}}var nonASCIISingleCaseWordChar=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;var isWordCharBasic=CodeMirror.isWordChar=function(ch){return (/\w/.test(ch)||ch>"\x80"&&(ch.toUpperCase()!=ch.toLowerCase()||nonASCIISingleCaseWordChar.test(ch)))};function isWordChar(ch,helper){if(!helper)return isWordCharBasic(ch);if(helper.source.indexOf("\\w")>-1&&isWordCharBasic(ch))return true;return helper.test(ch)}function isEmpty(obj){for(var n in obj)if(obj.hasOwnProperty(n)&&obj[n])return false;return true} // Extending unicode characters. A series of a non-extending char +
	// any number of extending chars is treated as a single unit as far
	// as editing and measuring is concerned. This is not fully correct,
	// since some scripts/fonts/browsers also treat other configurations
	// of code points as a group.
	var extendingChars=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;function isExtendingChar(ch){return ch.charCodeAt(0)>=768&&extendingChars.test(ch)} // DOM UTILITIES
	function elt(tag,content,className,style){var e=document.createElement(tag);if(className)e.className=className;if(style)e.style.cssText=style;if(typeof content=="string")e.appendChild(document.createTextNode(content));else if(content)for(var i=0;i<content.length;++i)e.appendChild(content[i]);return e}var range;if(document.createRange)range=function(node,start,end,endNode){var r=document.createRange();r.setEnd(endNode||node,end);r.setStart(node,start);return r};else range=function(node,start,end){var r=document.body.createTextRange();try{r.moveToElementText(node.parentNode)}catch(e) {return r}r.collapse(true);r.moveEnd("character",end);r.moveStart("character",start);return r};function removeChildren(e){for(var count=e.childNodes.length;count>0;--count)e.removeChild(e.firstChild);return e}function removeChildrenAndAdd(parent,e){return removeChildren(parent).appendChild(e)}var contains=CodeMirror.contains=function(parent,child){if(child.nodeType==3) // Android browser always returns false when child is a textnode
	child=child.parentNode;if(parent.contains)return parent.contains(child);do {if(child.nodeType==11)child=child.host;if(child==parent)return true}while(child=child.parentNode)};function activeElt(){var activeElement=document.activeElement;while(activeElement&&activeElement.root&&activeElement.root.activeElement)activeElement=activeElement.root.activeElement;return activeElement} // Older versions of IE throws unspecified error when touching
	// document.activeElement in some cases (during loading, in iframe)
	if(ie&&ie_version<11)activeElt=function(){try{return document.activeElement}catch(e) {return document.body}};function classTest(cls){return new RegExp("(^|\\s)"+cls+"(?:$|\\s)\\s*")}var rmClass=CodeMirror.rmClass=function(node,cls){var current=node.className;var match=classTest(cls).exec(current);if(match){var after=current.slice(match.index+match[0].length);node.className=current.slice(0,match.index)+(after?match[1]+after:"")}};var addClass=CodeMirror.addClass=function(node,cls){var current=node.className;if(!classTest(cls).test(current))node.className+=(current?" ":"")+cls};function joinClasses(a,b){var as=a.split(" ");for(var i=0;i<as.length;i++)if(as[i]&&!classTest(as[i]).test(b))b+=" "+as[i];return b} // WINDOW-WIDE EVENTS
	// These must be handled carefully, because naively registering a
	// handler for each editor will cause the editors to never be
	// garbage collected.
	function forEachCodeMirror(f){if(!document.body.getElementsByClassName)return;var byClass=document.body.getElementsByClassName("CodeMirror");for(var i=0;i<byClass.length;i++){var cm=byClass[i].CodeMirror;if(cm)f(cm)}}var globalsRegistered=false;function ensureGlobalHandlers(){if(globalsRegistered)return;registerGlobalHandlers();globalsRegistered=true}function registerGlobalHandlers(){ // When the window resizes, we need to refresh active editors.
	var resizeTimer;on(window,"resize",function(){if(resizeTimer==null)resizeTimer=setTimeout(function(){resizeTimer=null;forEachCodeMirror(onResize)},100)}); // When the window loses focus, we want to show the editor as blurred
	on(window,"blur",function(){forEachCodeMirror(onBlur)})} // FEATURE DETECTION
	// Detect drag-and-drop
	var dragAndDrop=(function(){ // There is *some* kind of drag-and-drop support in IE6-8, but I
	// couldn't get it to work yet.
	if(ie&&ie_version<9)return false;var div=elt('div');return "draggable" in div||"dragDrop" in div})();var zwspSupported;function zeroWidthElement(measure){if(zwspSupported==null){var test=elt("span","\u200b");removeChildrenAndAdd(measure,elt("span",[test,document.createTextNode("x")]));if(measure.firstChild.offsetHeight!=0)zwspSupported=test.offsetWidth<=1&&test.offsetHeight>2&&!(ie&&ie_version<8)}var node=zwspSupported?elt("span","\u200b"):elt("span","\u00a0",null,"display: inline-block; width: 1px; margin-right: -1px");node.setAttribute("cm-text","");return node} // Feature-detect IE's crummy client rect reporting for bidi text
	var badBidiRects;function hasBadBidiRects(measure){if(badBidiRects!=null)return badBidiRects;var txt=removeChildrenAndAdd(measure,document.createTextNode("A\u062eA"));var r0=range(txt,0,1).getBoundingClientRect();if(!r0||r0.left==r0.right)return false; // Safari returns null in some cases (#2780)
	var r1=range(txt,1,2).getBoundingClientRect();return badBidiRects=r1.right-r0.right<3} // See if "".split is the broken IE version, if so, provide an
	// alternative way to split lines.
	var splitLinesAuto=CodeMirror.splitLines="\n\nb".split(/\n/).length!=3?function(string){var pos=0,result=[],l=string.length;while(pos<=l){var nl=string.indexOf("\n",pos);if(nl==-1)nl=string.length;var line=string.slice(pos,string.charAt(nl-1)=="\r"?nl-1:nl);var rt=line.indexOf("\r");if(rt!=-1){result.push(line.slice(0,rt));pos+=rt+1}else {result.push(line);pos=nl+1}}return result}:function(string){return string.split(/\r\n?|\n/)};var hasSelection=window.getSelection?function(te){try{return te.selectionStart!=te.selectionEnd}catch(e) {return false}}:function(te){try{var range=te.ownerDocument.selection.createRange()}catch(e) {}if(!range||range.parentElement()!=te)return false;return range.compareEndPoints("StartToEnd",range)!=0};var hasCopyEvent=(function(){var e=elt("div");if("oncopy" in e)return true;e.setAttribute("oncopy","return;");return typeof e.oncopy=="function"})();var badZoomedRects=null;function hasBadZoomedRects(measure){if(badZoomedRects!=null)return badZoomedRects;var node=removeChildrenAndAdd(measure,elt("span","x"));var normal=node.getBoundingClientRect();var fromRange=range(node,0,1).getBoundingClientRect();return badZoomedRects=Math.abs(normal.left-fromRange.left)>1} // KEY NAMES
	var keyNames=CodeMirror.keyNames={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"};(function(){ // Number keys
	for(var i=0;i<10;i++)keyNames[i+48]=keyNames[i+96]=String(i); // Alphabetic keys
	for(var i=65;i<=90;i++)keyNames[i]=String.fromCharCode(i); // Function keys
	for(var i=1;i<=12;i++)keyNames[i+111]=keyNames[i+63235]="F"+i})(); // BIDI HELPERS
	function iterateBidiSections(order,from,to,f){if(!order)return f(from,to,"ltr");var found=false;for(var i=0;i<order.length;++i){var part=order[i];if(part.from<to&&part.to>from||from==to&&part.to==from){f(Math.max(part.from,from),Math.min(part.to,to),part.level==1?"rtl":"ltr");found=true}}if(!found)f(from,to,"ltr")}function bidiLeft(part){return part.level%2?part.to:part.from}function bidiRight(part){return part.level%2?part.from:part.to}function lineLeft(line){var order=getOrder(line);return order?bidiLeft(order[0]):0}function lineRight(line){var order=getOrder(line);if(!order)return line.text.length;return bidiRight(lst(order))}function lineStart(cm,lineN){var line=getLine(cm.doc,lineN);var visual=visualLine(line);if(visual!=line)lineN=lineNo(visual);var order=getOrder(visual);var ch=!order?0:order[0].level%2?lineRight(visual):lineLeft(visual);return Pos(lineN,ch)}function lineEnd(cm,lineN){var merged,line=getLine(cm.doc,lineN);while(merged=collapsedSpanAtEnd(line)){line=merged.find(1,true).line;lineN=null}var order=getOrder(line);var ch=!order?line.text.length:order[0].level%2?lineLeft(line):lineRight(line);return Pos(lineN==null?lineNo(line):lineN,ch)}function lineStartSmart(cm,pos){var start=lineStart(cm,pos.line);var line=getLine(cm.doc,start.line);var order=getOrder(line);if(!order||order[0].level==0){var firstNonWS=Math.max(0,line.text.search(/\S/));var inWS=pos.line==start.line&&pos.ch<=firstNonWS&&pos.ch;return Pos(start.line,inWS?0:firstNonWS)}return start}function compareBidiLevel(order,a,b){var linedir=order[0].level;if(a==linedir)return true;if(b==linedir)return false;return a<b}var bidiOther;function getBidiPartAt(order,pos){bidiOther=null;for(var i=0,found;i<order.length;++i){var cur=order[i];if(cur.from<pos&&cur.to>pos)return i;if(cur.from==pos||cur.to==pos){if(found==null){found=i}else if(compareBidiLevel(order,cur.level,order[found].level)){if(cur.from!=cur.to)bidiOther=found;return i}else {if(cur.from!=cur.to)bidiOther=i;return found}}}return found}function moveInLine(line,pos,dir,byUnit){if(!byUnit)return pos+dir;do pos+=dir;while(pos>0&&isExtendingChar(line.text.charAt(pos)));return pos} // This is needed in order to move 'visually' through bi-directional
	// text -- i.e., pressing left should make the cursor go left, even
	// when in RTL text. The tricky part is the 'jumps', where RTL and
	// LTR text touch each other. This often requires the cursor offset
	// to move more than one unit, in order to visually move one unit.
	function moveVisually(line,start,dir,byUnit){var bidi=getOrder(line);if(!bidi)return moveLogically(line,start,dir,byUnit);var pos=getBidiPartAt(bidi,start),part=bidi[pos];var target=moveInLine(line,start,part.level%2?-dir:dir,byUnit);for(;;){if(target>part.from&&target<part.to)return target;if(target==part.from||target==part.to){if(getBidiPartAt(bidi,target)==pos)return target;part=bidi[pos+=dir];return dir>0==part.level%2?part.to:part.from}else {part=bidi[pos+=dir];if(!part)return null;if(dir>0==part.level%2)target=moveInLine(line,part.to,-1,byUnit);else target=moveInLine(line,part.from,1,byUnit)}}}function moveLogically(line,start,dir,byUnit){var target=start+dir;if(byUnit)while(target>0&&isExtendingChar(line.text.charAt(target)))target+=dir;return target<0||target>line.text.length?null:target} // Bidirectional ordering algorithm
	// See http://unicode.org/reports/tr9/tr9-13.html for the algorithm
	// that this (partially) implements.
	// One-char codes used for character types:
	// L (L):   Left-to-Right
	// R (R):   Right-to-Left
	// r (AL):  Right-to-Left Arabic
	// 1 (EN):  European Number
	// + (ES):  European Number Separator
	// % (ET):  European Number Terminator
	// n (AN):  Arabic Number
	// , (CS):  Common Number Separator
	// m (NSM): Non-Spacing Mark
	// b (BN):  Boundary Neutral
	// s (B):   Paragraph Separator
	// t (S):   Segment Separator
	// w (WS):  Whitespace
	// N (ON):  Other Neutrals
	// Returns null if characters are ordered as they appear
	// (left-to-right), or an array of sections ({from, to, level}
	// objects) in the order in which they occur visually.
	var bidiOrdering=(function(){ // Character types for codepoints 0 to 0xff
	var lowTypes="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN"; // Character types for codepoints 0x600 to 0x6ff
	var arabicTypes="rrrrrrrrrrrr,rNNmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmrrrrrrrnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmNmmmm";function charType(code){if(code<=0xf7)return lowTypes.charAt(code);else if(0x590<=code&&code<=0x5f4)return "R";else if(0x600<=code&&code<=0x6ed)return arabicTypes.charAt(code-0x600);else if(0x6ee<=code&&code<=0x8ac)return "r";else if(0x2000<=code&&code<=0x200b)return "w";else if(code==0x200c)return "b";else return "L"}var bidiRE=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;var isNeutral=/[stwN]/,isStrong=/[LRr]/,countsAsLeft=/[Lb1n]/,countsAsNum=/[1n]/; // Browsers seem to always treat the boundaries of block elements as being L.
	var outerType="L";function BidiSpan(level,from,to){this.level=level;this.from=from;this.to=to}return function(str){if(!bidiRE.test(str))return false;var len=str.length,types=[];for(var i=0,type;i<len;++i)types.push(type=charType(str.charCodeAt(i))); // W1. Examine each non-spacing mark (NSM) in the level run, and
	// change the type of the NSM to the type of the previous
	// character. If the NSM is at the start of the level run, it will
	// get the type of sor.
	for(var i=0,prev=outerType;i<len;++i){var type=types[i];if(type=="m")types[i]=prev;else prev=type} // W2. Search backwards from each instance of a European number
	// until the first strong type (R, L, AL, or sor) is found. If an
	// AL is found, change the type of the European number to Arabic
	// number.
	// W3. Change all ALs to R.
	for(var i=0,cur=outerType;i<len;++i){var type=types[i];if(type=="1"&&cur=="r")types[i]="n";else if(isStrong.test(type)){cur=type;if(type=="r")types[i]="R"}} // W4. A single European separator between two European numbers
	// changes to a European number. A single common separator between
	// two numbers of the same type changes to that type.
	for(var i=1,prev=types[0];i<len-1;++i){var type=types[i];if(type=="+"&&prev=="1"&&types[i+1]=="1")types[i]="1";else if(type==","&&prev==types[i+1]&&(prev=="1"||prev=="n"))types[i]=prev;prev=type} // W5. A sequence of European terminators adjacent to European
	// numbers changes to all European numbers.
	// W6. Otherwise, separators and terminators change to Other
	// Neutral.
	for(var i=0;i<len;++i){var type=types[i];if(type==",")types[i]="N";else if(type=="%"){for(var end=i+1;end<len&&types[end]=="%";++end){}var replace=i&&types[i-1]=="!"||end<len&&types[end]=="1"?"1":"N";for(var j=i;j<end;++j)types[j]=replace;i=end-1}} // W7. Search backwards from each instance of a European number
	// until the first strong type (R, L, or sor) is found. If an L is
	// found, then change the type of the European number to L.
	for(var i=0,cur=outerType;i<len;++i){var type=types[i];if(cur=="L"&&type=="1")types[i]="L";else if(isStrong.test(type))cur=type} // N1. A sequence of neutrals takes the direction of the
	// surrounding strong text if the text on both sides has the same
	// direction. European and Arabic numbers act as if they were R in
	// terms of their influence on neutrals. Start-of-level-run (sor)
	// and end-of-level-run (eor) are used at level run boundaries.
	// N2. Any remaining neutrals take the embedding direction.
	for(var i=0;i<len;++i){if(isNeutral.test(types[i])){for(var end=i+1;end<len&&isNeutral.test(types[end]);++end){}var before=(i?types[i-1]:outerType)=="L";var after=(end<len?types[end]:outerType)=="L";var replace=before||after?"L":"R";for(var j=i;j<end;++j)types[j]=replace;i=end-1}} // Here we depart from the documented algorithm, in order to avoid
	// building up an actual levels array. Since there are only three
	// levels (0, 1, 2) in an implementation that doesn't take
	// explicit embedding into account, we can build up the order on
	// the fly, without following the level-based algorithm.
	var order=[],m;for(var i=0;i<len;){if(countsAsLeft.test(types[i])){var start=i;for(++i;i<len&&countsAsLeft.test(types[i]);++i){}order.push(new BidiSpan(0,start,i))}else {var pos=i,at=order.length;for(++i;i<len&&types[i]!="L";++i){}for(var j=pos;j<i;){if(countsAsNum.test(types[j])){if(pos<j)order.splice(at,0,new BidiSpan(1,pos,j));var nstart=j;for(++j;j<i&&countsAsNum.test(types[j]);++j){}order.splice(at,0,new BidiSpan(2,nstart,j));pos=j}else ++j}if(pos<i)order.splice(at,0,new BidiSpan(1,pos,i))}}if(order[0].level==1&&(m=str.match(/^\s+/))){order[0].from=m[0].length;order.unshift(new BidiSpan(0,0,m[0].length))}if(lst(order).level==1&&(m=str.match(/\s+$/))){lst(order).to-=m[0].length;order.push(new BidiSpan(0,len-m[0].length,len))}if(order[0].level==2)order.unshift(new BidiSpan(1,order[0].to,order[0].to));if(order[0].level!=lst(order).level)order.push(new BidiSpan(order[0].level,len,len));return order}})(); // THE END
	CodeMirror.version="5.9.0";return CodeMirror});

/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	// CodeMirror, copyright (c) by Marijn Haverbeke and others
	// Distributed under an MIT license: http://codemirror.net/LICENSE

	// TODO actually recognize syntax of TypeScript constructs

	(function (mod) {
	  if (true) // CommonJS
	    mod(__webpack_require__(129));else if (typeof define == "function" && define.amd) // AMD
	    define(["../../lib/codemirror"], mod);else // Plain browser env
	    mod(CodeMirror);
	})(function (CodeMirror) {
	  "use strict";

	  CodeMirror.defineMode("javascript", function (config, parserConfig) {
	    var indentUnit = config.indentUnit;
	    var statementIndent = parserConfig.statementIndent;
	    var jsonldMode = parserConfig.jsonld;
	    var jsonMode = parserConfig.json || jsonldMode;
	    var isTS = parserConfig.typescript;
	    var wordRE = parserConfig.wordCharacters || /[\w$\xa1-\uffff]/;

	    // Tokenizer

	    var keywords = (function () {
	      function kw(type) {
	        return { type: type, style: "keyword" };
	      }
	      var A = kw("keyword a"),
	          B = kw("keyword b"),
	          C = kw("keyword c");
	      var operator = kw("operator"),
	          atom = { type: "atom", style: "atom" };

	      var jsKeywords = {
	        "if": kw("if"), "while": A, "with": A, "else": B, "do": B, "try": B, "finally": B,
	        "return": C, "break": C, "continue": C, "new": kw("new"), "delete": C, "throw": C, "debugger": C,
	        "var": kw("var"), "const": kw("var"), "let": kw("var"),
	        "function": kw("function"), "catch": kw("catch"),
	        "for": kw("for"), "switch": kw("switch"), "case": kw("case"), "default": kw("default"),
	        "in": operator, "typeof": operator, "instanceof": operator,
	        "true": atom, "false": atom, "null": atom, "undefined": atom, "NaN": atom, "Infinity": atom,
	        "this": kw("this"), "class": kw("class"), "super": kw("atom"),
	        "yield": C, "export": kw("export"), "import": kw("import"), "extends": C
	      };

	      // Extend the 'normal' keywords with the TypeScript language extensions
	      if (isTS) {
	        var type = { type: "variable", style: "variable-3" };
	        var tsKeywords = {
	          // object-like things
	          "interface": kw("interface"),
	          "extends": kw("extends"),
	          "constructor": kw("constructor"),

	          // scope modifiers
	          "public": kw("public"),
	          "private": kw("private"),
	          "protected": kw("protected"),
	          "static": kw("static"),

	          // types
	          "string": type, "number": type, "boolean": type, "any": type
	        };

	        for (var attr in tsKeywords) {
	          jsKeywords[attr] = tsKeywords[attr];
	        }
	      }

	      return jsKeywords;
	    })();

	    var isOperatorChar = /[+\-*&%=<>!?|~^]/;
	    var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)"/;

	    function readRegexp(stream) {
	      var escaped = false,
	          next,
	          inSet = false;
	      while ((next = stream.next()) != null) {
	        if (!escaped) {
	          if (next == "/" && !inSet) return;
	          if (next == "[") inSet = true;else if (inSet && next == "]") inSet = false;
	        }
	        escaped = !escaped && next == "\\";
	      }
	    }

	    // Used as scratch variables to communicate multiple values without
	    // consing up tons of objects.
	    var type, content;
	    function ret(tp, style, cont) {
	      type = tp;content = cont;
	      return style;
	    }
	    function tokenBase(stream, state) {
	      var ch = stream.next();
	      if (ch == '"' || ch == "'") {
	        state.tokenize = tokenString(ch);
	        return state.tokenize(stream, state);
	      } else if (ch == "." && stream.match(/^\d+(?:[eE][+\-]?\d+)?/)) {
	        return ret("number", "number");
	      } else if (ch == "." && stream.match("..")) {
	        return ret("spread", "meta");
	      } else if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
	        return ret(ch);
	      } else if (ch == "=" && stream.eat(">")) {
	        return ret("=>", "operator");
	      } else if (ch == "0" && stream.eat(/x/i)) {
	        stream.eatWhile(/[\da-f]/i);
	        return ret("number", "number");
	      } else if (ch == "0" && stream.eat(/o/i)) {
	        stream.eatWhile(/[0-7]/i);
	        return ret("number", "number");
	      } else if (ch == "0" && stream.eat(/b/i)) {
	        stream.eatWhile(/[01]/i);
	        return ret("number", "number");
	      } else if (/\d/.test(ch)) {
	        stream.match(/^\d*(?:\.\d*)?(?:[eE][+\-]?\d+)?/);
	        return ret("number", "number");
	      } else if (ch == "/") {
	        if (stream.eat("*")) {
	          state.tokenize = tokenComment;
	          return tokenComment(stream, state);
	        } else if (stream.eat("/")) {
	          stream.skipToEnd();
	          return ret("comment", "comment");
	        } else if (/^(?:operator|sof|keyword c|case|new|[\[{}\(,;:])$/.test(state.lastType)) {
	          readRegexp(stream);
	          stream.match(/^\b(([gimyu])(?![gimyu]*\2))+\b/);
	          return ret("regexp", "string-2");
	        } else {
	          stream.eatWhile(isOperatorChar);
	          return ret("operator", "operator", stream.current());
	        }
	      } else if (ch == "`") {
	        state.tokenize = tokenQuasi;
	        return tokenQuasi(stream, state);
	      } else if (ch == "#") {
	        stream.skipToEnd();
	        return ret("error", "error");
	      } else if (isOperatorChar.test(ch)) {
	        stream.eatWhile(isOperatorChar);
	        return ret("operator", "operator", stream.current());
	      } else if (wordRE.test(ch)) {
	        stream.eatWhile(wordRE);
	        var word = stream.current(),
	            known = keywords.propertyIsEnumerable(word) && keywords[word];
	        return known && state.lastType != "." ? ret(known.type, known.style, word) : ret("variable", "variable", word);
	      }
	    }

	    function tokenString(quote) {
	      return function (stream, state) {
	        var escaped = false,
	            next;
	        if (jsonldMode && stream.peek() == "@" && stream.match(isJsonldKeyword)) {
	          state.tokenize = tokenBase;
	          return ret("jsonld-keyword", "meta");
	        }
	        while ((next = stream.next()) != null) {
	          if (next == quote && !escaped) break;
	          escaped = !escaped && next == "\\";
	        }
	        if (!escaped) state.tokenize = tokenBase;
	        return ret("string", "string");
	      };
	    }

	    function tokenComment(stream, state) {
	      var maybeEnd = false,
	          ch;
	      while (ch = stream.next()) {
	        if (ch == "/" && maybeEnd) {
	          state.tokenize = tokenBase;
	          break;
	        }
	        maybeEnd = ch == "*";
	      }
	      return ret("comment", "comment");
	    }

	    function tokenQuasi(stream, state) {
	      var escaped = false,
	          next;
	      while ((next = stream.next()) != null) {
	        if (!escaped && (next == "`" || next == "$" && stream.eat("{"))) {
	          state.tokenize = tokenBase;
	          break;
	        }
	        escaped = !escaped && next == "\\";
	      }
	      return ret("quasi", "string-2", stream.current());
	    }

	    var brackets = "([{}])";
	    // This is a crude lookahead trick to try and notice that we're
	    // parsing the argument patterns for a fat-arrow function before we
	    // actually hit the arrow token. It only works if the arrow is on
	    // the same line as the arguments and there's no strange noise
	    // (comments) in between. Fallback is to only notice when we hit the
	    // arrow, and not declare the arguments as locals for the arrow
	    // body.
	    function findFatArrow(stream, state) {
	      if (state.fatArrowAt) state.fatArrowAt = null;
	      var arrow = stream.string.indexOf("=>", stream.start);
	      if (arrow < 0) return;

	      var depth = 0,
	          sawSomething = false;
	      for (var pos = arrow - 1; pos >= 0; --pos) {
	        var ch = stream.string.charAt(pos);
	        var bracket = brackets.indexOf(ch);
	        if (bracket >= 0 && bracket < 3) {
	          if (!depth) {
	            ++pos;break;
	          }
	          if (--depth == 0) break;
	        } else if (bracket >= 3 && bracket < 6) {
	          ++depth;
	        } else if (wordRE.test(ch)) {
	          sawSomething = true;
	        } else if (/["'\/]/.test(ch)) {
	          return;
	        } else if (sawSomething && !depth) {
	          ++pos;
	          break;
	        }
	      }
	      if (sawSomething && !depth) state.fatArrowAt = pos;
	    }

	    // Parser

	    var atomicTypes = { "atom": true, "number": true, "variable": true, "string": true, "regexp": true, "this": true, "jsonld-keyword": true };

	    function JSLexical(indented, column, type, align, prev, info) {
	      this.indented = indented;
	      this.column = column;
	      this.type = type;
	      this.prev = prev;
	      this.info = info;
	      if (align != null) this.align = align;
	    }

	    function inScope(state, varname) {
	      for (var v = state.localVars; v; v = v.next) if (v.name == varname) return true;
	      for (var cx = state.context; cx; cx = cx.prev) {
	        for (var v = cx.vars; v; v = v.next) if (v.name == varname) return true;
	      }
	    }

	    function parseJS(state, style, type, content, stream) {
	      var cc = state.cc;
	      // Communicate our context to the combinators.
	      // (Less wasteful than consing up a hundred closures on every call.)
	      cx.state = state;cx.stream = stream;cx.marked = null, cx.cc = cc;cx.style = style;

	      if (!state.lexical.hasOwnProperty("align")) state.lexical.align = true;

	      while (true) {
	        var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;
	        if (combinator(type, content)) {
	          while (cc.length && cc[cc.length - 1].lex) cc.pop()();
	          if (cx.marked) return cx.marked;
	          if (type == "variable" && inScope(state, content)) return "variable-2";
	          return style;
	        }
	      }
	    }

	    // Combinator utils

	    var cx = { state: null, column: null, marked: null, cc: null };
	    function pass() {
	      for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);
	    }
	    function cont() {
	      pass.apply(null, arguments);
	      return true;
	    }
	    function register(varname) {
	      function inList(list) {
	        for (var v = list; v; v = v.next) if (v.name == varname) return true;
	        return false;
	      }
	      var state = cx.state;
	      cx.marked = "def";
	      if (state.context) {
	        if (inList(state.localVars)) return;
	        state.localVars = { name: varname, next: state.localVars };
	      } else {
	        if (inList(state.globalVars)) return;
	        if (parserConfig.globalVars) state.globalVars = { name: varname, next: state.globalVars };
	      }
	    }

	    // Combinators

	    var defaultVars = { name: "this", next: { name: "arguments" } };
	    function pushcontext() {
	      cx.state.context = { prev: cx.state.context, vars: cx.state.localVars };
	      cx.state.localVars = defaultVars;
	    }
	    function popcontext() {
	      cx.state.localVars = cx.state.context.vars;
	      cx.state.context = cx.state.context.prev;
	    }
	    function pushlex(type, info) {
	      var result = function () {
	        var state = cx.state,
	            indent = state.indented;
	        if (state.lexical.type == "stat") indent = state.lexical.indented;else for (var outer = state.lexical; outer && outer.type == ")" && outer.align; outer = outer.prev) indent = outer.indented;
	        state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);
	      };
	      result.lex = true;
	      return result;
	    }
	    function poplex() {
	      var state = cx.state;
	      if (state.lexical.prev) {
	        if (state.lexical.type == ")") state.indented = state.lexical.indented;
	        state.lexical = state.lexical.prev;
	      }
	    }
	    poplex.lex = true;

	    function expect(wanted) {
	      function exp(type) {
	        if (type == wanted) return cont();else if (wanted == ";") return pass();else return cont(exp);
	      };
	      return exp;
	    }

	    function statement(type, value) {
	      if (type == "var") return cont(pushlex("vardef", value.length), vardef, expect(";"), poplex);
	      if (type == "keyword a") return cont(pushlex("form"), expression, statement, poplex);
	      if (type == "keyword b") return cont(pushlex("form"), statement, poplex);
	      if (type == "{") return cont(pushlex("}"), block, poplex);
	      if (type == ";") return cont();
	      if (type == "if") {
	        if (cx.state.lexical.info == "else" && cx.state.cc[cx.state.cc.length - 1] == poplex) cx.state.cc.pop()();
	        return cont(pushlex("form"), expression, statement, poplex, maybeelse);
	      }
	      if (type == "function") return cont(functiondef);
	      if (type == "for") return cont(pushlex("form"), forspec, statement, poplex);
	      if (type == "variable") return cont(pushlex("stat"), maybelabel);
	      if (type == "switch") return cont(pushlex("form"), expression, pushlex("}", "switch"), expect("{"), block, poplex, poplex);
	      if (type == "case") return cont(expression, expect(":"));
	      if (type == "default") return cont(expect(":"));
	      if (type == "catch") return cont(pushlex("form"), pushcontext, expect("("), funarg, expect(")"), statement, poplex, popcontext);
	      if (type == "class") return cont(pushlex("form"), className, poplex);
	      if (type == "export") return cont(pushlex("stat"), afterExport, poplex);
	      if (type == "import") return cont(pushlex("stat"), afterImport, poplex);
	      return pass(pushlex("stat"), expression, expect(";"), poplex);
	    }
	    function expression(type) {
	      return expressionInner(type, false);
	    }
	    function expressionNoComma(type) {
	      return expressionInner(type, true);
	    }
	    function expressionInner(type, noComma) {
	      if (cx.state.fatArrowAt == cx.stream.start) {
	        var body = noComma ? arrowBodyNoComma : arrowBody;
	        if (type == "(") return cont(pushcontext, pushlex(")"), commasep(pattern, ")"), poplex, expect("=>"), body, popcontext);else if (type == "variable") return pass(pushcontext, pattern, expect("=>"), body, popcontext);
	      }

	      var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;
	      if (atomicTypes.hasOwnProperty(type)) return cont(maybeop);
	      if (type == "function") return cont(functiondef, maybeop);
	      if (type == "keyword c") return cont(noComma ? maybeexpressionNoComma : maybeexpression);
	      if (type == "(") return cont(pushlex(")"), maybeexpression, comprehension, expect(")"), poplex, maybeop);
	      if (type == "operator" || type == "spread") return cont(noComma ? expressionNoComma : expression);
	      if (type == "[") return cont(pushlex("]"), arrayLiteral, poplex, maybeop);
	      if (type == "{") return contCommasep(objprop, "}", null, maybeop);
	      if (type == "quasi") return pass(quasi, maybeop);
	      if (type == "new") return cont(maybeTarget(noComma));
	      return cont();
	    }
	    function maybeexpression(type) {
	      if (type.match(/[;\}\)\],]/)) return pass();
	      return pass(expression);
	    }
	    function maybeexpressionNoComma(type) {
	      if (type.match(/[;\}\)\],]/)) return pass();
	      return pass(expressionNoComma);
	    }

	    function maybeoperatorComma(type, value) {
	      if (type == ",") return cont(expression);
	      return maybeoperatorNoComma(type, value, false);
	    }
	    function maybeoperatorNoComma(type, value, noComma) {
	      var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;
	      var expr = noComma == false ? expression : expressionNoComma;
	      if (type == "=>") return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);
	      if (type == "operator") {
	        if (/\+\+|--/.test(value)) return cont(me);
	        if (value == "?") return cont(expression, expect(":"), expr);
	        return cont(expr);
	      }
	      if (type == "quasi") {
	        return pass(quasi, me);
	      }
	      if (type == ";") return;
	      if (type == "(") return contCommasep(expressionNoComma, ")", "call", me);
	      if (type == ".") return cont(property, me);
	      if (type == "[") return cont(pushlex("]"), maybeexpression, expect("]"), poplex, me);
	    }
	    function quasi(type, value) {
	      if (type != "quasi") return pass();
	      if (value.slice(value.length - 2) != "${") return cont(quasi);
	      return cont(expression, continueQuasi);
	    }
	    function continueQuasi(type) {
	      if (type == "}") {
	        cx.marked = "string-2";
	        cx.state.tokenize = tokenQuasi;
	        return cont(quasi);
	      }
	    }
	    function arrowBody(type) {
	      findFatArrow(cx.stream, cx.state);
	      return pass(type == "{" ? statement : expression);
	    }
	    function arrowBodyNoComma(type) {
	      findFatArrow(cx.stream, cx.state);
	      return pass(type == "{" ? statement : expressionNoComma);
	    }
	    function maybeTarget(noComma) {
	      return function (type) {
	        if (type == ".") return cont(noComma ? targetNoComma : target);else return pass(noComma ? expressionNoComma : expression);
	      };
	    }
	    function target(_, value) {
	      if (value == "target") {
	        cx.marked = "keyword";return cont(maybeoperatorComma);
	      }
	    }
	    function targetNoComma(_, value) {
	      if (value == "target") {
	        cx.marked = "keyword";return cont(maybeoperatorNoComma);
	      }
	    }
	    function maybelabel(type) {
	      if (type == ":") return cont(poplex, statement);
	      return pass(maybeoperatorComma, expect(";"), poplex);
	    }
	    function property(type) {
	      if (type == "variable") {
	        cx.marked = "property";return cont();
	      }
	    }
	    function objprop(type, value) {
	      if (type == "variable" || cx.style == "keyword") {
	        cx.marked = "property";
	        if (value == "get" || value == "set") return cont(getterSetter);
	        return cont(afterprop);
	      } else if (type == "number" || type == "string") {
	        cx.marked = jsonldMode ? "property" : cx.style + " property";
	        return cont(afterprop);
	      } else if (type == "jsonld-keyword") {
	        return cont(afterprop);
	      } else if (type == "[") {
	        return cont(expression, expect("]"), afterprop);
	      } else if (type == "spread") {
	        return cont(expression);
	      }
	    }
	    function getterSetter(type) {
	      if (type != "variable") return pass(afterprop);
	      cx.marked = "property";
	      return cont(functiondef);
	    }
	    function afterprop(type) {
	      if (type == ":") return cont(expressionNoComma);
	      if (type == "(") return pass(functiondef);
	    }
	    function commasep(what, end) {
	      function proceed(type) {
	        if (type == ",") {
	          var lex = cx.state.lexical;
	          if (lex.info == "call") lex.pos = (lex.pos || 0) + 1;
	          return cont(what, proceed);
	        }
	        if (type == end) return cont();
	        return cont(expect(end));
	      }
	      return function (type) {
	        if (type == end) return cont();
	        return pass(what, proceed);
	      };
	    }
	    function contCommasep(what, end, info) {
	      for (var i = 3; i < arguments.length; i++) cx.cc.push(arguments[i]);
	      return cont(pushlex(end, info), commasep(what, end), poplex);
	    }
	    function block(type) {
	      if (type == "}") return cont();
	      return pass(statement, block);
	    }
	    function maybetype(type) {
	      if (isTS && type == ":") return cont(typedef);
	    }
	    function maybedefault(_, value) {
	      if (value == "=") return cont(expressionNoComma);
	    }
	    function typedef(type) {
	      if (type == "variable") {
	        cx.marked = "variable-3";return cont();
	      }
	    }
	    function vardef() {
	      return pass(pattern, maybetype, maybeAssign, vardefCont);
	    }
	    function pattern(type, value) {
	      if (type == "variable") {
	        register(value);return cont();
	      }
	      if (type == "spread") return cont(pattern);
	      if (type == "[") return contCommasep(pattern, "]");
	      if (type == "{") return contCommasep(proppattern, "}");
	    }
	    function proppattern(type, value) {
	      if (type == "variable" && !cx.stream.match(/^\s*:/, false)) {
	        register(value);
	        return cont(maybeAssign);
	      }
	      if (type == "variable") cx.marked = "property";
	      if (type == "spread") return cont(pattern);
	      return cont(expect(":"), pattern, maybeAssign);
	    }
	    function maybeAssign(_type, value) {
	      if (value == "=") return cont(expressionNoComma);
	    }
	    function vardefCont(type) {
	      if (type == ",") return cont(vardef);
	    }
	    function maybeelse(type, value) {
	      if (type == "keyword b" && value == "else") return cont(pushlex("form", "else"), statement, poplex);
	    }
	    function forspec(type) {
	      if (type == "(") return cont(pushlex(")"), forspec1, expect(")"), poplex);
	    }
	    function forspec1(type) {
	      if (type == "var") return cont(vardef, expect(";"), forspec2);
	      if (type == ";") return cont(forspec2);
	      if (type == "variable") return cont(formaybeinof);
	      return pass(expression, expect(";"), forspec2);
	    }
	    function formaybeinof(_type, value) {
	      if (value == "in" || value == "of") {
	        cx.marked = "keyword";return cont(expression);
	      }
	      return cont(maybeoperatorComma, forspec2);
	    }
	    function forspec2(type, value) {
	      if (type == ";") return cont(forspec3);
	      if (value == "in" || value == "of") {
	        cx.marked = "keyword";return cont(expression);
	      }
	      return pass(expression, expect(";"), forspec3);
	    }
	    function forspec3(type) {
	      if (type != ")") cont(expression);
	    }
	    function functiondef(type, value) {
	      if (value == "*") {
	        cx.marked = "keyword";return cont(functiondef);
	      }
	      if (type == "variable") {
	        register(value);return cont(functiondef);
	      }
	      if (type == "(") return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, statement, popcontext);
	    }
	    function funarg(type) {
	      if (type == "spread") return cont(funarg);
	      return pass(pattern, maybetype, maybedefault);
	    }
	    function className(type, value) {
	      if (type == "variable") {
	        register(value);return cont(classNameAfter);
	      }
	    }
	    function classNameAfter(type, value) {
	      if (value == "extends") return cont(expression, classNameAfter);
	      if (type == "{") return cont(pushlex("}"), classBody, poplex);
	    }
	    function classBody(type, value) {
	      if (type == "variable" || cx.style == "keyword") {
	        if (value == "static") {
	          cx.marked = "keyword";
	          return cont(classBody);
	        }
	        cx.marked = "property";
	        if (value == "get" || value == "set") return cont(classGetterSetter, functiondef, classBody);
	        return cont(functiondef, classBody);
	      }
	      if (value == "*") {
	        cx.marked = "keyword";
	        return cont(classBody);
	      }
	      if (type == ";") return cont(classBody);
	      if (type == "}") return cont();
	    }
	    function classGetterSetter(type) {
	      if (type != "variable") return pass();
	      cx.marked = "property";
	      return cont();
	    }
	    function afterExport(_type, value) {
	      if (value == "*") {
	        cx.marked = "keyword";return cont(maybeFrom, expect(";"));
	      }
	      if (value == "default") {
	        cx.marked = "keyword";return cont(expression, expect(";"));
	      }
	      return pass(statement);
	    }
	    function afterImport(type) {
	      if (type == "string") return cont();
	      return pass(importSpec, maybeFrom);
	    }
	    function importSpec(type, value) {
	      if (type == "{") return contCommasep(importSpec, "}");
	      if (type == "variable") register(value);
	      if (value == "*") cx.marked = "keyword";
	      return cont(maybeAs);
	    }
	    function maybeAs(_type, value) {
	      if (value == "as") {
	        cx.marked = "keyword";return cont(importSpec);
	      }
	    }
	    function maybeFrom(_type, value) {
	      if (value == "from") {
	        cx.marked = "keyword";return cont(expression);
	      }
	    }
	    function arrayLiteral(type) {
	      if (type == "]") return cont();
	      return pass(expressionNoComma, maybeArrayComprehension);
	    }
	    function maybeArrayComprehension(type) {
	      if (type == "for") return pass(comprehension, expect("]"));
	      if (type == ",") return cont(commasep(maybeexpressionNoComma, "]"));
	      return pass(commasep(expressionNoComma, "]"));
	    }
	    function comprehension(type) {
	      if (type == "for") return cont(forspec, comprehension);
	      if (type == "if") return cont(expression, comprehension);
	    }

	    function isContinuedStatement(state, textAfter) {
	      return state.lastType == "operator" || state.lastType == "," || isOperatorChar.test(textAfter.charAt(0)) || /[,.]/.test(textAfter.charAt(0));
	    }

	    // Interface

	    return {
	      startState: function (basecolumn) {
	        var state = {
	          tokenize: tokenBase,
	          lastType: "sof",
	          cc: [],
	          lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, "block", false),
	          localVars: parserConfig.localVars,
	          context: parserConfig.localVars && { vars: parserConfig.localVars },
	          indented: 0
	        };
	        if (parserConfig.globalVars && typeof parserConfig.globalVars == "object") state.globalVars = parserConfig.globalVars;
	        return state;
	      },

	      token: function (stream, state) {
	        if (stream.sol()) {
	          if (!state.lexical.hasOwnProperty("align")) state.lexical.align = false;
	          state.indented = stream.indentation();
	          findFatArrow(stream, state);
	        }
	        if (state.tokenize != tokenComment && stream.eatSpace()) return null;
	        var style = state.tokenize(stream, state);
	        if (type == "comment") return style;
	        state.lastType = type == "operator" && (content == "++" || content == "--") ? "incdec" : type;
	        return parseJS(state, style, type, content, stream);
	      },

	      indent: function (state, textAfter) {
	        if (state.tokenize == tokenComment) return CodeMirror.Pass;
	        if (state.tokenize != tokenBase) return 0;
	        var firstChar = textAfter && textAfter.charAt(0),
	            lexical = state.lexical;
	        // Kludge to prevent 'maybelse' from blocking lexical scope pops
	        if (!/^\s*else\b/.test(textAfter)) for (var i = state.cc.length - 1; i >= 0; --i) {
	          var c = state.cc[i];
	          if (c == poplex) lexical = lexical.prev;else if (c != maybeelse) break;
	        }
	        if (lexical.type == "stat" && firstChar == "}") lexical = lexical.prev;
	        if (statementIndent && lexical.type == ")" && lexical.prev.type == "stat") lexical = lexical.prev;
	        var type = lexical.type,
	            closing = firstChar == type;

	        if (type == "vardef") return lexical.indented + (state.lastType == "operator" || state.lastType == "," ? lexical.info + 1 : 0);else if (type == "form" && firstChar == "{") return lexical.indented;else if (type == "form") return lexical.indented + indentUnit;else if (type == "stat") return lexical.indented + (isContinuedStatement(state, textAfter) ? statementIndent || indentUnit : 0);else if (lexical.info == "switch" && !closing && parserConfig.doubleIndentSwitch != false) return lexical.indented + (/^(?:case|default)\b/.test(textAfter) ? indentUnit : 2 * indentUnit);else if (lexical.align) return lexical.column + (closing ? 0 : 1);else return lexical.indented + (closing ? 0 : indentUnit);
	      },

	      electricInput: /^\s*(?:case .*?:|default:|\{|\})$/,
	      blockCommentStart: jsonMode ? null : "/*",
	      blockCommentEnd: jsonMode ? null : "*/",
	      lineComment: jsonMode ? null : "//",
	      fold: "brace",
	      closeBrackets: "()[]{}''\"\"``",

	      helperType: jsonMode ? "json" : "javascript",
	      jsonldMode: jsonldMode,
	      jsonMode: jsonMode
	    };
	  });

	  CodeMirror.registerHelper("wordChars", "javascript", /[\w$]/);

	  CodeMirror.defineMIME("text/javascript", "javascript");
	  CodeMirror.defineMIME("text/ecmascript", "javascript");
	  CodeMirror.defineMIME("application/javascript", "javascript");
	  CodeMirror.defineMIME("application/x-javascript", "javascript");
	  CodeMirror.defineMIME("application/ecmascript", "javascript");
	  CodeMirror.defineMIME("application/json", { name: "javascript", json: true });
	  CodeMirror.defineMIME("application/x-json", { name: "javascript", json: true });
	  CodeMirror.defineMIME("application/ld+json", { name: "javascript", jsonld: true });
	  CodeMirror.defineMIME("text/typescript", { name: "javascript", typescript: true });
	  CodeMirror.defineMIME("application/typescript", { name: "javascript", typescript: true });
	});

/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	// CodeMirror, copyright (c) by Marijn Haverbeke and others
	// Distributed under an MIT license: http://codemirror.net/LICENSE

	(function (mod) {
	  if (true) // CommonJS
	    mod(__webpack_require__(129));else if (typeof define == "function" && define.amd) // AMD
	    define(["../../lib/codemirror"], mod);else // Plain browser env
	    mod(CodeMirror);
	})(function (CodeMirror) {
	  "use strict";

	  CodeMirror.defineMode("xml", function (config, parserConfig) {
	    var indentUnit = config.indentUnit;
	    var multilineTagIndentFactor = parserConfig.multilineTagIndentFactor || 1;
	    var multilineTagIndentPastTag = parserConfig.multilineTagIndentPastTag;
	    if (multilineTagIndentPastTag == null) multilineTagIndentPastTag = true;

	    var Kludges = parserConfig.htmlMode ? {
	      autoSelfClosers: { 'area': true, 'base': true, 'br': true, 'col': true, 'command': true,
	        'embed': true, 'frame': true, 'hr': true, 'img': true, 'input': true,
	        'keygen': true, 'link': true, 'meta': true, 'param': true, 'source': true,
	        'track': true, 'wbr': true, 'menuitem': true },
	      implicitlyClosed: { 'dd': true, 'li': true, 'optgroup': true, 'option': true, 'p': true,
	        'rp': true, 'rt': true, 'tbody': true, 'td': true, 'tfoot': true,
	        'th': true, 'tr': true },
	      contextGrabbers: {
	        'dd': { 'dd': true, 'dt': true },
	        'dt': { 'dd': true, 'dt': true },
	        'li': { 'li': true },
	        'option': { 'option': true, 'optgroup': true },
	        'optgroup': { 'optgroup': true },
	        'p': { 'address': true, 'article': true, 'aside': true, 'blockquote': true, 'dir': true,
	          'div': true, 'dl': true, 'fieldset': true, 'footer': true, 'form': true,
	          'h1': true, 'h2': true, 'h3': true, 'h4': true, 'h5': true, 'h6': true,
	          'header': true, 'hgroup': true, 'hr': true, 'menu': true, 'nav': true, 'ol': true,
	          'p': true, 'pre': true, 'section': true, 'table': true, 'ul': true },
	        'rp': { 'rp': true, 'rt': true },
	        'rt': { 'rp': true, 'rt': true },
	        'tbody': { 'tbody': true, 'tfoot': true },
	        'td': { 'td': true, 'th': true },
	        'tfoot': { 'tbody': true },
	        'th': { 'td': true, 'th': true },
	        'thead': { 'tbody': true, 'tfoot': true },
	        'tr': { 'tr': true }
	      },
	      doNotIndent: { "pre": true },
	      allowUnquoted: true,
	      allowMissing: true,
	      caseFold: true
	    } : {
	      autoSelfClosers: {},
	      implicitlyClosed: {},
	      contextGrabbers: {},
	      doNotIndent: {},
	      allowUnquoted: false,
	      allowMissing: false,
	      caseFold: false
	    };
	    var alignCDATA = parserConfig.alignCDATA;

	    // Return variables for tokenizers
	    var type, setStyle;

	    function inText(stream, state) {
	      function chain(parser) {
	        state.tokenize = parser;
	        return parser(stream, state);
	      }

	      var ch = stream.next();
	      if (ch == "<") {
	        if (stream.eat("!")) {
	          if (stream.eat("[")) {
	            if (stream.match("CDATA[")) return chain(inBlock("atom", "]]>"));else return null;
	          } else if (stream.match("--")) {
	            return chain(inBlock("comment", "-->"));
	          } else if (stream.match("DOCTYPE", true, true)) {
	            stream.eatWhile(/[\w\._\-]/);
	            return chain(doctype(1));
	          } else {
	            return null;
	          }
	        } else if (stream.eat("?")) {
	          stream.eatWhile(/[\w\._\-]/);
	          state.tokenize = inBlock("meta", "?>");
	          return "meta";
	        } else {
	          type = stream.eat("/") ? "closeTag" : "openTag";
	          state.tokenize = inTag;
	          return "tag bracket";
	        }
	      } else if (ch == "&") {
	        var ok;
	        if (stream.eat("#")) {
	          if (stream.eat("x")) {
	            ok = stream.eatWhile(/[a-fA-F\d]/) && stream.eat(";");
	          } else {
	            ok = stream.eatWhile(/[\d]/) && stream.eat(";");
	          }
	        } else {
	          ok = stream.eatWhile(/[\w\.\-:]/) && stream.eat(";");
	        }
	        return ok ? "atom" : "error";
	      } else {
	        stream.eatWhile(/[^&<]/);
	        return null;
	      }
	    }
	    inText.isInText = true;

	    function inTag(stream, state) {
	      var ch = stream.next();
	      if (ch == ">" || ch == "/" && stream.eat(">")) {
	        state.tokenize = inText;
	        type = ch == ">" ? "endTag" : "selfcloseTag";
	        return "tag bracket";
	      } else if (ch == "=") {
	        type = "equals";
	        return null;
	      } else if (ch == "<") {
	        state.tokenize = inText;
	        state.state = baseState;
	        state.tagName = state.tagStart = null;
	        var next = state.tokenize(stream, state);
	        return next ? next + " tag error" : "tag error";
	      } else if (/[\'\"]/.test(ch)) {
	        state.tokenize = inAttribute(ch);
	        state.stringStartCol = stream.column();
	        return state.tokenize(stream, state);
	      } else {
	        stream.match(/^[^\s\u00a0=<>\"\']*[^\s\u00a0=<>\"\'\/]/);
	        return "word";
	      }
	    }

	    function inAttribute(quote) {
	      var closure = function (stream, state) {
	        while (!stream.eol()) {
	          if (stream.next() == quote) {
	            state.tokenize = inTag;
	            break;
	          }
	        }
	        return "string";
	      };
	      closure.isInAttribute = true;
	      return closure;
	    }

	    function inBlock(style, terminator) {
	      return function (stream, state) {
	        while (!stream.eol()) {
	          if (stream.match(terminator)) {
	            state.tokenize = inText;
	            break;
	          }
	          stream.next();
	        }
	        return style;
	      };
	    }
	    function doctype(depth) {
	      return function (stream, state) {
	        var ch;
	        while ((ch = stream.next()) != null) {
	          if (ch == "<") {
	            state.tokenize = doctype(depth + 1);
	            return state.tokenize(stream, state);
	          } else if (ch == ">") {
	            if (depth == 1) {
	              state.tokenize = inText;
	              break;
	            } else {
	              state.tokenize = doctype(depth - 1);
	              return state.tokenize(stream, state);
	            }
	          }
	        }
	        return "meta";
	      };
	    }

	    function Context(state, tagName, startOfLine) {
	      this.prev = state.context;
	      this.tagName = tagName;
	      this.indent = state.indented;
	      this.startOfLine = startOfLine;
	      if (Kludges.doNotIndent.hasOwnProperty(tagName) || state.context && state.context.noIndent) this.noIndent = true;
	    }
	    function popContext(state) {
	      if (state.context) state.context = state.context.prev;
	    }
	    function maybePopContext(state, nextTagName) {
	      var parentTagName;
	      while (true) {
	        if (!state.context) {
	          return;
	        }
	        parentTagName = state.context.tagName;
	        if (!Kludges.contextGrabbers.hasOwnProperty(parentTagName) || !Kludges.contextGrabbers[parentTagName].hasOwnProperty(nextTagName)) {
	          return;
	        }
	        popContext(state);
	      }
	    }

	    function baseState(type, stream, state) {
	      if (type == "openTag") {
	        state.tagStart = stream.column();
	        return tagNameState;
	      } else if (type == "closeTag") {
	        return closeTagNameState;
	      } else {
	        return baseState;
	      }
	    }
	    function tagNameState(type, stream, state) {
	      if (type == "word") {
	        state.tagName = stream.current();
	        setStyle = "tag";
	        return attrState;
	      } else {
	        setStyle = "error";
	        return tagNameState;
	      }
	    }
	    function closeTagNameState(type, stream, state) {
	      if (type == "word") {
	        var tagName = stream.current();
	        if (state.context && state.context.tagName != tagName && Kludges.implicitlyClosed.hasOwnProperty(state.context.tagName)) popContext(state);
	        if (state.context && state.context.tagName == tagName) {
	          setStyle = "tag";
	          return closeState;
	        } else {
	          setStyle = "tag error";
	          return closeStateErr;
	        }
	      } else {
	        setStyle = "error";
	        return closeStateErr;
	      }
	    }

	    function closeState(type, _stream, state) {
	      if (type != "endTag") {
	        setStyle = "error";
	        return closeState;
	      }
	      popContext(state);
	      return baseState;
	    }
	    function closeStateErr(type, stream, state) {
	      setStyle = "error";
	      return closeState(type, stream, state);
	    }

	    function attrState(type, _stream, state) {
	      if (type == "word") {
	        setStyle = "attribute";
	        return attrEqState;
	      } else if (type == "endTag" || type == "selfcloseTag") {
	        var tagName = state.tagName,
	            tagStart = state.tagStart;
	        state.tagName = state.tagStart = null;
	        if (type == "selfcloseTag" || Kludges.autoSelfClosers.hasOwnProperty(tagName)) {
	          maybePopContext(state, tagName);
	        } else {
	          maybePopContext(state, tagName);
	          state.context = new Context(state, tagName, tagStart == state.indented);
	        }
	        return baseState;
	      }
	      setStyle = "error";
	      return attrState;
	    }
	    function attrEqState(type, stream, state) {
	      if (type == "equals") return attrValueState;
	      if (!Kludges.allowMissing) setStyle = "error";
	      return attrState(type, stream, state);
	    }
	    function attrValueState(type, stream, state) {
	      if (type == "string") return attrContinuedState;
	      if (type == "word" && Kludges.allowUnquoted) {
	        setStyle = "string";return attrState;
	      }
	      setStyle = "error";
	      return attrState(type, stream, state);
	    }
	    function attrContinuedState(type, stream, state) {
	      if (type == "string") return attrContinuedState;
	      return attrState(type, stream, state);
	    }

	    return {
	      startState: function () {
	        return { tokenize: inText,
	          state: baseState,
	          indented: 0,
	          tagName: null, tagStart: null,
	          context: null };
	      },

	      token: function (stream, state) {
	        if (!state.tagName && stream.sol()) state.indented = stream.indentation();

	        if (stream.eatSpace()) return null;
	        type = null;
	        var style = state.tokenize(stream, state);
	        if ((style || type) && style != "comment") {
	          setStyle = null;
	          state.state = state.state(type || style, stream, state);
	          if (setStyle) style = setStyle == "error" ? style + " error" : setStyle;
	        }
	        return style;
	      },

	      indent: function (state, textAfter, fullLine) {
	        var context = state.context;
	        // Indent multi-line strings (e.g. css).
	        if (state.tokenize.isInAttribute) {
	          if (state.tagStart == state.indented) return state.stringStartCol + 1;else return state.indented + indentUnit;
	        }
	        if (context && context.noIndent) return CodeMirror.Pass;
	        if (state.tokenize != inTag && state.tokenize != inText) return fullLine ? fullLine.match(/^(\s*)/)[0].length : 0;
	        // Indent the starts of attribute names.
	        if (state.tagName) {
	          if (multilineTagIndentPastTag) return state.tagStart + state.tagName.length + 2;else return state.tagStart + indentUnit * multilineTagIndentFactor;
	        }
	        if (alignCDATA && /<!\[CDATA\[/.test(textAfter)) return 0;
	        var tagAfter = textAfter && /^<(\/)?([\w_:\.-]*)/.exec(textAfter);
	        if (tagAfter && tagAfter[1]) {
	          // Closing tag spotted
	          while (context) {
	            if (context.tagName == tagAfter[2]) {
	              context = context.prev;
	              break;
	            } else if (Kludges.implicitlyClosed.hasOwnProperty(context.tagName)) {
	              context = context.prev;
	            } else {
	              break;
	            }
	          }
	        } else if (tagAfter) {
	          // Opening tag spotted
	          while (context) {
	            var grabbers = Kludges.contextGrabbers[context.tagName];
	            if (grabbers && grabbers.hasOwnProperty(tagAfter[2])) context = context.prev;else break;
	          }
	        }
	        while (context && !context.startOfLine) context = context.prev;
	        if (context) return context.indent + indentUnit;else return 0;
	      },

	      electricInput: /<\/[\s\w:]+>$/,
	      blockCommentStart: "<!--",
	      blockCommentEnd: "-->",

	      configuration: parserConfig.htmlMode ? "html" : "xml",
	      helperType: parserConfig.htmlMode ? "html" : "xml"
	    };
	  });

	  CodeMirror.defineMIME("text/xml", "xml");
	  CodeMirror.defineMIME("application/xml", "xml");
	  if (!CodeMirror.mimeModes.hasOwnProperty("text/html")) CodeMirror.defineMIME("text/html", { name: "xml", htmlMode: true });
	});

/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	// CodeMirror, copyright (c) by Marijn Haverbeke and others
	// Distributed under an MIT license: http://codemirror.net/LICENSE

	(function (mod) {
	  if (true) // CommonJS
	    mod(__webpack_require__(129), __webpack_require__(131), __webpack_require__(133));else if (typeof define == "function" && define.amd) // AMD
	    define(["../../lib/codemirror", "../xml/xml", "../meta"], mod);else // Plain browser env
	    mod(CodeMirror);
	})(function (CodeMirror) {
	  "use strict";

	  CodeMirror.defineMode("markdown", function (cmCfg, modeCfg) {

	    var htmlFound = CodeMirror.modes.hasOwnProperty("xml");
	    var htmlMode = CodeMirror.getMode(cmCfg, htmlFound ? { name: "xml", htmlMode: true } : "text/plain");

	    function getMode(name) {
	      if (CodeMirror.findModeByName) {
	        var found = CodeMirror.findModeByName(name);
	        if (found) name = found.mime || found.mimes[0];
	      }
	      var mode = CodeMirror.getMode(cmCfg, name);
	      return mode.name == "null" ? null : mode;
	    }

	    // Should characters that affect highlighting be highlighted separate?
	    // Does not include characters that will be output (such as `1.` and `-` for lists)
	    if (modeCfg.highlightFormatting === undefined) modeCfg.highlightFormatting = false;

	    // Maximum number of nested blockquotes. Set to 0 for infinite nesting.
	    // Excess `>` will emit `error` token.
	    if (modeCfg.maxBlockquoteDepth === undefined) modeCfg.maxBlockquoteDepth = 0;

	    // Should underscores in words open/close em/strong?
	    if (modeCfg.underscoresBreakWords === undefined) modeCfg.underscoresBreakWords = true;

	    // Use `fencedCodeBlocks` to configure fenced code blocks. false to
	    // disable, string to specify a precise regexp that the fence should
	    // match, and true to allow three or more backticks or tildes (as
	    // per CommonMark).

	    // Turn on task lists? ("- [ ] " and "- [x] ")
	    if (modeCfg.taskLists === undefined) modeCfg.taskLists = false;

	    // Turn on strikethrough syntax
	    if (modeCfg.strikethrough === undefined) modeCfg.strikethrough = false;

	    // Allow token types to be overridden by user-provided token types.
	    if (modeCfg.tokenTypeOverrides === undefined) modeCfg.tokenTypeOverrides = {};

	    var codeDepth = 0;

	    var tokenTypes = {
	      header: "header",
	      code: "comment",
	      quote: "quote",
	      list1: "variable-2",
	      list2: "variable-3",
	      list3: "keyword",
	      hr: "hr",
	      image: "tag",
	      formatting: "formatting",
	      linkInline: "link",
	      linkEmail: "link",
	      linkText: "link",
	      linkHref: "string",
	      em: "em",
	      strong: "strong",
	      strikethrough: "strikethrough"
	    };

	    for (var tokenType in tokenTypes) {
	      if (tokenTypes.hasOwnProperty(tokenType) && modeCfg.tokenTypeOverrides[tokenType]) {
	        tokenTypes[tokenType] = modeCfg.tokenTypeOverrides[tokenType];
	      }
	    }

	    var hrRE = /^([*\-_])(?:\s*\1){2,}\s*$/,
	        ulRE = /^[*\-+]\s+/,
	        olRE = /^[0-9]+([.)])\s+/,
	        taskListRE = /^\[(x| )\](?=\s)/ // Must follow ulRE or olRE
	    ,
	        atxHeaderRE = modeCfg.allowAtxHeaderWithoutSpace ? /^(#+)/ : /^(#+)(?: |$)/,
	        setextHeaderRE = /^ *(?:\={1,}|-{1,})\s*$/,
	        textRE = /^[^#!\[\]*_\\<>` "'(~]+/,
	        fencedCodeRE = new RegExp("^(" + (modeCfg.fencedCodeBlocks === true ? "~~~+|```+" : modeCfg.fencedCodeBlocks) + ")[ \\t]*([\\w+#]*)");

	    function switchInline(stream, state, f) {
	      state.f = state.inline = f;
	      return f(stream, state);
	    }

	    function switchBlock(stream, state, f) {
	      state.f = state.block = f;
	      return f(stream, state);
	    }

	    function lineIsEmpty(line) {
	      return !line || !/\S/.test(line.string);
	    }

	    // Blocks

	    function blankLine(state) {
	      // Reset linkTitle state
	      state.linkTitle = false;
	      // Reset EM state
	      state.em = false;
	      // Reset STRONG state
	      state.strong = false;
	      // Reset strikethrough state
	      state.strikethrough = false;
	      // Reset state.quote
	      state.quote = 0;
	      // Reset state.indentedCode
	      state.indentedCode = false;
	      if (!htmlFound && state.f == htmlBlock) {
	        state.f = inlineNormal;
	        state.block = blockNormal;
	      }
	      // Reset state.trailingSpace
	      state.trailingSpace = 0;
	      state.trailingSpaceNewLine = false;
	      // Mark this line as blank
	      state.prevLine = state.thisLine;
	      state.thisLine = null;
	      return null;
	    }

	    function blockNormal(stream, state) {

	      var sol = stream.sol();

	      var prevLineIsList = state.list !== false,
	          prevLineIsIndentedCode = state.indentedCode;

	      state.indentedCode = false;

	      if (prevLineIsList) {
	        if (state.indentationDiff >= 0) {
	          // Continued list
	          if (state.indentationDiff < 4) {
	            // Only adjust indentation if *not* a code block
	            state.indentation -= state.indentationDiff;
	          }
	          state.list = null;
	        } else if (state.indentation > 0) {
	          state.list = null;
	          state.listDepth = Math.floor(state.indentation / 4);
	        } else {
	          // No longer a list
	          state.list = false;
	          state.listDepth = 0;
	        }
	      }

	      var match = null;
	      if (state.indentationDiff >= 4) {
	        stream.skipToEnd();
	        if (prevLineIsIndentedCode || lineIsEmpty(state.prevLine)) {
	          state.indentation -= 4;
	          state.indentedCode = true;
	          return tokenTypes.code;
	        } else {
	          return null;
	        }
	      } else if (stream.eatSpace()) {
	        return null;
	      } else if ((match = stream.match(atxHeaderRE)) && match[1].length <= 6) {
	        state.header = match[1].length;
	        if (modeCfg.highlightFormatting) state.formatting = "header";
	        state.f = state.inline;
	        return getType(state);
	      } else if (!lineIsEmpty(state.prevLine) && !state.quote && !prevLineIsList && !prevLineIsIndentedCode && (match = stream.match(setextHeaderRE))) {
	        state.header = match[0].charAt(0) == '=' ? 1 : 2;
	        if (modeCfg.highlightFormatting) state.formatting = "header";
	        state.f = state.inline;
	        return getType(state);
	      } else if (stream.eat('>')) {
	        state.quote = sol ? 1 : state.quote + 1;
	        if (modeCfg.highlightFormatting) state.formatting = "quote";
	        stream.eatSpace();
	        return getType(state);
	      } else if (stream.peek() === '[') {
	        return switchInline(stream, state, footnoteLink);
	      } else if (stream.match(hrRE, true)) {
	        state.hr = true;
	        return tokenTypes.hr;
	      } else if ((lineIsEmpty(state.prevLine) || prevLineIsList) && (stream.match(ulRE, false) || stream.match(olRE, false))) {
	        var listType = null;
	        if (stream.match(ulRE, true)) {
	          listType = 'ul';
	        } else {
	          stream.match(olRE, true);
	          listType = 'ol';
	        }
	        state.indentation = stream.column() + stream.current().length;
	        state.list = true;
	        state.listDepth++;
	        if (modeCfg.taskLists && stream.match(taskListRE, false)) {
	          state.taskList = true;
	        }
	        state.f = state.inline;
	        if (modeCfg.highlightFormatting) state.formatting = ["list", "list-" + listType];
	        return getType(state);
	      } else if (modeCfg.fencedCodeBlocks && (match = stream.match(fencedCodeRE, true))) {
	        state.fencedChars = match[1];
	        // try switching mode
	        state.localMode = getMode(match[2]);
	        if (state.localMode) state.localState = state.localMode.startState();
	        state.f = state.block = local;
	        if (modeCfg.highlightFormatting) state.formatting = "code-block";
	        state.code = true;
	        return getType(state);
	      }

	      return switchInline(stream, state, state.inline);
	    }

	    function htmlBlock(stream, state) {
	      var style = htmlMode.token(stream, state.htmlState);
	      if (htmlFound && state.htmlState.tagStart === null && !state.htmlState.context && state.htmlState.tokenize.isInText || state.md_inside && stream.current().indexOf(">") > -1) {
	        state.f = inlineNormal;
	        state.block = blockNormal;
	        state.htmlState = null;
	      }
	      return style;
	    }

	    function local(stream, state) {
	      if (stream.sol() && state.fencedChars && stream.match(state.fencedChars, false)) {
	        state.localMode = state.localState = null;
	        state.f = state.block = leavingLocal;
	        return null;
	      } else if (state.localMode) {
	        return state.localMode.token(stream, state.localState);
	      } else {
	        stream.skipToEnd();
	        return tokenTypes.code;
	      }
	    }

	    function leavingLocal(stream, state) {
	      stream.match(state.fencedChars);
	      state.block = blockNormal;
	      state.f = inlineNormal;
	      state.fencedChars = null;
	      if (modeCfg.highlightFormatting) state.formatting = "code-block";
	      state.code = true;
	      var returnType = getType(state);
	      state.code = false;
	      return returnType;
	    }

	    // Inline
	    function getType(state) {
	      var styles = [];

	      if (state.formatting) {
	        styles.push(tokenTypes.formatting);

	        if (typeof state.formatting === "string") state.formatting = [state.formatting];

	        for (var i = 0; i < state.formatting.length; i++) {
	          styles.push(tokenTypes.formatting + "-" + state.formatting[i]);

	          if (state.formatting[i] === "header") {
	            styles.push(tokenTypes.formatting + "-" + state.formatting[i] + "-" + state.header);
	          }

	          // Add `formatting-quote` and `formatting-quote-#` for blockquotes
	          // Add `error` instead if the maximum blockquote nesting depth is passed
	          if (state.formatting[i] === "quote") {
	            if (!modeCfg.maxBlockquoteDepth || modeCfg.maxBlockquoteDepth >= state.quote) {
	              styles.push(tokenTypes.formatting + "-" + state.formatting[i] + "-" + state.quote);
	            } else {
	              styles.push("error");
	            }
	          }
	        }
	      }

	      if (state.taskOpen) {
	        styles.push("meta");
	        return styles.length ? styles.join(' ') : null;
	      }
	      if (state.taskClosed) {
	        styles.push("property");
	        return styles.length ? styles.join(' ') : null;
	      }

	      if (state.linkHref) {
	        styles.push(tokenTypes.linkHref, "url");
	      } else {
	        // Only apply inline styles to non-url text
	        if (state.strong) {
	          styles.push(tokenTypes.strong);
	        }
	        if (state.em) {
	          styles.push(tokenTypes.em);
	        }
	        if (state.strikethrough) {
	          styles.push(tokenTypes.strikethrough);
	        }
	        if (state.linkText) {
	          styles.push(tokenTypes.linkText);
	        }
	        if (state.code) {
	          styles.push(tokenTypes.code);
	        }
	      }

	      if (state.header) {
	        styles.push(tokenTypes.header, tokenTypes.header + "-" + state.header);
	      }

	      if (state.quote) {
	        styles.push(tokenTypes.quote);

	        // Add `quote-#` where the maximum for `#` is modeCfg.maxBlockquoteDepth
	        if (!modeCfg.maxBlockquoteDepth || modeCfg.maxBlockquoteDepth >= state.quote) {
	          styles.push(tokenTypes.quote + "-" + state.quote);
	        } else {
	          styles.push(tokenTypes.quote + "-" + modeCfg.maxBlockquoteDepth);
	        }
	      }

	      if (state.list !== false) {
	        var listMod = (state.listDepth - 1) % 3;
	        if (!listMod) {
	          styles.push(tokenTypes.list1);
	        } else if (listMod === 1) {
	          styles.push(tokenTypes.list2);
	        } else {
	          styles.push(tokenTypes.list3);
	        }
	      }

	      if (state.trailingSpaceNewLine) {
	        styles.push("trailing-space-new-line");
	      } else if (state.trailingSpace) {
	        styles.push("trailing-space-" + (state.trailingSpace % 2 ? "a" : "b"));
	      }

	      return styles.length ? styles.join(' ') : null;
	    }

	    function handleText(stream, state) {
	      if (stream.match(textRE, true)) {
	        return getType(state);
	      }
	      return undefined;
	    }

	    function inlineNormal(stream, state) {
	      var style = state.text(stream, state);
	      if (typeof style !== 'undefined') return style;

	      if (state.list) {
	        // List marker (*, +, -, 1., etc)
	        state.list = null;
	        return getType(state);
	      }

	      if (state.taskList) {
	        var taskOpen = stream.match(taskListRE, true)[1] !== "x";
	        if (taskOpen) state.taskOpen = true;else state.taskClosed = true;
	        if (modeCfg.highlightFormatting) state.formatting = "task";
	        state.taskList = false;
	        return getType(state);
	      }

	      state.taskOpen = false;
	      state.taskClosed = false;

	      if (state.header && stream.match(/^#+$/, true)) {
	        if (modeCfg.highlightFormatting) state.formatting = "header";
	        return getType(state);
	      }

	      // Get sol() value now, before character is consumed
	      var sol = stream.sol();

	      var ch = stream.next();

	      if (ch === '\\') {
	        stream.next();
	        if (modeCfg.highlightFormatting) {
	          var type = getType(state);
	          var formattingEscape = tokenTypes.formatting + "-escape";
	          return type ? type + " " + formattingEscape : formattingEscape;
	        }
	      }

	      // Matches link titles present on next line
	      if (state.linkTitle) {
	        state.linkTitle = false;
	        var matchCh = ch;
	        if (ch === '(') {
	          matchCh = ')';
	        }
	        matchCh = (matchCh + '').replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1");
	        var regex = '^\\s*(?:[^' + matchCh + '\\\\]+|\\\\\\\\|\\\\.)' + matchCh;
	        if (stream.match(new RegExp(regex), true)) {
	          return tokenTypes.linkHref;
	        }
	      }

	      // If this block is changed, it may need to be updated in GFM mode
	      if (ch === '`') {
	        var previousFormatting = state.formatting;
	        if (modeCfg.highlightFormatting) state.formatting = "code";
	        var t = getType(state);
	        var before = stream.pos;
	        stream.eatWhile('`');
	        var difference = 1 + stream.pos - before;
	        if (!state.code) {
	          codeDepth = difference;
	          state.code = true;
	          return getType(state);
	        } else {
	          if (difference === codeDepth) {
	            // Must be exact
	            state.code = false;
	            return t;
	          }
	          state.formatting = previousFormatting;
	          return getType(state);
	        }
	      } else if (state.code) {
	        return getType(state);
	      }

	      if (ch === '!' && stream.match(/\[[^\]]*\] ?(?:\(|\[)/, false)) {
	        stream.match(/\[[^\]]*\]/);
	        state.inline = state.f = linkHref;
	        return tokenTypes.image;
	      }

	      if (ch === '[' && stream.match(/.*\](\(.*\)| ?\[.*\])/, false)) {
	        state.linkText = true;
	        if (modeCfg.highlightFormatting) state.formatting = "link";
	        return getType(state);
	      }

	      if (ch === ']' && state.linkText && stream.match(/\(.*\)| ?\[.*\]/, false)) {
	        if (modeCfg.highlightFormatting) state.formatting = "link";
	        var type = getType(state);
	        state.linkText = false;
	        state.inline = state.f = linkHref;
	        return type;
	      }

	      if (ch === '<' && stream.match(/^(https?|ftps?):\/\/(?:[^\\>]|\\.)+>/, false)) {
	        state.f = state.inline = linkInline;
	        if (modeCfg.highlightFormatting) state.formatting = "link";
	        var type = getType(state);
	        if (type) {
	          type += " ";
	        } else {
	          type = "";
	        }
	        return type + tokenTypes.linkInline;
	      }

	      if (ch === '<' && stream.match(/^[^> \\]+@(?:[^\\>]|\\.)+>/, false)) {
	        state.f = state.inline = linkInline;
	        if (modeCfg.highlightFormatting) state.formatting = "link";
	        var type = getType(state);
	        if (type) {
	          type += " ";
	        } else {
	          type = "";
	        }
	        return type + tokenTypes.linkEmail;
	      }

	      if (ch === '<' && stream.match(/^(!--|\w)/, false)) {
	        var end = stream.string.indexOf(">", stream.pos);
	        if (end != -1) {
	          var atts = stream.string.substring(stream.start, end);
	          if (/markdown\s*=\s*('|"){0,1}1('|"){0,1}/.test(atts)) state.md_inside = true;
	        }
	        stream.backUp(1);
	        state.htmlState = CodeMirror.startState(htmlMode);
	        return switchBlock(stream, state, htmlBlock);
	      }

	      if (ch === '<' && stream.match(/^\/\w*?>/)) {
	        state.md_inside = false;
	        return "tag";
	      }

	      var ignoreUnderscore = false;
	      if (!modeCfg.underscoresBreakWords) {
	        if (ch === '_' && stream.peek() !== '_' && stream.match(/(\w)/, false)) {
	          var prevPos = stream.pos - 2;
	          if (prevPos >= 0) {
	            var prevCh = stream.string.charAt(prevPos);
	            if (prevCh !== '_' && prevCh.match(/(\w)/, false)) {
	              ignoreUnderscore = true;
	            }
	          }
	        }
	      }
	      if (ch === '*' || ch === '_' && !ignoreUnderscore) {
	        if (sol && stream.peek() === ' ') {
	          // Do nothing, surrounded by newline and space
	        } else if (state.strong === ch && stream.eat(ch)) {
	            // Remove STRONG
	            if (modeCfg.highlightFormatting) state.formatting = "strong";
	            var t = getType(state);
	            state.strong = false;
	            return t;
	          } else if (!state.strong && stream.eat(ch)) {
	            // Add STRONG
	            state.strong = ch;
	            if (modeCfg.highlightFormatting) state.formatting = "strong";
	            return getType(state);
	          } else if (state.em === ch) {
	            // Remove EM
	            if (modeCfg.highlightFormatting) state.formatting = "em";
	            var t = getType(state);
	            state.em = false;
	            return t;
	          } else if (!state.em) {
	            // Add EM
	            state.em = ch;
	            if (modeCfg.highlightFormatting) state.formatting = "em";
	            return getType(state);
	          }
	      } else if (ch === ' ') {
	        if (stream.eat('*') || stream.eat('_')) {
	          // Probably surrounded by spaces
	          if (stream.peek() === ' ') {
	            // Surrounded by spaces, ignore
	            return getType(state);
	          } else {
	            // Not surrounded by spaces, back up pointer
	            stream.backUp(1);
	          }
	        }
	      }

	      if (modeCfg.strikethrough) {
	        if (ch === '~' && stream.eatWhile(ch)) {
	          if (state.strikethrough) {
	            // Remove strikethrough
	            if (modeCfg.highlightFormatting) state.formatting = "strikethrough";
	            var t = getType(state);
	            state.strikethrough = false;
	            return t;
	          } else if (stream.match(/^[^\s]/, false)) {
	            // Add strikethrough
	            state.strikethrough = true;
	            if (modeCfg.highlightFormatting) state.formatting = "strikethrough";
	            return getType(state);
	          }
	        } else if (ch === ' ') {
	          if (stream.match(/^~~/, true)) {
	            // Probably surrounded by space
	            if (stream.peek() === ' ') {
	              // Surrounded by spaces, ignore
	              return getType(state);
	            } else {
	              // Not surrounded by spaces, back up pointer
	              stream.backUp(2);
	            }
	          }
	        }
	      }

	      if (ch === ' ') {
	        if (stream.match(/ +$/, false)) {
	          state.trailingSpace++;
	        } else if (state.trailingSpace) {
	          state.trailingSpaceNewLine = true;
	        }
	      }

	      return getType(state);
	    }

	    function linkInline(stream, state) {
	      var ch = stream.next();

	      if (ch === ">") {
	        state.f = state.inline = inlineNormal;
	        if (modeCfg.highlightFormatting) state.formatting = "link";
	        var type = getType(state);
	        if (type) {
	          type += " ";
	        } else {
	          type = "";
	        }
	        return type + tokenTypes.linkInline;
	      }

	      stream.match(/^[^>]+/, true);

	      return tokenTypes.linkInline;
	    }

	    function linkHref(stream, state) {
	      // Check if space, and return NULL if so (to avoid marking the space)
	      if (stream.eatSpace()) {
	        return null;
	      }
	      var ch = stream.next();
	      if (ch === '(' || ch === '[') {
	        state.f = state.inline = getLinkHrefInside(ch === "(" ? ")" : "]");
	        if (modeCfg.highlightFormatting) state.formatting = "link-string";
	        state.linkHref = true;
	        return getType(state);
	      }
	      return 'error';
	    }

	    function getLinkHrefInside(endChar) {
	      return function (stream, state) {
	        var ch = stream.next();

	        if (ch === endChar) {
	          state.f = state.inline = inlineNormal;
	          if (modeCfg.highlightFormatting) state.formatting = "link-string";
	          var returnState = getType(state);
	          state.linkHref = false;
	          return returnState;
	        }

	        if (stream.match(inlineRE(endChar), true)) {
	          stream.backUp(1);
	        }

	        state.linkHref = true;
	        return getType(state);
	      };
	    }

	    function footnoteLink(stream, state) {
	      if (stream.match(/^[^\]]*\]:/, false)) {
	        state.f = footnoteLinkInside;
	        stream.next(); // Consume [
	        if (modeCfg.highlightFormatting) state.formatting = "link";
	        state.linkText = true;
	        return getType(state);
	      }
	      return switchInline(stream, state, inlineNormal);
	    }

	    function footnoteLinkInside(stream, state) {
	      if (stream.match(/^\]:/, true)) {
	        state.f = state.inline = footnoteUrl;
	        if (modeCfg.highlightFormatting) state.formatting = "link";
	        var returnType = getType(state);
	        state.linkText = false;
	        return returnType;
	      }

	      stream.match(/^[^\]]+/, true);

	      return tokenTypes.linkText;
	    }

	    function footnoteUrl(stream, state) {
	      // Check if space, and return NULL if so (to avoid marking the space)
	      if (stream.eatSpace()) {
	        return null;
	      }
	      // Match URL
	      stream.match(/^[^\s]+/, true);
	      // Check for link title
	      if (stream.peek() === undefined) {
	        // End of line, set flag to check next line
	        state.linkTitle = true;
	      } else {
	        // More content on line, check if link title
	        stream.match(/^(?:\s+(?:"(?:[^"\\]|\\\\|\\.)+"|'(?:[^'\\]|\\\\|\\.)+'|\((?:[^)\\]|\\\\|\\.)+\)))?/, true);
	      }
	      state.f = state.inline = inlineNormal;
	      return tokenTypes.linkHref + " url";
	    }

	    var savedInlineRE = [];
	    function inlineRE(endChar) {
	      if (!savedInlineRE[endChar]) {
	        // Escape endChar for RegExp (taken from http://stackoverflow.com/a/494122/526741)
	        endChar = (endChar + '').replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1");
	        // Match any non-endChar, escaped character, as well as the closing
	        // endChar.
	        savedInlineRE[endChar] = new RegExp('^(?:[^\\\\]|\\\\.)*?(' + endChar + ')');
	      }
	      return savedInlineRE[endChar];
	    }

	    var mode = {
	      startState: function () {
	        return {
	          f: blockNormal,

	          prevLine: null,
	          thisLine: null,

	          block: blockNormal,
	          htmlState: null,
	          indentation: 0,

	          inline: inlineNormal,
	          text: handleText,

	          formatting: false,
	          linkText: false,
	          linkHref: false,
	          linkTitle: false,
	          em: false,
	          strong: false,
	          header: 0,
	          hr: false,
	          taskList: false,
	          list: false,
	          listDepth: 0,
	          quote: 0,
	          trailingSpace: 0,
	          trailingSpaceNewLine: false,
	          strikethrough: false,
	          fencedChars: null
	        };
	      },

	      copyState: function (s) {
	        return {
	          f: s.f,

	          prevLine: s.prevLine,
	          thisLine: s.thisLine,

	          block: s.block,
	          htmlState: s.htmlState && CodeMirror.copyState(htmlMode, s.htmlState),
	          indentation: s.indentation,

	          localMode: s.localMode,
	          localState: s.localMode ? CodeMirror.copyState(s.localMode, s.localState) : null,

	          inline: s.inline,
	          text: s.text,
	          formatting: false,
	          linkTitle: s.linkTitle,
	          code: s.code,
	          em: s.em,
	          strong: s.strong,
	          strikethrough: s.strikethrough,
	          header: s.header,
	          hr: s.hr,
	          taskList: s.taskList,
	          list: s.list,
	          listDepth: s.listDepth,
	          quote: s.quote,
	          indentedCode: s.indentedCode,
	          trailingSpace: s.trailingSpace,
	          trailingSpaceNewLine: s.trailingSpaceNewLine,
	          md_inside: s.md_inside,
	          fencedChars: s.fencedChars
	        };
	      },

	      token: function (stream, state) {

	        // Reset state.formatting
	        state.formatting = false;

	        if (stream != state.thisLine) {
	          var forceBlankLine = state.header || state.hr;

	          // Reset state.header and state.hr
	          state.header = 0;
	          state.hr = false;

	          if (stream.match(/^\s*$/, true) || forceBlankLine) {
	            blankLine(state);
	            if (!forceBlankLine) return null;
	            state.prevLine = null;
	          }

	          state.prevLine = state.thisLine;
	          state.thisLine = stream;

	          // Reset state.taskList
	          state.taskList = false;

	          // Reset state.trailingSpace
	          state.trailingSpace = 0;
	          state.trailingSpaceNewLine = false;

	          state.f = state.block;
	          var indentation = stream.match(/^\s*/, true)[0].replace(/\t/g, '    ').length;
	          var difference = Math.floor((indentation - state.indentation) / 4) * 4;
	          if (difference > 4) difference = 4;
	          var adjustedIndentation = state.indentation + difference;
	          state.indentationDiff = adjustedIndentation - state.indentation;
	          state.indentation = adjustedIndentation;
	          if (indentation > 0) return null;
	        }
	        return state.f(stream, state);
	      },

	      innerMode: function (state) {
	        if (state.block == htmlBlock) return { state: state.htmlState, mode: htmlMode };
	        if (state.localState) return { state: state.localState, mode: state.localMode };
	        return { state: state, mode: mode };
	      },

	      blankLine: blankLine,

	      getType: getType,

	      fold: "markdown"
	    };
	    return mode;
	  }, "xml");

	  CodeMirror.defineMIME("text/x-markdown", "markdown");
	});

/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	// CodeMirror, copyright (c) by Marijn Haverbeke and others
	// Distributed under an MIT license: http://codemirror.net/LICENSE

	(function (mod) {
	  if (true) // CommonJS
	    mod(__webpack_require__(129));else if (typeof define == "function" && define.amd) // AMD
	    define(["../lib/codemirror"], mod);else // Plain browser env
	    mod(CodeMirror);
	})(function (CodeMirror) {
	  "use strict";

	  CodeMirror.modeInfo = [{ name: "APL", mime: "text/apl", mode: "apl", ext: ["dyalog", "apl"] }, { name: "PGP", mimes: ["application/pgp", "application/pgp-keys", "application/pgp-signature"], mode: "asciiarmor", ext: ["pgp"] }, { name: "ASN.1", mime: "text/x-ttcn-asn", mode: "asn.1", ext: ["asn", "asn1"] }, { name: "Asterisk", mime: "text/x-asterisk", mode: "asterisk", file: /^extensions\.conf$/i }, { name: "Brainfuck", mime: "text/x-brainfuck", mode: "brainfuck", ext: ["b", "bf"] }, { name: "C", mime: "text/x-csrc", mode: "clike", ext: ["c", "h"] }, { name: "C++", mime: "text/x-c++src", mode: "clike", ext: ["cpp", "c++", "cc", "cxx", "hpp", "h++", "hh", "hxx"], alias: ["cpp"] }, { name: "Cobol", mime: "text/x-cobol", mode: "cobol", ext: ["cob", "cpy"] }, { name: "C#", mime: "text/x-csharp", mode: "clike", ext: ["cs"], alias: ["csharp"] }, { name: "Clojure", mime: "text/x-clojure", mode: "clojure", ext: ["clj"] }, { name: "Closure Stylesheets (GSS)", mime: "text/x-gss", mode: "css", ext: ["gss"] }, { name: "CMake", mime: "text/x-cmake", mode: "cmake", ext: ["cmake", "cmake.in"], file: /^CMakeLists.txt$/ }, { name: "CoffeeScript", mime: "text/x-coffeescript", mode: "coffeescript", ext: ["coffee"], alias: ["coffee", "coffee-script"] }, { name: "Common Lisp", mime: "text/x-common-lisp", mode: "commonlisp", ext: ["cl", "lisp", "el"], alias: ["lisp"] }, { name: "Cypher", mime: "application/x-cypher-query", mode: "cypher", ext: ["cyp", "cypher"] }, { name: "Cython", mime: "text/x-cython", mode: "python", ext: ["pyx", "pxd", "pxi"] }, { name: "CSS", mime: "text/css", mode: "css", ext: ["css"] }, { name: "CQL", mime: "text/x-cassandra", mode: "sql", ext: ["cql"] }, { name: "D", mime: "text/x-d", mode: "d", ext: ["d"] }, { name: "Dart", mimes: ["application/dart", "text/x-dart"], mode: "dart", ext: ["dart"] }, { name: "diff", mime: "text/x-diff", mode: "diff", ext: ["diff", "patch"] }, { name: "Django", mime: "text/x-django", mode: "django" }, { name: "Dockerfile", mime: "text/x-dockerfile", mode: "dockerfile", file: /^Dockerfile$/ }, { name: "DTD", mime: "application/xml-dtd", mode: "dtd", ext: ["dtd"] }, { name: "Dylan", mime: "text/x-dylan", mode: "dylan", ext: ["dylan", "dyl", "intr"] }, { name: "EBNF", mime: "text/x-ebnf", mode: "ebnf" }, { name: "ECL", mime: "text/x-ecl", mode: "ecl", ext: ["ecl"] }, { name: "Eiffel", mime: "text/x-eiffel", mode: "eiffel", ext: ["e"] }, { name: "Elm", mime: "text/x-elm", mode: "elm", ext: ["elm"] }, { name: "Embedded Javascript", mime: "application/x-ejs", mode: "htmlembedded", ext: ["ejs"] }, { name: "Embedded Ruby", mime: "application/x-erb", mode: "htmlembedded", ext: ["erb"] }, { name: "Erlang", mime: "text/x-erlang", mode: "erlang", ext: ["erl"] }, { name: "Factor", mime: "text/x-factor", mode: "factor", ext: ["factor"] }, { name: "Forth", mime: "text/x-forth", mode: "forth", ext: ["forth", "fth", "4th"] }, { name: "Fortran", mime: "text/x-fortran", mode: "fortran", ext: ["f", "for", "f77", "f90"] }, { name: "F#", mime: "text/x-fsharp", mode: "mllike", ext: ["fs"], alias: ["fsharp"] }, { name: "Gas", mime: "text/x-gas", mode: "gas", ext: ["s"] }, { name: "Gherkin", mime: "text/x-feature", mode: "gherkin", ext: ["feature"] }, { name: "GitHub Flavored Markdown", mime: "text/x-gfm", mode: "gfm", file: /^(readme|contributing|history).md$/i }, { name: "Go", mime: "text/x-go", mode: "go", ext: ["go"] }, { name: "Groovy", mime: "text/x-groovy", mode: "groovy", ext: ["groovy"] }, { name: "HAML", mime: "text/x-haml", mode: "haml", ext: ["haml"] }, { name: "Haskell", mime: "text/x-haskell", mode: "haskell", ext: ["hs"] }, { name: "Haxe", mime: "text/x-haxe", mode: "haxe", ext: ["hx"] }, { name: "HXML", mime: "text/x-hxml", mode: "haxe", ext: ["hxml"] }, { name: "ASP.NET", mime: "application/x-aspx", mode: "htmlembedded", ext: ["aspx"], alias: ["asp", "aspx"] }, { name: "HTML", mime: "text/html", mode: "htmlmixed", ext: ["html", "htm"], alias: ["xhtml"] }, { name: "HTTP", mime: "message/http", mode: "http" }, { name: "IDL", mime: "text/x-idl", mode: "idl", ext: ["pro"] }, { name: "Jade", mime: "text/x-jade", mode: "jade", ext: ["jade"] }, { name: "Java", mime: "text/x-java", mode: "clike", ext: ["java"] }, { name: "Java Server Pages", mime: "application/x-jsp", mode: "htmlembedded", ext: ["jsp"], alias: ["jsp"] }, { name: "JavaScript", mimes: ["text/javascript", "text/ecmascript", "application/javascript", "application/x-javascript", "application/ecmascript"],
	    mode: "javascript", ext: ["js"], alias: ["ecmascript", "js", "node"] }, { name: "JSON", mimes: ["application/json", "application/x-json"], mode: "javascript", ext: ["json", "map"], alias: ["json5"] }, { name: "JSON-LD", mime: "application/ld+json", mode: "javascript", ext: ["jsonld"], alias: ["jsonld"] }, { name: "Jinja2", mime: "null", mode: "jinja2" }, { name: "Julia", mime: "text/x-julia", mode: "julia", ext: ["jl"] }, { name: "Kotlin", mime: "text/x-kotlin", mode: "clike", ext: ["kt"] }, { name: "LESS", mime: "text/x-less", mode: "css", ext: ["less"] }, { name: "LiveScript", mime: "text/x-livescript", mode: "livescript", ext: ["ls"], alias: ["ls"] }, { name: "Lua", mime: "text/x-lua", mode: "lua", ext: ["lua"] }, { name: "Markdown", mime: "text/x-markdown", mode: "markdown", ext: ["markdown", "md", "mkd"] }, { name: "mIRC", mime: "text/mirc", mode: "mirc" }, { name: "MariaDB SQL", mime: "text/x-mariadb", mode: "sql" }, { name: "Mathematica", mime: "text/x-mathematica", mode: "mathematica", ext: ["m", "nb"] }, { name: "Modelica", mime: "text/x-modelica", mode: "modelica", ext: ["mo"] }, { name: "MUMPS", mime: "text/x-mumps", mode: "mumps" }, { name: "MS SQL", mime: "text/x-mssql", mode: "sql" }, { name: "MySQL", mime: "text/x-mysql", mode: "sql" }, { name: "Nginx", mime: "text/x-nginx-conf", mode: "nginx", file: /nginx.*\.conf$/i }, { name: "NSIS", mime: "text/x-nsis", mode: "nsis", ext: ["nsh", "nsi"] }, { name: "NTriples", mime: "text/n-triples", mode: "ntriples", ext: ["nt"] }, { name: "Objective C", mime: "text/x-objectivec", mode: "clike", ext: ["m", "mm"] }, { name: "OCaml", mime: "text/x-ocaml", mode: "mllike", ext: ["ml", "mli", "mll", "mly"] }, { name: "Octave", mime: "text/x-octave", mode: "octave", ext: ["m"] }, { name: "Oz", mime: "text/x-oz", mode: "oz", ext: ["oz"] }, { name: "Pascal", mime: "text/x-pascal", mode: "pascal", ext: ["p", "pas"] }, { name: "PEG.js", mime: "null", mode: "pegjs", ext: ["jsonld"] }, { name: "Perl", mime: "text/x-perl", mode: "perl", ext: ["pl", "pm"] }, { name: "PHP", mime: "application/x-httpd-php", mode: "php", ext: ["php", "php3", "php4", "php5", "phtml"] }, { name: "Pig", mime: "text/x-pig", mode: "pig", ext: ["pig"] }, { name: "Plain Text", mime: "text/plain", mode: "null", ext: ["txt", "text", "conf", "def", "list", "log"] }, { name: "PLSQL", mime: "text/x-plsql", mode: "sql", ext: ["pls"] }, { name: "Properties files", mime: "text/x-properties", mode: "properties", ext: ["properties", "ini", "in"], alias: ["ini", "properties"] }, { name: "Python", mime: "text/x-python", mode: "python", ext: ["py", "pyw"] }, { name: "Puppet", mime: "text/x-puppet", mode: "puppet", ext: ["pp"] }, { name: "Q", mime: "text/x-q", mode: "q", ext: ["q"] }, { name: "R", mime: "text/x-rsrc", mode: "r", ext: ["r"], alias: ["rscript"] }, { name: "reStructuredText", mime: "text/x-rst", mode: "rst", ext: ["rst"], alias: ["rst"] }, { name: "RPM Changes", mime: "text/x-rpm-changes", mode: "rpm" }, { name: "RPM Spec", mime: "text/x-rpm-spec", mode: "rpm", ext: ["spec"] }, { name: "Ruby", mime: "text/x-ruby", mode: "ruby", ext: ["rb"], alias: ["jruby", "macruby", "rake", "rb", "rbx"] }, { name: "Rust", mime: "text/x-rustsrc", mode: "rust", ext: ["rs"] }, { name: "Sass", mime: "text/x-sass", mode: "sass", ext: ["sass"] }, { name: "Scala", mime: "text/x-scala", mode: "clike", ext: ["scala"] }, { name: "Scheme", mime: "text/x-scheme", mode: "scheme", ext: ["scm", "ss"] }, { name: "SCSS", mime: "text/x-scss", mode: "css", ext: ["scss"] }, { name: "Shell", mime: "text/x-sh", mode: "shell", ext: ["sh", "ksh", "bash"], alias: ["bash", "sh", "zsh"], file: /^PKGBUILD$/ }, { name: "Sieve", mime: "application/sieve", mode: "sieve", ext: ["siv", "sieve"] }, { name: "Slim", mimes: ["text/x-slim", "application/x-slim"], mode: "slim", ext: ["slim"] }, { name: "Smalltalk", mime: "text/x-stsrc", mode: "smalltalk", ext: ["st"] }, { name: "Smarty", mime: "text/x-smarty", mode: "smarty", ext: ["tpl"] }, { name: "Solr", mime: "text/x-solr", mode: "solr" }, { name: "Soy", mime: "text/x-soy", mode: "soy", ext: ["soy"], alias: ["closure template"] }, { name: "SPARQL", mime: "application/sparql-query", mode: "sparql", ext: ["rq", "sparql"], alias: ["sparul"] }, { name: "Spreadsheet", mime: "text/x-spreadsheet", mode: "spreadsheet", alias: ["excel", "formula"] }, { name: "SQL", mime: "text/x-sql", mode: "sql", ext: ["sql"] }, { name: "Squirrel", mime: "text/x-squirrel", mode: "clike", ext: ["nut"] }, { name: "Swift", mime: "text/x-swift", mode: "swift", ext: ["swift"] }, { name: "MariaDB", mime: "text/x-mariadb", mode: "sql" }, { name: "sTeX", mime: "text/x-stex", mode: "stex" }, { name: "LaTeX", mime: "text/x-latex", mode: "stex", ext: ["text", "ltx"], alias: ["tex"] }, { name: "SystemVerilog", mime: "text/x-systemverilog", mode: "verilog", ext: ["v"] }, { name: "Tcl", mime: "text/x-tcl", mode: "tcl", ext: ["tcl"] }, { name: "Textile", mime: "text/x-textile", mode: "textile", ext: ["textile"] }, { name: "TiddlyWiki ", mime: "text/x-tiddlywiki", mode: "tiddlywiki" }, { name: "Tiki wiki", mime: "text/tiki", mode: "tiki" }, { name: "TOML", mime: "text/x-toml", mode: "toml", ext: ["toml"] }, { name: "Tornado", mime: "text/x-tornado", mode: "tornado" }, { name: "troff", mime: "troff", mode: "troff", ext: ["1", "2", "3", "4", "5", "6", "7", "8", "9"] }, { name: "TTCN", mime: "text/x-ttcn", mode: "ttcn", ext: ["ttcn", "ttcn3", "ttcnpp"] }, { name: "TTCN_CFG", mime: "text/x-ttcn-cfg", mode: "ttcn-cfg", ext: ["cfg"] }, { name: "Turtle", mime: "text/turtle", mode: "turtle", ext: ["ttl"] }, { name: "TypeScript", mime: "application/typescript", mode: "javascript", ext: ["ts"], alias: ["ts"] }, { name: "Twig", mime: "text/x-twig", mode: "twig" }, { name: "VB.NET", mime: "text/x-vb", mode: "vb", ext: ["vb"] }, { name: "VBScript", mime: "text/vbscript", mode: "vbscript", ext: ["vbs"] }, { name: "Velocity", mime: "text/velocity", mode: "velocity", ext: ["vtl"] }, { name: "Verilog", mime: "text/x-verilog", mode: "verilog", ext: ["v"] }, { name: "VHDL", mime: "text/x-vhdl", mode: "vhdl", ext: ["vhd", "vhdl"] }, { name: "XML", mimes: ["application/xml", "text/xml"], mode: "xml", ext: ["xml", "xsl", "xsd"], alias: ["rss", "wsdl", "xsd"] }, { name: "XQuery", mime: "application/xquery", mode: "xquery", ext: ["xy", "xquery"] }, { name: "YAML", mime: "text/x-yaml", mode: "yaml", ext: ["yaml", "yml"], alias: ["yml"] }, { name: "Z80", mime: "text/x-z80", mode: "z80", ext: ["z80"] }, { name: "mscgen", mime: "text/x-mscgen", mode: "mscgen", ext: ["mscgen", "mscin", "msc"] }, { name: "xu", mime: "text/x-xu", mode: "mscgen", ext: ["xu"] }, { name: "msgenny", mime: "text/x-msgenny", mode: "mscgen", ext: ["msgenny"] }];
	  // Ensure all modes have a mime property for backwards compatibility
	  for (var i = 0; i < CodeMirror.modeInfo.length; i++) {
	    var info = CodeMirror.modeInfo[i];
	    if (info.mimes) info.mime = info.mimes[0];
	  }

	  CodeMirror.findModeByMIME = function (mime) {
	    mime = mime.toLowerCase();
	    for (var i = 0; i < CodeMirror.modeInfo.length; i++) {
	      var info = CodeMirror.modeInfo[i];
	      if (info.mime == mime) return info;
	      if (info.mimes) for (var j = 0; j < info.mimes.length; j++) if (info.mimes[j] == mime) return info;
	    }
	  };

	  CodeMirror.findModeByExtension = function (ext) {
	    for (var i = 0; i < CodeMirror.modeInfo.length; i++) {
	      var info = CodeMirror.modeInfo[i];
	      if (info.ext) for (var j = 0; j < info.ext.length; j++) if (info.ext[j] == ext) return info;
	    }
	  };

	  CodeMirror.findModeByFileName = function (filename) {
	    for (var i = 0; i < CodeMirror.modeInfo.length; i++) {
	      var info = CodeMirror.modeInfo[i];
	      if (info.file && info.file.test(filename)) return info;
	    }
	    var dot = filename.lastIndexOf(".");
	    var ext = dot > -1 && filename.substring(dot + 1, filename.length);
	    if (ext) return CodeMirror.findModeByExtension(ext);
	  };

	  CodeMirror.findModeByName = function (name) {
	    name = name.toLowerCase();
	    for (var i = 0; i < CodeMirror.modeInfo.length; i++) {
	      var info = CodeMirror.modeInfo[i];
	      if (info.name.toLowerCase() == name) return info;
	      if (info.alias) for (var j = 0; j < info.alias.length; j++) if (info.alias[j].toLowerCase() == name) return info;
	    }
	  };
	});

/***/ }
/******/ ]);